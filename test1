/* -------------------------------------------------------------------------
 * MODULE:      d8_network.c
 * -------------------------------------------------------------------------
 * DESCRIPTION: Routines to interface with the network server.
 * -------------------------------------------------------------------------
 * COPYRIGHT:   (c) 2005-2011 Censerve Consulting, Inc
 * ------------------------------------------------------------------------- */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/timeb.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <net/if.h>
#include <netinet/in.h>
#include <signal.h>
#include <limits.h>

#include <SDL.h>
#include <SDL_thread.h>
#include <SDL_ttf.h>

#include "D8Game.h"
#include "d8_globals.h"
#include "d8_flashmem.h"
#include "d8_network.h"
#include "SAS.h"
#include "SASdef.h"
#include "d8_ioboard.h"
#include "d8_denomination.h"
#include "Bingo.h"
#include "eventLog.h"
#ifdef PULLTAB
#include "PullTab.h"
#endif
#if defined(PICKAPRIZE) && !defined(ATRIB2)
#include "GCol_BonusGame.h"
#else
#include "PBonusGame.h"
#endif

#ifdef PULLTAB
int TopBonusPrizeX = 0;
unsigned long lastEventTime = 0;
#endif

#ifndef PRODUCTION
//#define notdef1	1		//remove comment to print debug messages
#endif
//#define	bingo_debug	1

//#define TEST_OFS	1

#ifdef LOADTEST
extern int doAutoPlay;
#endif

#ifndef PRODUCTION
#ifdef TEST_OFS
int doActivityTest = 1;
#else
int doActivityTest = 0;
#endif
int doLoginTest = 0;
#ifdef notdef
int doCommsOnLineTest = 1;
#endif
#endif
#ifndef PRODUCTION
#define notdef2		1		//
#endif
#define ENCRYPTMSG	1
#define	DECRYPTMSG	2

unsigned long lastEventTime = 0;
static int _NeedServerConfig = 0;
MultiProg multiProg[10];
void JackpotInfoReInit();
int payRangeChanged = 0;

#ifdef FORCE_CNET_DISCONNECT
static int keepAliveCnt = 0;
#endif

#ifdef BINGO
extern BingoCardInfo _BCInfo;
static int NeedTestLogin = 0;
static int LastTestLoginTime = 0;
static int LastHistoryTime = 0;		// last time bingo:history was sent
#endif
static int LastGameActivityTime = 0;	// last time progressive:gameActivity was sent
static int LastProgHitTime = 0;		// last time progressive:progressiveHit was sent
#ifdef USE_MAG_CARD
static int LastPurchaseTime = 0;
#else
static int LastCashInfoTime = 0;	// last time progressive:cashinfo was sent
#endif
static int LastReceivedTime = 0;

extern int GetWinCredits(int linesBet);
extern int msg_crypt(char *message,char *dest, int length,int action);

typedef struct {
        char Class[64];
        char EgmID[64];
        char CommandID[64];
        char Command[64];
        //char Data[512];
	char Data[2049+1024];
        } EGM_CLASS;

#define DPAIR_LEN 255

typedef struct {
        char key[256];
        char data[DPAIR_LEN+1];
        } DATA_PAIRS;

#ifdef USE_MAG_CARD
 #ifndef USE_MAG_CARD_ONLY
  void SavePurchaseBuf();
  void ReloadPurchaseBuf();
 #endif
#else
void SaveCashInfoBuf();
void ReloadCashInfoBuf();
#endif
void SaveLastActivityBuf();
void ReloadLastActivityBuf();
void SaveHistoryBuf();
void ReloadLastHistoryBuf();
void SaveLastProgHitBuf();
void ReloadLastProgHitBuf();
int GetDenomLevel(int denom);
void sort ( long * data, int cnt);
int OpenSocket(char *server, int port,struct sockaddr_in *dest_addr,struct sockaddr_in *eserver);
SDL_bool sendClass(int sockfd,struct sockaddr *destAddr,char *Class,char *EgmID,char *Command,char *Data);
char *getTimeStamp(void);
//SDL_bool waitForServerOnlineAck(int sockfd,struct sockaddr_in *dest_addr);
void decodeClass(char *rxbuf,EGM_CLASS *egmclass);

void processReceivedClass(int sockfd,struct sockaddr *destAddr,char *rxbuf, int numbytes);
void processCommunicationsClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);
void processCabinetClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);

//NEW:
void processProgressiveClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);   //progressive
#ifdef BINGO
void processBingoClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);         //bingo
#endif
void processErrorFromServer(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);
void processBadClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);
extern SDL_bool IsChirping();

void extractDataPairs(char *rawdata,DATA_PAIRS *dpairs,int count);
void extractDataPairsDelim(char *rawdata,DATA_PAIRS *dpairs,int count, char delim);
void parseNext(char *rawdata,long *value,int count, char delim);
void parseNextChar(char *rawdata,char *value,int count, char delim);
void parseNextStr(char *rawdata,char *value,int count, char delim);
int NetworkThread(void *da);
long long ReadNVRam(unsigned char Addr);

int FmReadData(long loc, long nbytes, unsigned char *buf1, int printit);
long long ReadNVRam(unsigned char Addr);
void IoBoard_WriteRTC();
int EraseSector(long Sector, int printit);
void FlashVoucherLog(voucherLogType *vl);
void FlashHandpayLog(voucherLogType *vl);
void SetDateTime(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass);
int GetServerPort(void);
void GetServerIP(char *server);
char _stringFalse[]="false";
char _stringTrue[]="true";

int _Socket = -1;
int _ConnectionCount = 0;			// number of attempts to connect
int echosock;
// Secure Enhanced Validation
#ifdef SASMODE
extern unsigned char seva[6];
#else
unsigned char seva[6];
#endif
unsigned char sevb[6];
unsigned char sevc[6];
extern unsigned char instate51;                 // SAS 
extern unsigned char instate57;                 // System Validation
extern unsigned long putst57;                   // System Validation timer
extern unsigned char SVVid[];
extern int availLinesBet[];
#ifdef DO_TITO
extern int rejectTic;
#endif
int progrcvd[5] = {0,0,0,0,0};
static Uint32 _StartOnlineTick=0;
static Uint32 _StartKeepAliveTick=0;
SDL_bool _OnlineAcked = SDL_FALSE;
SDL_bool _Reconnect=SDL_FALSE;
struct sockaddr_in _DestAddr;
struct sockaddr_in echoserver;
SDL_bool _BrokenPipe = SDL_FALSE;
char notsentbuf[SNPRINTF_LIMIT+1];
void FlashEvent(int evType, char *subev, int eventCode);
SDL_bool HaveCashInfo2Send();
void SendCashInfo1(cashinfo *cinfo);

/*   Variables that need to be set */

char _EgmLocation[] = "carousel#1";
char _BobVersion[] = "1.0.0";

SDL_bool _hasDateTime = SDL_FALSE;
SDL_bool _GEPamtReceived = SDL_FALSE;
int serverConfigError = 0;

#ifdef BINGO
static int setid = 0;			// bingo pattern set id
//static int paylevel = 0;		// pay table level (1-4) for 90%,92%,94%,95% payout
static int needPatterns = 1;		// only request patterns and win amounts once
int paylevelcount = 0;			// number of pay levels
int paylevelvalues[5] = {0,0,0,0,0};	// pay out percentage of each pay level
static SDL_bool bingoPatternsDone = SDL_FALSE;
SDL_bool IsBingoPatternsDone();
#endif

static int keepAliveInterval = 10000;
static SDL_bool forceKeepAlive = SDL_FALSE;

char lastGAbuf[TRANSLOGSIZE];			// data for last sendGameActivity
char lastGameHist[TRANSLOGSIZE];		// data for last game history transaction
char lastProgHitbuf[TRANSLOGSIZE];		// data for last progressive hit transaction
char lastProgCelebBuf[TRANSLOGSIZE];		// data for last progressive Celeb transaction
#ifdef USE_MAG_CARD
char lastPurchasebuf[TRANSLOGSIZE];		// date for last purchase transaction
#else
char lastCIbuf[TRANSLOGSIZE];			// data for last cashinfo
#endif
#ifdef CS030
char lastTimeBuf[32];			// used for power down time
char lastPowerOffTime[32];
unsigned long lastTimeTick = 0;
#endif
#ifdef CASHPLAY
static int lastGetNewPinTime = 0;
void SendBingoGetPin();
#endif
#ifdef BINGO
 #ifdef PULLTAB
  char *acctStr = "account";
  char *gameStr = "pulltab";
 #else
  char *acctStr = "bingo";
  char *gameStr = "bingo";
 #endif
#else
  char *acctStr = "bingo";
  char *gameStr = "bingo";
#endif
void GetServerIP(char *server);

SDL_bool IsNetworkConfigValid(void)
{
//#ifdef MEXICO
//	return SDL_FALSE;
//#else
#ifdef LOADTEST
	fprintf(_debugPort, "%d.%d.%d.%d %d,%d\n", _GlobalConfig.ServerIPAddress[0], 
		_GlobalConfig.ServerIPAddress[1], _GlobalConfig.ServerIPAddress[2], 
		_GlobalConfig.ServerIPAddress[3], _GlobalConfig.ServerPort, 
		_ExtendedConfig.SASGroup);
#endif
        if(_GlobalConfig.ServerIPAddress[0]<0 || _GlobalConfig.ServerIPAddress[1]<0 ||
        _GlobalConfig.ServerIPAddress[2]<0 || _GlobalConfig.ServerIPAddress[3]<0 ||
        _GlobalConfig.ServerPort<0 || _ExtendedConfig.SASGroup==0)
                return SDL_FALSE;
        else
                return SDL_TRUE;
//#endif
}

#ifdef TABLET
static int BLcount = 0;		// number of times creating BL.txt.
				// if we have wireless signal, but cannot connect to server, we create BL.txt to tell getmacip
				//   to reacquire mac address and wireless
int GetBLcount()
{
	return BLcount;
}
#endif

SDL_bool DoNetworkConnection(void)
{
        char server[256]="";
        int port;
#ifdef TABLET
	int cnt;
	int level = 0;

#ifndef LOADTEST
	if (_GlobalConfig.useWireless == 1)
		level = GetSignalLevel();		// get wireless signal level
	else
		level = 100;
	
	if (IsNetworkConfigValid() == SDL_TRUE) {
		//CheckWireless(NULL);
		if (level == 0)
			_ConnectionCount = 0;
		
		if (level < -90) level = 0;
	
		//if ((sysret) || (level == 0)){		// don't try to reconnect if no wireless or poor signal
//		if (((sysret) && (sysret != 256)) || (level == 0)){		// don't try to reconnect if no wireless or poor signal
		if (level == 0){		// don't try to reconnect if no wireless or poor signal
			//if (sysret && sysret != 256)
			//	AcquireWireless();
			_ConnectionCount = 0;
			return SDL_FALSE;
		}
	}
#endif
#endif

        if(IsNetworkConfigValid() == SDL_TRUE)
        {
                _Socket = -1;
#ifndef LOADTEST
                sprintf(server,"%d.%d.%d.%d",_GlobalConfig.ServerIPAddress[0],_GlobalConfig.ServerIPAddress[1], _GlobalConfig.ServerIPAddress[2],_GlobalConfig.ServerIPAddress[3]);
                port = _GlobalConfig.ServerPort-1;  //Base 0 to 1 Change   ie. egm setup as 1 but we send a 0 to CasinoNet
 #ifdef notdef2
  #ifdef TABLET
		//port += 1;		// faking different port address
                fprintf(_debugPort, "Connecting to [%s] on Port[%d] %s level=%d\n",server,port,getTimeStamp(),level);
  #else
                fprintf(_debugPort, "Connecting to [%s] on Port[%d] %s\n",server,port,getTimeStamp());
  #endif
 #endif
#else
		GetServerIP(server);
		port = GetServerPort();
#endif
                printf("Connecting to [%s] on Port[%d]\n",server,port);
                _Socket = OpenSocket(server,port,&_DestAddr,&echoserver);
		printf("_Socket=%d\n",_Socket);
                if ((_Socket >= 0) && (_BrokenPipe == SDL_TRUE))
                {
                        //setsockopt  
                        _Reconnect = SDL_FALSE;
                         _BrokenPipe = SDL_FALSE;
                         return SDL_TRUE;
                } else {		// DEBUG
			if (_BrokenPipe == SDL_TRUE) {		// DEBUG
#ifdef notdef2
				fprintf(_debugPort, "_Socket = %d\n",_Socket);		// DEBUG
#endif
#ifdef TABLET
 #ifndef LOADTEST
				if (_ConnectionCount > 10) {
					FILE *fp;
					//system(sudostr1);		// do ifdown
					fp = fopen("./BL.txt","a+");
					++BLcount;
					fclose(fp);
					_ConnectionCount = 0;
				}
 #endif
#endif
			}
		}
        }
        return SDL_FALSE;
}  

void Signal_PipeHandler(int signum)
{
        return;
}

SDL_bool checkNetworkConnected()
{
        SDL_bool netConnected;

         if(IsNetworkConfigValid() == SDL_TRUE)
         {
                 netConnected = Network_Connect();
         } else
                 netConnected = SDL_FALSE;
#ifdef LOADTEST
	fprintf(_debugPort, "checkNetworkConnected() %d\n", netConnected);
#endif
         return netConnected;
}

SDL_bool Network_Connect(void)
{
#ifdef CNPROGRESSIVE
        SDL_bool Connected = SDL_FALSE;
  
        signal(SIGPIPE,Signal_PipeHandler);
   
//        if(DoNetworkConnection() == SDL_TRUE)
//        {
//                fprintf(_debugPort, "DoNetworkConnection succeeded - _NetworkThreadRun = %d\n", _NetworkThreadRun);
                if (_NetworkThread == NULL)
                {
                        //START THE THREAD HERE
                        _NetworkThread = SDL_CreateThread(NetworkThread,(void *)NULL);
                        if (_NetworkThread != NULL)
                        {
                                _BrokenPipe=SDL_TRUE;
                                Connected = SDL_TRUE;
                                _progressiveValueReceived = SDL_FALSE;
                                _KeepAliveTick = -1;
#ifdef BINGO
				//_BCInfo.serialnum = 0;
				//fprintf(_debugPort, "clearing serial number\n");
				SetBingoDisconnectState(BDIS_DISCONNECT);
#endif
                        }
                }
//        }
#ifdef notdef
        fprintf(_debugPort,"Network_Connect: _NetworkThread=%p Connected=%d\n",_NetworkThread,Connected);
#endif
        return Connected;
#endif
        return SDL_FALSE;
}

void SendKeepAlive(struct sockaddr *dest_addr)
{
        char buf[2049+1024];
#ifdef FORCE_CNET_DISCONNECT_1
	if (++keepAliveCnt > 2) {
		keepAliveCnt = 0;
		fprintf(_debugPort, "Force BrokenPipe\n");
		_BrokenPipe = SDL_TRUE;         // no socket - what happened???
		return;
	}
#endif
	if (_OnlineAcked == SDL_TRUE) {
        	_StartKeepAliveTick = SDL_GetTicks();
#ifdef VICTORYLAND
		//if ((IsBingoPatternsDone() == SDL_TRUE) && NeedTestLogin == 1) {
		if (NeedTestLogin == 1) {
			//if (IsBingoPatternsDone() == SDL_TRUE) 
			{
				fprintf(_debugPort, "SendKeepAlive: need test login\n");
				sprintf(buf,"macaddr=%s,passport=%s,pin=0000,mindenom=%d",macaddr,_BCInfo.passport,_Denominations[0]);
				sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"login",buf);
			}
        		_keepAliveSent = SDL_TRUE;                  // Tell the scheduler we sent a keepAlive 	
			forceKeepAlive = SDL_FALSE;
			LastTestLoginTime = SDL_GetTicks();
			return;	
		}
 #ifndef PRODUCTION
		if (IsWaiting4APIack() == SDL_TRUE) {
			fprintf(_debugPort, "bonusInfo.waiting4GAack = %x, OutOfService=%d\n", bonusInfo.waiting4GAack, OutOfService());
			fprintf(_debugPort, "LastGameActivityTime=%d, %d\n",LastGameActivityTime, SDL_GetTicks());
		}
 #endif
		if (OutOfService() == SDL_FALSE && (IsWaiting4APIack() == SDL_TRUE)) {
#else
		if (IsWaiting4APIack() == SDL_TRUE) {
#endif
			forceKeepAlive = SDL_FALSE;
			if (IsWaiting4PurchaseAck() == SDL_TRUE) {
#ifdef USE_MAG_CARD
 #ifndef USE_MAG_CARD_ONLY
				if ((LastPurchaseTime + 3*SEC2TICKS) <= SDL_GetTicks()) {
					sendClass(_Socket, dest_addr, "progressive", _TheEgmID, "purchase", lastPurchasebuf);
					LastPurchaseTime = SDL_GetTicks();
				}
 #endif
#else
				if ((LastCashInfoTime + 3*SEC2TICKS) <= SDL_GetTicks()) {
					sendClass(_Socket, dest_addr, "progressive", _TheEgmID, "cashinfo", lastCIbuf);
					LastCashInfoTime = SDL_GetTicks();
				}
#endif
			}
#ifdef BINGO
			if (IsWaiting4HistoryAck() == SDL_TRUE) {
				if ((LastHistoryTime + 3*SEC2TICKS) <= SDL_GetTicks()) {
					sendClass(_Socket,dest_addr,gameStr,_TheEgmID,"history",lastGameHist);
					LastHistoryTime = SDL_GetTicks();
				}
			}
#endif
			if (IsWaiting4GameActivityAck() == SDL_TRUE) {
				if ((LastGameActivityTime + 3*SEC2TICKS) <= SDL_GetTicks()) {
					if ((VNetOnLine() == SDL_TRUE) && 
#ifdef VICTORYLAND
						(_GlobalMeters.serverLock != 4)) 
#else
						(SDL_TRUE))
#endif
					{
        					sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"gameActivity",lastGAbuf);
						LastGameActivityTime = SDL_GetTicks();
					}
				}
			}
		} 
		if (bonusInfo.waiting4ProgHitAck) {
			if ((LastProgHitTime + 3*SEC2TICKS) <= SDL_GetTicks()) {
				sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"progressiveHit",lastProgHitbuf);	
				LastProgHitTime = SDL_GetTicks();
			}
		} 
		{
#ifdef VICTORYLAND
			int state;
			state = DeviceState();
			if (state == 4 || state == 8) {
				if (CheckUnlockFlag() == SDL_TRUE) {		// we are already unlocked
					if (_CurrentPlayerAccount > 0) {
						state = 1;
					} else {
						state = 0;
					}
				//} else if (IsBingoPatternsDone() == SDL_FALSE) {
				//	state = 1;
				} else {
					if ((NeedTestLogin == 0) && ((LastTestLoginTime == 0) ||
						((LastTestLoginTime + (3*MIN2TICKS)) < SDL_GetTicks()))) {
						NeedTestLogin = 1;
						LastTestLoginTime = SDL_GetTicks();
					}
				}
			}
			forceKeepAlive = SDL_FALSE;
			if (strlen(_BCInfo.passport) == 0)
				sprintf(buf,"CommDateTime=%s,status=%1d,passport=%s",getTimeStamp(),state,"0000");
			else
				sprintf(buf,"CommDateTime=%s,status=%1d,passport=%s",getTimeStamp(),state,_BCInfo.passport);
#else
			sprintf(buf,"CommDateTime=%s",getTimeStamp());
#endif
			sendClass(_Socket,dest_addr,"communications",_TheEgmID,"keepAlive",buf);
			//fprintf(_debugPort, "keepalive\n");
		}
        	_keepAliveSent = SDL_TRUE;                              // Tell the scheduler we sent a keepAlive to CasinoNet
#ifndef LOADTEST
		if (lastEventTime && ((SDL_GetTicks() - lastEventTime) > 1000)) {
			extern void ResendEvent();
			ResendEvent();
		} else if ((lastEventTime == 0) && (EQ.NumUnread > 0)) {
			ResendEvent();
		}
#endif
#ifdef CASHPLAY
		if ((strlen(_BCInfo.newpin) == 0) && (LoggedIn() == SDL_FALSE)) { 
			if ((lastGetNewPinTime == 0) || ((SDL_GetTicks() - lastGetNewPinTime) > 3000)) {
				SendBingoGetPin();
			}
		}
#endif
	}
}

int NetworkThread(void *p)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        fd_set rd;
        struct timeval timeout;
        int readsocks;

        if(_NetworkSendPacketMutex==NULL)
                _NetworkSendPacketMutex=SDL_CreateMutex();

        for(;_NetworkThreadRun == SDL_TRUE;)
        {
                char buf[2049+1024];
                int numbytes;
                Uint32 currentTick;
                char databuf[256];
		static char partialbuf[2048+1024];
		static int partialCt = 0;
		int start;

                if (_BrokenPipe == SDL_TRUE)
                {
                        int i;
                        for (i=0; i<_numDenomLevels; i++)               // reset the denom level values.
                                progrcvd[i] = 0;
                        _progressiveValueReceived = SDL_FALSE;          // we need to get new progressive values before we can run
#ifdef BINGO
			//_GEPamtReceived = SDL_FALSE;
			//_BCInfo.serialnum = 0;
			//fprintf(_debugPort, "clearing serial number\n");
			SetBingoDisconnectState(BDIS_DISCONNECT);
#endif
			//serverConfigError = 0;
			serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
                        Network_Close();
                        if (DoNetworkConnection() == SDL_TRUE)
                        {
                                _KeepAliveTick = keepAliveInterval - 2000;		//3000;                   // -1 disables  keepAliveTicks 30000 is 3 seconds
                                _BrokenPipe = SDL_FALSE;
                                _OnlineAcked = SDL_FALSE;
                                _StartOnlineTick = SDL_GetTicks();
                                //Sending commsOnLine
#ifdef BINGO
 #ifdef PULLTAB
				TopBonusPrizeX = 0;
                                sprintf(databuf,"bobVersion=%s,egmLocation=%s,CommDateTime=%s,progressive=%d,pulltab=1,GameName=%s,macaddr=%s,asset=%d,gameser=%d",
 #else
                                sprintf(databuf,"bobVersion=%s,egmLocation=%s,CommDateTime=%s,progressive=%d,bingo=1,GameName=%s,macaddr=%s,asset=%d,gameser=%d",
 #endif
					_BobVersion,_EgmLocation,getTimeStamp(),
                                        ((_ExtendedConfig.ProgControllerType == 2)?_ExtendedConfig.SASGroup:0),_ProductId,macaddr,_GlobalConfig.assetID, _GlobalConfig.MachineID);
#else
                                sprintf(databuf,"bobVersion=%s,egmLocation=%s,CommDateTime=%s,progressive=%d,GameName=%s,asset=%d,gameser=%d",_BobVersion,_EgmLocation,getTimeStamp(),
                                        ((_ExtendedConfig.ProgControllerType == 2)?_ExtendedConfig.SASGroup:0),_ProductId,_GlobalConfig.assetID, _GlobalConfig.MachineID);
#endif
				LastReceivedTime = _StartOnlineTick;
                                sendClass(_Socket,dest_addr,"communications",_TheEgmID,"commsOnLine",databuf);
#ifdef FORCE_CNET_DISCONNECT
				keepAliveCnt = 0;
#endif
				if (_ExtendedConfig.denominations[0] == 0)
					_NeedServerConfig=1;
#ifdef VICTORYLAND
				i = DeviceState();
				if ((i == 4) || (i == 8)) {	//  jackpot lockup or out of service
					NeedTestLogin = 1;
					LastTestLoginTime = SDL_GetTicks();
				} else {
					NeedTestLogin = 0;
					LastTestLoginTime = 0;
				}
#endif
#ifdef notdef2
                                fprintf(_debugPort,"Sent commsOnline to %s:%s\n", _TheEgmID,databuf);
#endif
                        }
                        else
                        {
#ifdef TABLET
				//if (sysret || GetSignalLevel()==0) {
//				if ((sysret && (sysret != 256)) || GetSignalLevel()==0) {
				if (_GlobalConfig.useWireless == 1 && GetSignalLevel()==0) {
					// if wireless lost signal, don't sleep 5 s
				} else
#endif
                                	SDL_Delay(5000);                                      //wait 5s before trying another reconnect
                                _KeepAliveTick = -1;
                        }
                }
                else
                {
                        currentTick = SDL_GetTicks();
                        if((_OnlineAcked == SDL_FALSE) && ((currentTick - _StartOnlineTick) > 10000)) //more than 10s waiting for commsonline ack
                        {
				if (LastReceivedTime > _StartOnlineTick) {
#ifdef PULLTAB
                                	sprintf(databuf,"bobVersion=%s,egmLocation=%s,CommDateTime=%s,progressive=%d,pulltab=%d,GameName=%s,macaddr=%s,asset=%d,gameser=%d",
#else
                                	sprintf(databuf,"bobVersion=%s,egmLocation=%s,CommDateTime=%s,progressive=%d,bingo=%d,GameName=%s,macaddr=%s,asset=%d,gameser=%d",
#endif
						_BobVersion,_EgmLocation,getTimeStamp(),
                                        	((_ExtendedConfig.ProgControllerType == 2)?_ExtendedConfig.SASGroup:0),
#ifdef BINGO
						1,
#else
						0,
#endif
						_ProductId,macaddr,_GlobalConfig.assetID, _GlobalConfig.MachineID);
					LastReceivedTime = SDL_GetTicks();
					_StartOnlineTick = LastReceivedTime;
                                	sendClass(_Socket,dest_addr,"communications",_TheEgmID,"commsOnLine",databuf);
#ifdef FORCE_CNET_DISCONNECT
					keepAliveCnt = 0;
#endif
				} else {
//#ifndef PRODUCTION
//				fprintf(_debugPort, "_BrokenPipe at %s, %s\n", getTimeStamp(), _StartOnlineTick);
//#endif
                                	_BrokenPipe = SDL_TRUE;
                                	_KeepAliveTick = -1;
				}
                        }
                        else if((forceKeepAlive == SDL_TRUE && _OnlineAcked == SDL_TRUE) || 
				((_keepAliveSent == SDL_FALSE) && (_KeepAliveTick > 0) && 
					(((currentTick - _StartKeepAliveTick) >= _KeepAliveTick) ||
					((currentTick - LastReceivedTime) >= _KeepAliveTick) )
				))                         //if keep alive tick enabled
                        {
				//fprintf(_debugPort, "_forceKeepAlive=%d, _OnlineAcked=%d, _keepAliveSent=%d, _KeepAliveTick=%d, currentTick=%d, _StartKeepAliveTick=%d, LastReceivedTime=%d\n",
				//forceKeepAlive, _OnlineAcked, _keepAliveSent, _KeepAliveTick, currentTick, _StartKeepAliveTick, LastReceivedTime);
                                // _StartKeepAliveTick is set in the sendClass routine below so it is reset when any command is sent
#ifdef TABLET1
				//if (GetRawSignalLevel() != 0) {
				
					fprintf(_debugPort, "Sending ka, bingoState=%d, _BingoDisconnectState=%d\n",(int)GetBingoState(),(int)_BingoDisconnectState);
					UpdateDebug();
				//}
				//if (GetRawSignalLevel() != 0)
#endif
				{
					SendKeepAlive(dest_addr);
#ifdef notdef1
                                	fprintf(_debugPort,"ka sent\n");
#endif
				}
                        }
                        else if(_Socket >= 0)
                        {
                                Uint32 slctTime;

                                FD_ZERO (&rd);
                                FD_SET(_Socket,&rd);
                                if(_KeepAliveTick <= 0)               //if keep alive not enabled
                                {
                                        slctTime = 10000;             //select timeout is 10 seconds
                                }
                                else                 //timeout should be less than next keep alive tick
                                {
                                        slctTime = currentTick - _StartKeepAliveTick;
                                        if(slctTime < _KeepAliveTick)
                                                slctTime = _KeepAliveTick-slctTime;
                                        else
                                                slctTime = _KeepAliveTick;
                                }
                                 //make sure that it is less than next keep alive tick
                                 if(slctTime>100)
                                         slctTime=(slctTime-100);
				 
#ifdef BINGO
				 if (slctTime > 1000) slctTime = 1000;
#endif

                                timeout.tv_sec=slctTime/1000;
                                timeout.tv_usec=(slctTime%1000)*1000;

                                readsocks = select(_Socket+1,&rd,NULL,NULL,&timeout);
                                if(readsocks > 0)
                                {
#ifdef notdef
                                        fprintf(_debugPort, "Received data from CasinoNet\n");
#endif
					int ct;
					for (ct=0; ct<(2048+1024); ct++)
						buf[ct] = 0;
                                        if((numbytes=recv(_Socket,buf,2048,0))>0)
                                        {
						LastReceivedTime = SDL_GetTicks();
#ifdef bingo_debug1
						fprintf(_debugPort, "~!");
                                        	fprintf(_debugPort, "\nReceived data from CasinoNet");
						fprintf(_debugPort, " numbytes=%d, partialCt=%d\n",numbytes, partialCt);
#endif
						start = 0;
						if (partialCt > 0) {	// partial command left from last time
							memcpy(&partialbuf[partialCt], buf, numbytes);
							numbytes += partialCt;
							memcpy(buf, partialbuf, numbytes);
							partialCt = 0;
						}
#ifdef notdef
						if ((numbytes < (2048+1024)) || (buf[numbytes-1] == '\0')) {	// have complete command
                                                	buf[numbytes]='\0';
                                                	processReceivedClass(_Socket,dest_addr,&buf[start],numbytes-start);
						} else {
							// search for end of last complete command
							ct = 0;
							while (buf[numbytes-1-ct] != '\0') {
								ct++;
							}
							processReceivedClass(_Socket,dest_addr,&buf[start],numbytes-ct-start);
							strncpy(partialbuf, &buf[numbytes - ct], ct);
							partialCt = ct;
						}
#endif
//						while ((start < numbytes) && ((ct = strlen(&buf[start]))+start) <= numbytes) {
						while ((start < numbytes) && ((ct = strlen(&buf[start]))+start) < numbytes) {
							if (start > 0) {
								//fprintf(_debugPort, "start=%d, ct=%d, numbytes=%d\n",start,ct,numbytes);
							}
							//fprintf(_debugPort, "@%1d,%1d,%1d", start,numbytes,ct);
                                                	processReceivedClass(_Socket,dest_addr,&buf[start],ct);
							start += ct;
							//while ((buf[start] == '\0') && (start < numbytes)) {
							while ((start < numbytes) && (buf[start] == '\0')) {
								//fprintf(_debugPort, "#%1d,%1d",start,numbytes);
								++start;
							}
						}
						// search for end of last complete command
						if (start < numbytes) {
							ct = numbytes - start;
							memcpy(partialbuf, &buf[start], ct);
							partialCt = ct;
						} else {
							partialCt = 0;
						}
						//fprintf(_debugPort, "partialCt=%d\n",partialCt);
#ifdef FORCE_CNET_DISCONNECT
						if (++keepAliveCnt > 150) {
							_BrokenPipe = SDL_TRUE;
							keepAliveCnt = 0;
						}
#endif
                                        }
                                }
                                else if(readsocks < 0) 
                                {
#ifdef notdef
                                        fprintf(_debugPort, "ERROR ON SELECT:%d[%s]",errno,strerror(errno));
#endif
                                }
                        }
                        else {
#ifndef PRODUCTION
				fprintf(_debugPort, "Socket lost? %s\n", getTimeStamp);
#endif
                                _BrokenPipe = SDL_TRUE;         // no socket - what happened???
			}
                }
        }
        if(_NetworkSendPacketMutex != NULL)
        {
                SDL_DestroyMutex(_NetworkSendPacketMutex);
                _NetworkSendPacketMutex=NULL;
        }

        return 0;
}  


int OpenSocket(char *server, int port,struct sockaddr_in *dest_addr,struct sockaddr_in *eserver)
{
        int sockfd;

	_ConnectionCount++;
        sockfd = socket(PF_INET,SOCK_STREAM,0);

        dest_addr->sin_family=AF_INET;
        dest_addr->sin_port=htons(port);
        dest_addr->sin_addr.s_addr=inet_addr(server);

#ifdef notdef2
	fprintf(_debugPort, "in OpenSocket(), sockfd=%d\n", sockfd);
#endif
        if(connect(sockfd, (struct sockaddr *)dest_addr, sizeof(struct sockaddr))!=0)
        {
                LOG_FATAL("Error connecting to port [%d] on [%s]:%d\n",port,server,errno);
                fprintf(_debugPort, "Error connecting to port [%d] on [%s]:%d\n",port,server,errno);
                close(sockfd);
                sockfd = -1;
        }
	// successful 
	if (sockfd != -1)
		_ConnectionCount = 0;
#ifdef notdef
	/* Create the TCP socket */
	if ((echosock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		fprintf(_debugPort,"Failed to create socket\n");
	}
	/* Construct the server sockaddr_in structure */
	memset(&eserver, 0, sizeof(struct sockaddr)); /* Clear struct */
	eserver->sin_family = AF_INET; /* Internet/IP */
	eserver->sin_addr.s_addr = inet_addr(server); /* IP address */
	eserver->sin_port = htons(7); /* server port */
	/* Establish connection */
	if (connect(echosock, (struct sockaddr *) &eserver, sizeof(struct sockaddr)) < 0) {
		fprintf(_debugPort,"Failed to connect with echoserver\n");
	} else 
		fprintf(_debugPort,"Connected with echoserver echosock=%d\n",echosock);
#endif

        return sockfd;
}

void Network_Close(void)
{
        if(_Socket>=0) {
                close(_Socket);
		_Socket = -1;
	}
}

#ifndef BINGO
int DeviceState()
{
	return 0;
}
#endif

SDL_bool sendClass(int sockfd,struct sockaddr *destAddr,char *Class,char *EgmID,char *Command,char *Data)
{
        char buf[SNPRINTF_LIMIT+1];
	char buf1[SNPRINTF_LIMIT+1];
	char buf2[1024];
	char buf3[1024];
	int len;
        //static char notsentbuf[SNPRINTF_LIMIT+1];
        SDL_bool r;
        int numc;
	int deviceState = DeviceState();

	memset(buf,0,sizeof(buf));
	//if (!strcmp(Class, "bingo") && !strcmp(Command, "getwinamt")) {
	//} else {
	//if (strcmp(Class, "bingo") != 0) 
	{
		if ((_OnlineAcked == SDL_FALSE) || (deviceState != 4 && deviceState != 8)) {	// not jackpot lockup and not out of service lockup
			if ((IsWaiting4APIack() == SDL_FALSE) || (_OnlineAcked == SDL_FALSE))
        			_StartKeepAliveTick = SDL_GetTicks();
		}
	}
	//}

#ifdef notdef
        if(_NetworkSendPacketMutex!=NULL)      //make sure that we have finished sending the previous network packet
        {
                SDL_mutexP(_NetworkSendPacketMutex);
        }
#endif
        snprintf(buf,SNPRINTF_LIMIT,"%s:%s:%s:%s:%s:",Class,EgmID,getTimeStamp(),Command,Data);
#ifdef bingo_debug
 #ifndef LOADTEST
	//if (strcmp(Class,"bingo") == 0)
	if ((strcmp(Command, "keepAlive") != 0) || ((DeviceState() != 0) && (DeviceState() != 1)))
 #endif
	{
        	fprintf(_debugPort,"\nSC:[%s]\n",buf);
		UpdateDebug();
	}
	//if (strcmp(Command,"keepAlive") == 0)
        //	fprintf(_debugPort,"\nSC:[%s]\n",buf);
#endif
	if (_ExtendedConfig.encryptionEnabled == SDL_TRUE) {

	if (strcmp(Class,gameStr) != 0) {
	//	fprintf(_debugPort, "\n%s\n",buf);
	}
	len = strlen(buf);
	if (msg_crypt(buf,buf1,len,ENCRYPTMSG) == 0) {
		msg_crypt(buf,buf1,len,ENCRYPTMSG);		// should reinitialize mcrypt module
	}
	//fprintf(_debugPort, "%s\n\n",buf3);
	strcat(buf1,"\r");
	//fprintf(_debugPort, "%s\n",buf1);
	} else {
        strcat(buf,"\r");
	}
        if(_NetworkSendPacketMutex!=NULL)      //make sure that we have finished sending the previous network packet
        {
		//fprintf(_debugPort, "Lock _NetMutex\n");
                SDL_mutexP(_NetworkSendPacketMutex);
		//fprintf(_debugPort, "Got _NetMutex\n");
        }
        if ((strlen(notsentbuf) > 0) && (_progressiveValueReceived == SDL_TRUE)) {   // dont send until CN is ready.
                numc=sendto(sockfd,notsentbuf,strlen(notsentbuf),0,destAddr,sizeof(struct sockaddr));
                if (numc == -1)
                {
                        _BrokenPipe=SDL_TRUE;
#ifndef PRODUCTION
//#ifdef notdef1
                        fprintf(_debugPort, "NOTSENTBUF ERROR: sendto:%d[%s]",errno,strerror(errno));
//#endif
#endif
                        _Socket=-1;
                        r=SDL_FALSE;
                        goto out;
                } else {
#ifdef notdef1
                        fprintf(_debugPort, "NOTSENTBUF SUCCESS: notsentbuf=%s\n",notsentbuf);
#endif
                        notsentbuf[0]=0;
                }
        }
        //if(sockfd>=0 && sendto(sockfd,buf,strlen(buf),0,destAddr,sizeof(struct sockaddr))==-1)
	if (_ExtendedConfig.encryptionEnabled == SDL_TRUE) {

        numc=sendto(sockfd,buf1,strlen(buf1),0,destAddr,sizeof(struct sockaddr));
	//fprintf(_debugPort, "\nnumc = %d, strlen(buf1)=%d, time=%d\n",numc, strlen(buf1), SDL_GetTicks());
	} else {

        numc=sendto(sockfd,buf,strlen(buf),0,destAddr,sizeof(struct sockaddr));
	}

        if((sockfd>=0) && (numc==-1))
        {
                if (_progressiveValueReceived == SDL_TRUE) {
			if (_ExtendedConfig.encryptionEnabled == SDL_TRUE)

                        strcpy(notsentbuf,buf1);
			else
                        strcpy(notsentbuf,buf);
		}
//                if(errno==EPIPE)               //the pip has been broken
                _BrokenPipe=SDL_TRUE;
#ifndef PRODUCTION
//#ifdef notdef1
                fprintf(_debugPort, "sendto:%d[%s]",errno,strerror(errno));
//#endif
#endif
                _Socket=-1;
                r=SDL_FALSE;
        }  
        else  {
                r=SDL_TRUE;
#ifdef notdef1
                if (strlen(notsentbuf))
                        fprintf(_debugPort, "notsentbuf[%s] CLEARED\n",notsentbuf);
#endif
                if (_progressiveValueReceived == SDL_TRUE)
                        notsentbuf[0]=0;        // clear
        }
#ifdef notdef1
        if (numc != strlen(buf))
                fprintf(_debugPort, "*********************numc=%d strlen(buf)=%d\n",numc,strlen(buf));
#endif
        //SDL_Delay(500);
out:
        if(_NetworkSendPacketMutex!=NULL)
        {
		//fprintf(_debugPort, "unLock _NetMutex\n");
                SDL_mutexV(_NetworkSendPacketMutex);
        }
        return r;
}


char *getTimeStamp(void)
{
        static char tstring[64];
        struct timeb tb;
        struct tm *t;
  
        ftime(&tb);

        //t=gmtime(&tb.time);
        t=localtime(&tb.time);
             //yyyyMMddhhmmssnnn
        sprintf(tstring,"%d%02d%02d%02d%02d%02d%03d",t->tm_year+1900,t->tm_mon+1,t->tm_mday, t->tm_hour,t->tm_min,t->tm_sec,tb.millitm);
        return tstring;  
}

unsigned long secondsSinceEpoch()
{
	struct timeb tb;

	ftime(&tb);
	return tb.time;
}

void ProcessKeepAlive()
{
        static int lastTime;

        if (_keepAliveSent == SDL_TRUE)
        {
		int curTicks = SDL_GetTicks();
                if (((curTicks - lastTime) >= keepAliveInterval) || ((curTicks - LastReceivedTime - 1000) >= keepAliveInterval))        // Do this every 3000 ms
                {
#ifndef PRODUCTION
			fprintf(_debugPort, "ProcessKeepAlive timeout %s\n", getTimeStamp());
#endif
                        lastTime = SDL_GetTicks();
                        _keepAliveSent = SDL_FALSE;
                        _BrokenPipe = SDL_TRUE;
                        _progressiveValueReceived = SDL_FALSE;
			//serverConfigError = 0;
			serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
#ifdef BINGO
			//_GEPamtReceived = SDL_FALSE;
			//_BCInfo.serialnum = 0;
			//fprintf(_debugPort, "clearing serial number\n");
			SetBingoDisconnectState(BDIS_DISCONNECT);
#endif
                }
        }
        else
               lastTime = SDL_GetTicks();
#ifdef BINGO
	DeviceState();
#endif
}

void processReceivedClass(int sockfd,struct sockaddr *destAddr,char *rxbuf, int numbytes)
{
          EGM_CLASS egmclass;
	  char tmpbuf[2049+1024];
	  int inx=0;
	  int len = strlen(rxbuf);
	  int count;
	  char decodedBuf[2049+1024];
	  
	  // packets may run together, need to split them up to process individually.
	  while (inx < numbytes) {
		  len = strlen( &rxbuf[inx]);
		  //fprintf(_debugPort, "inx=%d, len=%d numbytes=%d\n",inx,len, numbytes);
		  count = 0;
		  while (len-- && (inx < numbytes)) {
			  tmpbuf[count++] = rxbuf[inx++];
		  }
		  ++inx;
		  tmpbuf[count] = 0;
	 
          //fprintf(_debugPort,"Received from server:[%s]\n",rxbuf);
//          decodeClass(rxbuf,&egmclass);
//          fprintf(_debugPort,"Received from server:[%s] egmclass.Class=%s\n",rxbuf,egmclass.Class);
//**************************????????????????????????
#ifdef notdef1
		if ((count != 77) && (count != 78))		// don't print heartbeats
		{
			int ct = count;
			int i;
			char buf1[256];
			char *cptr = &tmpbuf[0];
			
			fprintf(_debugPort, "Received from server: count=%d [", count);
			while (ct > 80) {
				for (i=0; i<80; i++) {
					buf1[i] = *cptr++;
					ct--;
				}
				buf1[80] = 0;
				fprintf(_debugPort, "%s\n",buf1);
			}
			for (i=0; i<ct; i++) 
				buf1[i] = *cptr++;
			buf1[ct] = 0;
			fprintf(_debugPort, "%s\n",buf1);
		}
#endif
		if (_ExtendedConfig.encryptionEnabled == SDL_TRUE)
		{
		//fprintf(_debugPort, "b4decrypt: %s\n",tmpbuf);
		if (tmpbuf[strlen(tmpbuf)-1] == '\r')
			tmpbuf[strlen(tmpbuf)-1] = '\0';
		msg_crypt(tmpbuf,decodedBuf,strlen(tmpbuf),DECRYPTMSG);
		//fprintf(_debugPort, "%s\n",decodedBuf);
		//UpdateDebug();
           	decodeClass(decodedBuf,&egmclass);
#ifdef bingo_debug
 #ifndef LOADTEST
		if (strcmp(egmclass.Command,"keepAliveAck") != 0)
 #endif
		{
  #ifndef BINGOTEST
			fprintf(_debugPort,"RC:[%s]\n",decodedBuf);
  #endif
		}
#endif
		}
		else
		{
           	decodeClass(tmpbuf,&egmclass);
#ifdef bingo_debug
		if (strcmp(egmclass.Command,"keepAliveAck") != 0)
         	fprintf(_debugPort,"RC:[%s\n]",tmpbuf);
#endif
		}
#ifdef bingo_debug
		//fprintf(_debugPort, "] egmclass.Class=%s\n",egmclass.Class);
#endif


          	_keepAliveSent = SDL_FALSE;                                           // Tell the scheduler we received the some data
          	_KeepAliveTick = keepAliveInterval - 2000;				//3000;
          	if(strcmp(egmclass.Class,"communications")==0)
                  processCommunicationsClass(sockfd,destAddr,&egmclass);
          	else if(strcmp(egmclass.Class,"cabinet")==0)
                  processCabinetClass(sockfd,destAddr,&egmclass);
          	else if(strcmp(egmclass.Class,"progressive")==0)
                  processProgressiveClass(sockfd,destAddr,&egmclass);
		else if (strcmp(egmclass.Class, "setProgressiveDenoms")==0) {
		}
		else if ((strcmp(egmclass.Class,gameStr)==0) || (strcmp(egmclass.Class,acctStr)==0) || (strcmp(egmclass.Class,"bingo")==0)) {
#ifdef BINGO
		  processBingoClass(sockfd,destAddr,&egmclass);
#else
                  processProgressiveClass(sockfd,destAddr,&egmclass);
#endif
		}
          	else
                  processBadClass(sockfd,destAddr,&egmclass);
	  }
	//fprintf(_debugPort, "inx=%d, numbytes=%d\n",inx,numbytes);
}

void decodeClass(char *rxbuf,EGM_CLASS *egmclass)
{
        *egmclass->Class='\0';
        *egmclass->EgmID='\0';
        *egmclass->CommandID='\0';
        *egmclass->Command='\0';
        *egmclass->Data='\0';
        char wbuf[2049+1024];
        char *start;
        char *next;

        strcpy(wbuf,rxbuf);
        start = wbuf;
        next = start;

        while(*next != ':' && *next != '\0')
                next++;
        if(*next != '\0')
        {
                *next = '\0';
                next++;
        }
        strcpy(egmclass->Class,start);
        start = next;

        while(*next != ':' && *next != '\0')
                next++;
        if(*next != '\0')
        {
                *next = '\0';
                next++;
        }
        strcpy(egmclass->EgmID,start);
        start = next;

        while(*next != ':' && *next != '\0')
                next++;
        if(*next != '\0')
        {
                *next = '\0';
                next++;
        }
        strcpy(egmclass->CommandID,start);
        start = next;

        while(*next != ':' && *next != '\0')
                next++;
        if(*next != '\0')
        {
                *next = '\0';
                next++;
        }
        strcpy(egmclass->Command,start);
        start = next;

#ifdef notdef		//should this be #ifndef BINGO????
        while(*next != ':' && *next != '\0')
        next++;
        if(*next != '\0')
        {
                *next = '\0';
                next++;
        }
#endif
        strcpy(egmclass->Data,start);
        start = next;
}

/*
"error:WGSC00001:20040316184627432:error:error=EA01,eventText=Invalid Resonse,eventTime=20040316184627432:<CR>"
*/

void processBadClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
        char buf[128];
  
//#ifdef notdef
        fprintf(_debugPort,"processBadClass: class not recognized.[%s]\n",egmclass->Data);
//#endif

        sprintf(buf,"error=%s,eventText=Invalid Response,eventTime=%s",egmclass->Class,egmclass->CommandID);
        sendClass(sockfd,destAddr,"error",_TheEgmID,"error",buf);
}

void processCommunicationsClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
        char buf[512];
        DATA_PAIRS KeepAliveDatapairs[]={
	  {"interval",""},
	  {"jackpottype", ""},
	};
        int count=2;

                                      //keepAlive communications class complete
        if(strcmp(egmclass->Command,"setKeepAlive")==0)
        {
                extractDataPairs(egmclass->Data,KeepAliveDatapairs,count);
                if(strlen(KeepAliveDatapairs[0].data)>0)
                {
			keepAliveInterval = atoi(KeepAliveDatapairs[0].data);
                        _KeepAliveTick = keepAliveInterval - 2000;
                        _StartKeepAliveTick = SDL_GetTicks();
#ifdef BINGO
			SetCmdTimeOut (keepAliveInterval);		// bingo command timeout, resend
#endif
                }
                
                //strcpy(KeepAliveDatapairs[1].data, "1");	// forcing JP_BONUS
		
                if(strlen(KeepAliveDatapairs[1].data)>0)
                {
			_ExtendedConfig._JackPotType = atoi(KeepAliveDatapairs[1].data);
			if (_JackPotType != _ExtendedConfig._JackPotType) {
			  _JackPotType = _ExtendedConfig._JackPotType;
			  serverConfigError |= JACKPOTYPE_ERR;
			  _saveConfigRequired = SDL_TRUE;
			}
                }
                else {
		  fprintf(_debugPort, "jackpottype not found\n");
		}
                buf[0]='\0';
                sendClass(sockfd,destAddr,"communications",_TheEgmID,"setKeepAliveAck",buf);
        }

        else if(strcmp(egmclass->Command,"keepAliveAck")==0)
        {
		//static int test=1;
                _keepAliveSent = SDL_FALSE;                                           // Tell the scheduler we received the ack
                _KeepAliveTick = keepAliveInterval - 2000;		//3000;
		{
			//fprintf(_debugPort, "[%s]\n",egmclass->Data);
			DATA_PAIRS KeepAliveDatapairs[]={
				{"vstatus",""},
				{"GEPamt",""},
			};
			int count=2;
			int curGepWin;

			extractDataPairs(egmclass->Data,KeepAliveDatapairs,count);
#ifdef BINGO
			sscanf(KeepAliveDatapairs[1].data, "%d", &curGepWin);
			if (curGepWin == 0 && _BCInfo.numgBalls == 71) {
				// GEP always awarded
				curGepWin = 1;
			}
    			SetCurrentBingoPrize(curGepWin);
			_GEPamtReceived = SDL_TRUE;
#endif
#ifdef VICTORYLAND
			SetLastVNetStatus(KeepAliveDatapairs[0].data);
#else
			if (_JackPotType == JP_BONUS) {
				SetLastVNetStatus(KeepAliveDatapairs[0].data);
			}

#endif
		}
        }
	else if (strcmp(egmclass->Command, "commsOnLineNack") == 0)
	{
	}
        else if(strcmp(egmclass->Command,"commsOnLineAck")==0)
        {
#ifdef notdef
		if (doCommsOnLineTest == 1) {		// ignore, pretend we got commsOnLineNack
			doCommsOnLineTest = 0;
			return;
		}
#endif
		_NeedServerConfig = 0;
                //SendGetVoucherConfiguration(sockfd,destAddr); 
		//fprintf(_debugPort, "commsOnLineAck:%s\n",egmclass->Data);   
                _OnlineAcked=SDL_TRUE;
#ifdef BINGO
        	DATA_PAIRS commsOnLineDatapairs[]={
			{"cardDigits",""},		//[0]
			{"gameInactivityTime",""},	//[1] in minutes
			{"gamePinTime",""},		//[2] in hours
			{"pinRetry",""},		//[3] count
			{"checkoutTime",""},		//[4] in hours
			{"paylevelcount",""},		//[5] number of pay levels
			{"paylevel00",""},		//[6]
			{"paylevel01",""},		//[7]
			{"paylevel02",""},		//[8]
			{"paylevel03",""},		//[9]
			{"paylevel04",""},		//[10]
			{"setid",""},			//[11]
			{"daubtimeout",""},		//[12]
			{"claimtimeout",""},		//[13]
			{"minplayers",""},		//[14]
			{"mode",""},			//[15]
			{"irslimit",""},		//[16]			
			{"cname",""},			//[17] Casino Name
			{"addr1",""},			//[18] Address Line 1
			{"addr2",""},			//[19] Address Line 2
			{"addr3",""},			//[20] Address Line 3
			{"phone",""},			//[21] phone number
		};
        	int count=17+5;
		int iv;
		
                extractDataPairs(egmclass->Data,commsOnLineDatapairs,count);
                if(strlen(commsOnLineDatapairs[0].data)>0)
			_BCInfo.cardDigits = atoi(commsOnLineDatapairs[0].data);
		else 
			_BCInfo.cardDigits = 10;		// default to 10 digits
                if(strlen(commsOnLineDatapairs[1].data)>0) {
			_BCInfo.gameInactivityTime = atoi(commsOnLineDatapairs[1].data);
//#ifndef PRODUCTION
//			_BCInfo.gameInactivityTime = 1;		// demo mode force 1 min
//#endif
		} else
			_BCInfo.gameInactivityTime = 10;	// default to 10 minutes
                if(strlen(commsOnLineDatapairs[2].data)>0) {
			_BCInfo.gamePinTime = atoi(commsOnLineDatapairs[2].data);
		} else
			_BCInfo.gamePinTime = 1;		// default to 1 hour
#ifdef VICTORYLAND
		_BCInfo.gamePinTime = 0;		// ignore
#endif
#ifdef BINGOSAS
		_BCInfo.gamePinTime = 0;		// ignore
#endif
                if(strlen(commsOnLineDatapairs[3].data)>0)
			_BCInfo.gamePinRetryMax = atoi(commsOnLineDatapairs[3].data);
		else
			_BCInfo.gamePinRetryMax = 0;		// default to none
                if(strlen(commsOnLineDatapairs[4].data)>0)
			_BCInfo.checkoutTime = atoi(commsOnLineDatapairs[4].data);
		else
			_BCInfo.checkoutTime = 12;		// default to 12 hours
		if (strlen(commsOnLineDatapairs[11].data)>0)
			setid = atoi(commsOnLineDatapairs[11].data);
		else
			setid = 1;
		if (strlen(commsOnLineDatapairs[5].data)>0) {
			SDL_bool configChanged = SDL_FALSE;
			paylevelcount = atoi(commsOnLineDatapairs[5].data);
			_maxPayLevel = paylevelcount;
			for (iv=0; iv<paylevelcount; iv++) {
				paylevelvalues[iv] = atoi(commsOnLineDatapairs[6+iv].data);
				//fprintf(_debugPort, "paylevelvalues[%d]=%d\n",iv,paylevelvalues[iv]);
				if (_GlobalConfig.payPercent[iv] != paylevelvalues[iv]) {
					_GlobalConfig.payPercent[iv] = paylevelvalues[iv];
					configChanged = SDL_TRUE;
				}

			}
			if (configChanged == SDL_TRUE) {
				_saveConfigRequired = SDL_TRUE;
				need2Send3C = SDL_TRUE;
			}
		}
 #ifndef PULLTAB
		if (strlen(commsOnLineDatapairs[12].data)>0) {
			//_BCInfo.daubtimeout = atoi(commsOnLineDatapairs[12].data)*1000;
			_BCInfo.daubtimeout = atoi(commsOnLineDatapairs[12].data);
			if (_BCInfo.daubtimeout > 0)
				_BCInfo.daubtimeout *= 1000;
			//_BCInfo.daubtimeout = 10000;		//!!!! faking it
		} else {
			_BCInfo.daubtimeout = 0;
		}
		if (strlen(commsOnLineDatapairs[13].data)>0) {
			_BCInfo.claimtimeout = atoi(commsOnLineDatapairs[13].data);
#ifdef TESTCLAIM
			_BCInfo.claimtimeout = 30;
#endif
			if (_BCInfo.claimtimeout > 0)
				_BCInfo.claimtimeout *= 1000;
			//_BCInfo.claimtimeout = -1;		//!!!! faking auto claim
		} else {
			_BCInfo.claimtimeout = 0;
		}
		if (strlen(commsOnLineDatapairs[14].data)>0) {
			_BCInfo.minPlayers = atoi(commsOnLineDatapairs[14].data);
		} else {
			_BCInfo.minPlayers = 1;
		}
		fprintf(_debugPort, "daubtimeout=%d, claimtimeout=%d\n",_BCInfo.daubtimeout, _BCInfo.claimtimeout);
 #endif
			
                if(strlen(commsOnLineDatapairs[15].data)>0)
			_BCInfo.playerMode = atoi(commsOnLineDatapairs[15].data);	//0=pin only, 1=passport+pin, 2=?
		else 
			_BCInfo.playerMode = 1;		// default to player card
		fprintf(_debugPort, "playerMode=%d\n",_BCInfo.playerMode);
		
                if(strlen(commsOnLineDatapairs[16].data)>0) {		//irslimit (if not send, use default)
			int luamt = atoi(commsOnLineDatapairs[16].data);
			if (luamt > 0)
				_ExtendedConfig.LockupAmount = luamt;
		}
		if (strlen(commsOnLineDatapairs[17].data) > 0) {
			char addr2[32];
			int len1, len2;
			int p1, p2;
			int gotSingleQuote = 0;
			len1 = strlen(commsOnLineDatapairs[17].data);
			for (p1=0, p2=0; p1<len1; p1++) {
			  if ((gotSingleQuote == 1) && (commsOnLineDatapairs[17].data[p1] == 39)) {
			      // skip 2nd quote, reset flag
			      gotSingleQuote = 0;
			  } else {
			    addr2[p2++] = commsOnLineDatapairs[17].data[p1];
			    if (addr2[p2-1] == 39)
			      gotSingleQuote = 1;
			    else
			      gotSingleQuote = 0;
			  }
			    
			}
			strcpy(_ExtendedConfig.CasinoName, addr2);
			strcpy(_ExtendedConfig.AddressLine1, commsOnLineDatapairs[18].data);
			strcpy(addr2, commsOnLineDatapairs[19].data);
			len1 = strlen(commsOnLineDatapairs[19].data);
			len2 = strlen(commsOnLineDatapairs[20].data);
			if ((len1 + len2) > 30)
				len2 = 30 - len1;
			strcat(addr2, " ");
			strncpy(&addr2[len1+1], commsOnLineDatapairs[20].data, len2);
			strcpy(_ExtendedConfig.AddressLine2, addr2);
			strcpy(_ExtendedConfig.AddressLine3, commsOnLineDatapairs[21].data);
		}
		//_GEPamtReceived = SDL_FALSE;
		//_BCInfo.serialnum = 0;
#ifdef VICTORYLAND
		SetBingoDisconnectState(BDIS_DISCONNECT);
#endif
#ifdef BINGOSAS
		SetBingoDisconnectState(BDIS_OK);
#endif
#ifndef PULLTAB
#ifdef BINGOSAS
		if (_BCInfo.cardnum == 0) {
			SetBingoState(BIS_SEND_CARD, -1);
		}
#endif
#ifdef nomore
		if (needPatterns == 1) {
			totalBingoPatterns = 0;				// reset number of patterns received
			//paylevel = 0;
		}
		//if (totalBingoPatterns < 20) {
		if (totalBingoPatterns < (_BCInfo.numiPatterns + _BCInfo.numgPatterns)) {
			//sprintf(buf,"pattern=%d,level=%d", totalBingoPatterns+1, paylevel+1);
			sprintf(buf,"pattern=%d,alllevels=1", totalBingoPatterns+1);
			sendClass(sockfd,destAddr,"bingo",_TheEgmID,"getpatterns",buf);
		} 
		else 
#endif
#endif
		{
			SendKeepAlive(destAddr);
#ifdef notdef1
                                	fprintf(_debugPort,"ka1 sent\n");
#endif
		}
#ifdef TABLET
		//else {
		//	SetLastActivityTime();
		//}
#endif
#else
        	DATA_PAIRS commsOnLineDatapairs[]={
			{"irslimit",""},		//[16]			
		};
        	int count=1;
		int iv;
		
                extractDataPairs(egmclass->Data,commsOnLineDatapairs,count);
                if(strlen(commsOnLineDatapairs[0].data)>0) {		//irslimit (if not send, use default)
			int luamt = atoi(commsOnLineDatapairs[0].data);
			if (luamt > 0)
				_ExtendedConfig.LockupAmount = luamt;
		}
		SendKeepAlive(destAddr);
#ifdef notdef1
		fprintf(_debugPort,"ka2 sent\n");
#endif
#endif
#ifndef PRODUCTION
		fprintf(_debugPort, "GetPayPercent() %d\n", GetPayPercent());
#endif
		if (_GlobalConfig.PayRangeFlag == 0) return;
		
		int dlev, llev, clev;
		for (iv=0; iv<_GlobalConfig.PayRangeFlag; iv++) {
			_MinBetRange.payPercent[iv] = PayName2Percent(_MinBetRange.payName[iv]);
			//fprintf(_debugPort, "[%1d],%d,%d\n", iv, 
			//	PayName2Percent(_MinBetRange.payName[iv]),
			//	PayName2Level(_MinBetRange.payName[iv]));
			if ((_MinBetRange.payLevel[iv] = PayName2Level(_MinBetRange.payName[iv])) == 0) {
				// name mismatch - must reconfig cnet
				serverConfigError |= PAY_ERR;
				fprintf(_debugPort, "%s mismatch", _MinBetRange.payName[iv]);
			}
			
		}
		for (dlev=0; dlev<_numDenomLevels; dlev++) {
			for (llev=0; llev<1; llev++) {
				for (clev=0; clev<_maxBetLevel; clev++) {
					int totalBet = _TotalBet[dlev][llev][clev];
					int mlev;
					for (mlev=1; mlev<(_GlobalConfig.PayRangeFlag+1); mlev++) {
						if ((mlev == _GlobalConfig.PayRangeFlag) || (_MinBetRange.minBet[mlev] <= 0) || (_MinBetRange.minBet[mlev] > totalBet)) {
#ifdef BINGO
						  _PayLevels[dlev][llev][clev] = _MinBetRange.payLevel[mlev - 1] - 1;
#else
						  _PayLevels[dlev][llev][clev] = _MinBetRange.payPercent[mlev-1];
#endif
						  fprintf(_debugPort, "_PayLevels[%1d][%d][%1d] = %d, %1d\n", dlev, llev+1, clev, totalBet, _PayLevels[dlev][llev][clev]);
						  break;
						}
					}
				}
			}
		}
        }
#ifdef BINGO
	else if (strcmp(egmclass->Command,"lock") == 0)
	{
		fprintf(_debugPort, " Got LOCK!!!\n");
		SetGotLock();
	}
	else if (strcmp(egmclass->Command,"pinlock") == 0)
	{
		fprintf(_debugPort, " Got PIN LOCK!!!\n");
		SetGotPinLock();
	}
	else if (strcmp(egmclass->Command,"unlock")==0)
	{
        	DATA_PAIRS datapairs[]={{"passport",""},};
        	int count=1;

                                      //keepAlive communications class complete
                extractDataPairs(egmclass->Data,datapairs,count);
		fprintf(_debugPort, "Got UNLOCK!!!\n");
#ifdef BINGO
		if (OutOfService() == SDL_TRUE) {
			ClearWaiting4GameActivityAck();	// don't send gameActivity, will be nacked
		}
		SetGotUnlock();
                if(strcmp(datapairs[0].data, _BCInfo.passport) == 0) {	// same passport
			sprintf(buf, "passport=%s",_BCInfo.passport);
			sendClass(sockfd,destAddr,"communications",_TheEgmID,"unlockack",buf);
		} else {
			sprintf(buf, "passport=%s",datapairs[0].data);
			sendClass(sockfd,destAddr,"communications",_TheEgmID,"unlocknack",buf);
		}
#endif
		
	}
#endif
	else if (strcmp(egmclass->Command,"Invalid command")==0) {
		//server had problem with last command, do nothing for now
	}
        else
                processBadClass(sockfd,destAddr,egmclass);
}

SDL_bool HaveCashInfo2Send()
{
	unsigned long long total = 0;
	total += _GlobalMeters.cinfo.billin;
	total += _GlobalMeters.cinfo.ticketin;
	total += _GlobalMeters.cinfo.promoin;
	total += _GlobalMeters.cinfo.aftin;
	total += _GlobalMeters.cinfo.lbin;
	total += _GlobalMeters.cinfo.ticketout;
	total += _GlobalMeters.cinfo.promoout;
	total += _GlobalMeters.cinfo.handpay;
	total += _GlobalMeters.cinfo.aft2ticket;
	total += _GlobalMeters.cinfo.aft2host;
	total += _GlobalMeters.cinfo.lb2ticket;

	if (total > 0) return SDL_TRUE;
	return SDL_FALSE;
}

//Actually send the cashinfo transaction
void SendCashInfo1(cashinfo *cinfo1)
{
#ifdef CLASS3_OR_BINGOSAS
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];

	sprintf(buf, "cashinfoid=%d,asset=%d,billin=%1d,ticketin=%1d,promoin=%1d,aftin=%1d,lbin=%1d,ticketout=%1d,promoout=%1d,handpay=%1d,aft2ticket=%1d,aft2host=%1d,lb2ticket=%1d,denom=%d,GameName=%s,macaddr=%s", _GlobalMeters.cashinfoid, _GlobalConfig.assetID, cinfo1->billin, cinfo1->ticketin, cinfo1->promoin, cinfo1->aftin, cinfo1->lbin, cinfo1->ticketout, cinfo1->promoout, cinfo1->handpay, cinfo1->aft2ticket, cinfo1->aft2host, cinfo1->lb2ticket,GetDenomX(),_ProductId,macaddr);
	strcpy(lastCIbuf, buf);						// save off data for cashinfo
	SetWaiting4PurchaseAck();				// set flag to indicate waiting for ack
	LastCashInfoTime = SDL_GetTicks();
	SaveCashInfoBuf();
	memset((unsigned char *)cinfo1, 0, sizeof(cashinfo)); 
	sendClass(_Socket, dest_addr, "progressive", _TheEgmID, "cashinfo", buf);
	++_GlobalMeters.cashinfoid;
#endif
}

// check to see if need/ok to send progressive:cashinfo.
void SendCashInfo(cashinfo *cinfo)
{
#ifdef CLASS3_OR_BINGOSAS
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
	cashinfo *cinfo1;

	if (_ExtendedConfig.ProgControllerType == 2) {
		_GlobalMeters.cinfo.billin += cinfo->billin;
		_GlobalMeters.cinfo.ticketin += cinfo->ticketin;
		_GlobalMeters.cinfo.promoin += cinfo->promoin;
		_GlobalMeters.cinfo.aftin += cinfo->aftin;
		_GlobalMeters.cinfo.lbin += cinfo->lbin;
		_GlobalMeters.cinfo.ticketout += cinfo->ticketout;
		_GlobalMeters.cinfo.promoout += cinfo->promoout;
		_GlobalMeters.cinfo.handpay += cinfo->handpay;
		_GlobalMeters.cinfo.aft2ticket += cinfo->aft2ticket;
		_GlobalMeters.cinfo.aft2host += cinfo->aft2host;
		_GlobalMeters.cinfo.lb2ticket += cinfo->lb2ticket;
		cinfo1 = &_GlobalMeters.cinfo;
		if (IsWaiting4PurchaseAck() == SDL_FALSE) {
			SendCashInfo1(cinfo1);
		}
	}
#endif
}

void SendCashInfoTicketOut(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.ticketout = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoPromoOut(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.promoout = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoHandPay(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.handpay = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoAft2Ticket(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.aft2ticket = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoLB2Ticket(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.lb2ticket = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoAFT2Host(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.aft2host = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoBillIn(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.billin = (long)amount;
	SendCashInfo(&cinfo);
#else
 #ifdef VICTORYLAND
  #ifdef USE_MAG_CARD
   #ifndef USE_MAG_CARD_ONLY
	struct sockaddr *dest_addr = (struct sockaddr *)&_DestAddr;
        char *ts=getTimeStamp();
	char buf[SNPRINTF_LIMIT + 1];
	int count1 = 0;
	int count2 = 0;
	int count5 = 0;
	int count10 = 0;
	int count20 = 0;
	int count50 = 0;
	int count100 = 0;
	switch (amount) {
	case 100:	//$1
		++count1;
		break;
	case 200:	// $2
		++count2;
		break;
	case 500:	//$5
		++count5;
		break;
	case 1000:	//$10
		++count10;
		break;
	case 2000:	//$20
		++count20;
		break;
	case 5000:	//$50
		++count50;
		break;
	case 10000:	//$100
		++count100;
		break;
	}


	sprintf(buf,"purchaseid=%d,timestamp=%s,macaddr=%s,passport=%s,asset=%d,purchamount=%lld,:one=%1d:two=%1d:five=%1d:ten=%1d:twenty=%1d:fifty=%1d:hundred=%1d", _GlobalMeters.cashinfoid, ts, macaddr, _BCInfo.passport, _GlobalConfig.assetID, amount, count1, count2, count5, count10, count20, count50, count100);
	strcpy(lastPurchasebuf, buf);		// save off data for purchase
	SetWaiting4PurchaseAck();		// set flag to indicate waiting for ack
	LastPurchaseTime = SDL_GetTicks();
	SavePurchaseBuf();
#ifndef PURCHASETEST
	sendClass(_Socket, dest_addr, "progressive", _TheEgmID, "purchase", buf);
#endif
	++_GlobalMeters.cashinfoid;
   #endif
  #endif
 #endif
#endif
}

void SendCashInfoTicketIn(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.ticketin = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoPromoIn(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.promoin = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoAFTIn(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.aftin = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

void SendCashInfoLBIn(unsigned long long amount)
{
#ifdef CLASS3_OR_BINGOSAS
	cashinfo cinfo;
	memset(&cinfo, 0, sizeof(cashinfo));
	cinfo.lbin = (long)amount;
	SendCashInfo(&cinfo);
#endif
}

char *getTicketDateTime(char *date, char *time);
void IncrLongLongMeter(unsigned long long *met, long long incramt, int metersize);
void IncrLongMeter(unsigned long *met, long incramt, int metersize);

#ifdef SASMODE
// Comms Down / player pressed cashout
// flag=0 comms down hand pay
//	SHP_JP_SV		6	// System Validation no hand pay receipt. Lockup, then save to hand pay log
//	SHP_JP_NP		7	// No print jackpot ticket. Lockup, then save to hand pay log
//	SHP_CASHABLE		8	// error getting validation id. Lockup, then save to hand pay log
//	SHP_COMMS_DOWN		9	// Comms down cash out. Lockup, then save to hand pay log
//	SHP_LARGE_WIN_NP	10	// No print jackpot ticket. Lockup, then save to hand pay log
//	SHP_LARGE_WIN_SV	11	// System Validation no hand pay receipt. Lockup, then save to hand pay log
//	SHP_TICKET_LIMIT_NP	12	// No print jackpot ticket. Lockup, then save to hand pay log
//	SHP_TICKET_LIMIT_SV	13	// System Validation no hand pay receipt. Lockup, then save to hand pay log
//	SHP_AFT_NP		14	// aft cashout
//	SHP_AFT_SV		15	// aft cashout
// tickCnt   total number of tickets printed for this cashout
// inx       ticket index for this cashout, bit 7 set indicates playable only
void SpecialHandpay(long long amount, int flag, int inx, int tickCnt)
{
#ifndef TABLET
    queueElementHP HPQElem1;  // Handpay Q Elem.
    queueElementV VQElem1;    // Validation Q Elem.
    unsigned char d1str[10];
    unsigned long d1;
    int validtype = 0x40;   // Cancelled credit handpay from cashout (no rcpt printed) table 15.13C
    char prntDate[64];
    char prntTime[64];
    char *timestamp;
    long long vidll;
    voucherLogType vl1;
    int i;

    timestamp=getTicketDateTime(prntDate,prntTime);
    //build struct and save to flash...
      	vl1.voucherId = 0;
      	vl1.transferAction = 1;  //1=issued,...,
      	vl1.voucherAmount = amount;
      	vl1.transferAmount = amount;
      	//vl1.transferSequence = _GlobalMeters.handpayTransSeq++;
      	vl1.transferSequence = _GlobalMeters.voucherTransSeq++;
        vl1.signature = HANDPAYLOGSIGNATURE;
        vl1.largeWin = flag;
	vl1.inx = inx;
	vl1.numTicks = tickCnt;

      	sscanf(timestamp,"%lld",&vidll);
      	vl1.egmDateTime = vidll;
      	vl1.cageDateTime = _SASGlobalMeters.CurrentRestrExpire;
      	//vl1.transactionId = 0;
        vl1.transactionId = _GlobalMeters.handpaySeq++;
      	vl1.ValidType = validtype;

       if (_ExtendedConfig.ProgControllerType == 2)
       		HPQElem1.ProgressiveGroup=0;  // 1 binary
       else
       		HPQElem1.ProgressiveGroup=_ExtendedConfig.SASGroup;  // 1 binary
        //HPQElem1.Level=0x80;               // 0==>Non Progressive since this is a regular cashout/comms down
       //HPQElem1.Level=_GlobalMeters._cctrue;        // 0x80 for forced hp / cashout -comms down  'OR' 0x0 for Normal JP Handpay
       switch (flag) {
	case SHP_JP_SV:
	//case SHP_JP_NP:
		HPQElem1.Level = 0;
		break;
	case SHP_CASHABLE:
	case SHP_COMMS_DOWN:
		HPQElem1.Level = 0x80;		// cancelled credits
		break;
	//case SHP_LARGE_WIN_NP:
	case SHP_LARGE_WIN_SV:
		HPQElem1.Level = 0;
		break;
	//case SHP_TICKET_LIMIT_NP:
	case SHP_TICKET_LIMIT_SV:
		HPQElem1.Level = 0x80;		// cancelled credits
		break;
	//case SHP_AFT_NP:
	case SHP_AFT_SV:
		HPQElem1.Level = 0x80;		// cancelled credits
		break;
       }
        HPQElem1.Amount=amount;         // 5 BCD
        HPQElem1.PartialPay=0;   // 2 BCD
        HPQElem1.ResetID=0;      // 1 binary 0==> only std handpay reset method available
#ifdef notdef
        fprintf(_debugPort,"SpecialHandpay call AddHPInfoQ amount=%d _cctrue=%d,  flag=%x,%x\n",amount,_GlobalMeters._cctrue, flag, HPQElem1.Level);
#endif
        AddHPInfoQ(&HandpayQ, &HPQElem1);
        //instate51 = 1;		// moved to inside AddHPInfoQ
	
	VQElem1.PoolId = 0;      // 0=unrestricted
	VQElem1.ValidationType = validtype; //0=cashable tick from cashout or win, no handpay l/u. 1=Restricted pg . 15-24
	for (i=0; i<4; i++)     // get date first
		d1str[i]=timestamp[i+4];
	for (i=0; i<4; i++)     // then get year
		d1str[i+4]=timestamp[i];
	d1str[8]=0;             // null terminate
	sscanf(d1str,"%ld",&d1);
	VQElem1.Date=d1;   // 4 BCD
	for (i=0; i<6; i++)     // get date first
		d1str[i]=timestamp[i+8];
	d1str[6]=0;             // null terminate
	sscanf(d1str,"%ld",&d1);
	VQElem1.Time=d1;     // 3 BCD
	//sscanf(&vid[2],"%lld",&vidll);
	//VQElem1.ValidationNumber=vl1.voucherId;  // 8 BCD
	vidll = 0;			// we didn't get one
	VQElem1.ValidationNumber=vidll;  // 8 BCD
	VQElem1.Amt=amount;         // 5 BCD
	//VQElem1.Ticknum=vl1.transferSequence;    // 2 binary
	VQElem1.Ticknum = 0xffff;
	//VQElem1.Expiration=_ExtendedConfig.ticketExpireDays;    // 4 BCD
	VQElem1.ValidSysId=0;    // 1 BCD
	if (validtype == 1) {
		VQElem1.PoolId=_SASGlobalMeters.CurrentPoolID;    // Restricted PoolID
		VQElem1.Expiration=_SASGlobalMeters.CurrentRestrExpire;    // Restricted Expiration
	} else {
		VQElem1.PoolId=0;    // Non Restricted
		VQElem1.Expiration=_ExtendedConfig.ticketExpireDays;    // Non Restricted Expiration
	}
	AddValInfoQ(&ValidationQ, &VQElem1);
	
        FlashHandpayLog(&vl1); // writes struct to next available location.
	_totalCashIn=0;
	switch (flag) {
	case SHP_CASHABLE:
	case SHP_COMMS_DOWN:
	//case SHP_AFT_NP:
	case SHP_AFT_SV:
	//case SHP_TICKET_LIMIT_NP:
	case SHP_TICKET_LIMIT_SV:
		IncrLongLongMeter(&_SASGlobalMeters.HandpaidCancelledCredits,amount,5);
		IncrLongLongMeter(&_GlobalMeters.PattCancelledCredits,amount,5);
		SendCashInfoHandPay(amount);
		break;
	case SHP_JP_SV:				// already metered to att paid progressive and att paid jackpots
	//case SHP_JP_NP:
		break;
	//case SHP_LARGE_WIN_NP:			// these are currently legacy bonus, already metered to External Bonus
	case SHP_LARGE_WIN_SV:
		break;
	}
        fprintf(_debugPort,"_SASGlobalMeters.HandpaidCancelledCredits=%lld\n",_SASGlobalMeters.HandpaidCancelledCredits);
#endif
}

void NetSendIssueVoucher(char *vid,long long amount,char *aid, char *ts, long long transSeq,int largewinflag,int ValidType, unsigned long expiration)
{
        long long vidll;
	voucherLogType vl1;
        unsigned char d1str[10];
        unsigned long d1;
        queueElementV VQElem1;    // Validation Q Elem.
        queueElementHP HPQElem1;  // Handpay Q Elem.
        int i,j;
	int singlewin = 0;
        int ConvertBetLevel[6] = {0, 5, 4, 3, 2, 1 }; //Game BetLevel 1 is lowest, Sas expects BetLevel 1 to be highest contributing so we must reverse it.

#ifndef PRODUCTION
	fprintf(_debugPort, "NetSendIssueVoucher(%s, amt=%lld, ts=%s, transSeq=%lld, largewinflag=%d, ValidType=%d, expiration=%d\n", vid, amount, ts, transSeq, largewinflag, ValidType, expiration);
#endif

        for (i=1,j=_maxBetLevel; i<=_maxBetLevel; i++,j--) {
                ConvertBetLevel[i] = j;
                //fprintf(_debugPort," ConvertBetLevel[%d]=%d\n",i,ConvertBetLevel[i]);
        }
      //build struct and save to flash...
      sscanf(vid,"%lld",&vidll);
      vl1.voucherId = vidll;
      vl1.transferAction = 1;  //1=issued,...,
      vl1.voucherAmount = amount;
      vl1.transferAmount = amount;
      //voucherLog.tran sferSequence = vidll;
      vl1.transferSequence = transSeq;
      if (largewinflag) {				//0 normal, 1 largeWin, 2 ticket limit, 3 aft, 4 legacy bonus
        vl1.signature = HANDPAYLOGSIGNATURE;
//      	vl1.largeWin = largewinflag;
	if ((largewinflag == HP_JP) || (largewinflag == HP_LARGE_WIN)) {
		vl1.largeWin = largewinflag;		//LARGEWINTRUE;
		singlewin = 1;
	} else {
		vl1.largeWin = largewinflag;		//LARGEWINFALSE;
	}
        vl1.transactionId = _GlobalMeters.handpaySeq++;
	vl1.inx = 0;				// hand pay always cashable at the cashier
	vl1.numTicks = 1;
      } else {
      	vl1.largeWin = 0;        //0=false 1=true
        vl1.signature = VOUCHERLOGSIGNATURE;
        vl1.transactionId = _GlobalMeters.voucherSeq++;
	if (amount == _GlobalMeters.amt2CashOut) {		// only 1 ticket
		vl1.inx = 0;
		vl1.numTicks = 1;
	} else {
		vl1.numTicks = 2;				// 2 tickets involved
		if (_GlobalMeters.amt2CashOut == _GlobalMeters.amtCashedOut)	// figure out 1st or 2nd ticket
			vl1.inx = 1;
		else
			vl1.inx = 0;
	}
      }
      sscanf(ts,"%lld",&vidll);
      vl1.egmDateTime = vidll;
      vl1.cageDateTime = expiration;
#ifdef notdef
      sscanf(aid,"%lld",&vidll);
      vl1.transactionId = vidll;
#endif
      vl1.ValidType = ValidType;
#ifdef SASMODE
      if (_ExtendedConfig.ProgControllerType != 2)
       		HPQElem1.ProgressiveGroup=_ExtendedConfig.SASGroup;  // 1 binary
      else
      		HPQElem1.ProgressiveGroup=0;  // 1 binary     
      //fprintf(_debugPort,"NetSend largewinflag=%x, validType=%x\n", largewinflag, ValidType);
      fprintf(_debugPort,"NetSend largewinflag=%x, validType=%x, _LastProgWin4GameActivity=%d\n", largewinflag, ValidType,_LastProgWin4GameActivity);
	  if ((largewinflag) || (ValidType & 0x40)) {	// hand pay
	       //if (singlewin == 1) 
               //		HPQElem1.ProgressiveGroup=_ExtendedConfig.SASGroup;  // 1 binary     
		//if (_GlobalMeters._ProgressiveWin > 0) {
		if (_LastProgWin4GameActivity > 0) {
#ifdef notdef
                        int i, level=0;
                        for (i=1; i<6; i++)
                        {
                                if (GetDenomX() == _dToLevel[i]) {
                                        level = i;
                                        break;
                                }
                        }
#endif
			int level = GetDenomLevel(GetDenomX());
#ifdef notdef
                        fprintf(_debugPort,"NetSend: level=%d\n",level);
#endif
               		HPQElem1.Level=ConvertBetLevel[_currentBetLevel];               // 1 binary
               		//HPQElem1.Level=level;               // 1 binary
		            fprintf(_debugPort,"NetSend: HPQElem1.level=%d\n",HPQElem1.Level);
		} else {
			if ((ValidType==0x40) || (ValidType==0x10)) // Cancelled Credits(hand pay)
               			HPQElem1.Level=0x80;               // 0x80==>Cancelled Credits
			else
               			HPQElem1.Level=0;               // 0==>Non Progressive
			if (largewinflag == HP_TICK_LIMT)
				HPQElem1.Level=0x80;               // 0x80==>Cancelled Credits
		}
               HPQElem1.Amount=amount;         // 5 BCD
               HPQElem1.PartialPay=0;   // 2 BCD
	       if ((SAS_A8_Credit2Game_Enabled() == SDL_TRUE) && 
			(amount < _ExtendedConfig.JackpotUpperLimit) &&
			((_GlobalMeters.PlayerAccount + amount) < _ExtendedConfig.MaxCredit))
		{
               		HPQElem1.ResetID=1;      // 1 binary 1==> Handpay reset to the credit meter is available
		} else
               		HPQElem1.ResetID=0;      // 1 binary 0==> only std handpay reset method available
		_SASGlobalMeters.lastResetID = HPQElem1.ResetID;
#ifdef notdef
	       fprintf(_debugPort,"NetSend call AddHPInfoQ\n");
#endif
	       if (singlewin == 1) {
               		AddGameEndExcQ();      // SAS
			if (_LastWin4GameActivity == 0)
	       			_SentGameEndFlg = 1;   // indicate we alrdy sent the game end.
	    	       SDL_Delay(200);        // 1/5 second  *allows gameendexc to go before the 0x51.
	       }
               AddHPInfoQ(&HandpayQ, &HPQElem1);
	       //instate51 = 1;			// moved to inside AddHPInfoQ
       //} else {	// allow
      }	// allow 0x3D (ticket printed) not->0x3E Gen Exc (HP validated) and 0x4D (send enhanced validation info) 
              //fprintf(_debugPort,"ts=%s\n",ts);
              VQElem1.PoolId = 0;      // 0=unrestricted
              VQElem1.ValidationType = ValidType; //0=cashable tick from cashout or win, no handpay l/u. 1=Restricted pg . 15-24
              for (i=0; i<4; i++)     // get date first
                      d1str[i]=ts[i+4];
              for (i=0; i<4; i++)     // then get year
                      d1str[i+4]=ts[i];
              d1str[8]=0;             // null terminate
              sscanf(d1str,"%ld",&d1);
              VQElem1.Date=d1;   // 4 BCD
              for (i=0; i<6; i++)     // get date first
                      d1str[i]=ts[i+8];
              d1str[6]=0;             // null terminate
              sscanf(d1str,"%ld",&d1);
              VQElem1.Time=d1;     // 3 BCD
      	      sscanf(&vid[2],"%lld",&vidll);
              //VQElem1.ValidationNumber=vl1.voucherId;  // 8 BCD
              VQElem1.ValidationNumber=vidll;  // 8 BCD
              VQElem1.Amt=amount;         // 5 BCD
	      if (ValidType & 0x40) {		// ticket not printed
		      VQElem1.Ticknum= 0xffff;
	      } else
              VQElem1.Ticknum=transSeq;    // 2 binary
              //VQElem1.Expiration=_ExtendedConfig.ticketExpireDays;    // 4 BCD
              VQElem1.ValidSysId=0;    // 1 BCD
	      if (ValidType == 1) {
              	VQElem1.PoolId=_SASGlobalMeters.CurrentPoolID;    // Restricted PoolID
              	VQElem1.Expiration=_SASGlobalMeters.CurrentRestrExpire;    // Restricted Expiration
	      } else {
              	VQElem1.PoolId=0;    // Non Restricted
              	VQElem1.Expiration=_ExtendedConfig.ticketExpireDays;    // Non Restricted Expiration
	      }
              AddValInfoQ(&ValidationQ, &VQElem1);
      //}
#endif
      if (largewinflag)
      	FlashHandpayLog(&vl1); // writes struct to next available location.
      else
      	FlashVoucherLog(&vl1); // writes struct to next available location.
}
#endif

void processCabinetClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
        char buf[128];

//   x   getcabinetStatus		cabinetStatus
//	 x		getCabinetProfile		cabinetProfile
//	 x		setCabinetState		cabinetStatus
//	 x		setCabinetLockOut		cabinetStatus
//			setDateTime		cabinetDateTime
//			getDateTime		cabinetDateTime
//			resetProcessor		resetStarted

        DATA_PAIRS CabinetDatapairs[]={
                        {"lockOut",""},
                        {"lockText",""},
                        {"lockTimeOut",""},
                        {"enable",""},
                        {"disableText",""},
                        {"enableGamePlay",""},
                        {"enableMoneyIn",""},
                        {"enableMoneyOut",""},
                        {"machineNum",""},
                        {"machineId",""},
                        {"currencyId",""}, 
			{"voucherReprint",""},                       
                        };
        int CabinetDataCount=12;

        if (strcmp(egmclass->Command,"setDateTime") == 0) {
                //printf("cabinet : setDateTime received\n");
                //SET THE TIME HERE
                SetDateTime(sockfd,destAddr,egmclass);
                IoBoard_WriteRTC();
                _hasDateTime=SDL_TRUE;
                //SDL_bool _hasDateTime=SDL_FALSE;
                //SDL_bool _hasVoucherConfig=SDL_FALSE;
                //SDL_bool _hasVoucherIds=SDL_FALSE;

                if (_LocalTimeOffset < 0)
                        sprintf(buf,"cabinetDateTime=%s,localOffset=%03d",getTimeStamp(),_LocalTimeOffset);
                else
                        sprintf(buf,"cabinetDateTime=%s,localOffset=%02d",getTimeStamp(),_LocalTimeOffset);
                sendClass(sockfd,destAddr,"cabinet",_TheEgmID,"cabinetDateTime",buf);
    
    //NB THE FIRST TIME WE NEED TO set FLAGS to 
    //                      SendGetVoucherConfiguration      & SendGetVoucherValidationIds 

        }
        else if (strcmp(egmclass->Command,"getDateTime") == 0)  {
                //printf("cabinet : getDateTime received\n");
                if(_LocalTimeOffset<0)
                        sprintf(buf,"cabinetDateTime=%s,localOffset=%03d",getTimeStamp(),_LocalTimeOffset);
                else
                        sprintf(buf,"cabinetDateTime=%s,localOffset=%02d",getTimeStamp(),_LocalTimeOffset);
                sendClass(sockfd,destAddr,"cabinet",_TheEgmID,"cabinetDateTime",buf);
        }
  else
    processBadClass(sockfd,destAddr,egmclass);
}


void SetDateTime(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
//  "cabinet:WGSC00001:20040316184627432:cabinetDateTime:cabinetDateTime=20060316184627432:localOffset=-07:<CR>"
#ifdef notdef
        fprintf(_debugPort,"SetDateTime\n");
#endif
#ifndef CLASS3_OR_BINGOSAS			// SAS sets the clock
        DATA_PAIRS datapairs[] = {
                        {"cabinetDateTime",""},
                        {"localOffset",""},
			{"localTime",""},
                        };
        int count = 3;
        struct tm timeVals;
        struct timeval tv;
        extern long int timezone;
        extern int daylight;

        extractDataPairs(egmclass->Data,datapairs,count);
        if(strlen(datapairs[1].data) > 0)
                _LocalTimeOffset = atoi(datapairs[1].data);
#ifdef notdef
        fprintf(_debugPort,"SetDateTime _LocalTimeOffset=%d\n",_LocalTimeOffset);
#endif

	if (_ExtendedConfig.SASEnabled == SDL_FALSE && (strlen(datapairs[2].data) > 0)) {                //decode the local DateTime
                char *buffp = &datapairs[2].data[0];
                char tmpbuf[64];
		char *curLocalTime = getTimeStamp();

		_LocalTimeOffset = 0;	// - _LocalTimeOffset;

		if (strncmp(curLocalTime, buffp, 14) == 0) return;	// if same time, don't change
		fprintf(_debugPort, "curLocalTime=%s, newTime=%s\n", curLocalTime, buffp);
                memset(&timeVals,0,sizeof(timeVals));

                strcpy(tmpbuf,buffp);  //get the year
                tmpbuf[4] = '\0';
                timeVals.tm_year = atoi(tmpbuf) - 1900;

                buffp = buffp + 4;
                strcpy(tmpbuf,buffp);  //get the month
                tmpbuf[2] = '\0';
                timeVals.tm_mon = atoi(tmpbuf) - 1;

                buffp = buffp + 2;
                strcpy(tmpbuf,buffp);  //get the day
                tmpbuf[2] = '\0';
                timeVals.tm_mday = atoi(tmpbuf);

                buffp = buffp+  2;
                strcpy(tmpbuf,buffp);  //get the hour
                tmpbuf[2] = '\0';
                timeVals.tm_hour = atoi(tmpbuf);

                buffp = buffp + 2;
                strcpy(tmpbuf,buffp);  //get the minutes
                tmpbuf[2] = '\0';
                timeVals.tm_min=atoi(tmpbuf);

                buffp = buffp + 2;
                strcpy(tmpbuf,buffp);  //get the seconds
                tmpbuf[2] = '\0';
                timeVals.tm_sec = atoi(tmpbuf);

                putenv("TZ=UTC0");             //tell mktime that the time is UTC
#ifdef notdef
                fprintf(_debugPort,"%d %d %d %d %d %d\n",timeVals.tm_year,timeVals.tm_mon,timeVals.tm_mday,timeVals.tm_hour,timeVals.tm_min,timeVals.tm_sec);
#endif
                if( (tv.tv_sec = (long)mktime(&timeVals)) != -1) {
                        LOG_WARN("mktime OK");
#ifdef notdef
                        fprintf(_debugPort,"mktime OK\n");      
#endif
                        tv.tv_usec = 0;
                        if(settimeofday(&tv,NULL) < 0) {
                                LOG_WARN("settimeofday ERROR:%d[%s]", errno, strerror(errno));
                                //FlashEvent(4,"Date Chg Bad1");
#ifndef LOADTEST
                                _saveDateEvent = 1;
#endif
                        } else {
                                //FlashEvent(4,"Date Chg Good");
#ifndef LOADTEST
                                _saveDateEvent = 2;
#endif
			}
                }
                else {
                        LOG_WARN("mktime ERROR:%d[%s]", errno, strerror(errno));
#ifdef notdef
                        fprintf(_debugPort,"mktime ERROR\n");
#endif
                        //FlashEvent(4,"Date Chg Bad2");
#ifndef LOADTEST
                        _saveDateEvent = 3;
#endif
                }
        }
#endif             
}

void SendProgGameInfo()
{
#ifndef BINGO
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
	int betLevel = GetProgLevel();
	
#ifdef notdef1
        fprintf(_debugPort,"SendProgGameInfo: _currentBetLevel=%d\n",_currentBetLevel);
#endif
        sprintf(buf,"progGroup=%ld,denom=%d,progLevel=%d,creditsWagered=%d,coinInMeter=%lld,gameid=%d,balance=%lld",
                _ExtendedConfig.SASGroup, GetDenomX(), betLevel, GetTotalCreditsBet(), _GlobalMeters.GCashPlayed, _GlobalMeters.gameid, _GlobalMeters._startMoney4GA);
#ifdef notdef1
	fprintf(_debugPort,buf);
#endif	
        sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"gameInfo",buf);
	_GlobalMeters.GameInfoSent = 1;
#endif
}

// This returns progressive level based 1
int GetProgLevel()
{
	int level = _currentBetLevel;
	if (_JackPotType == JP_BONUS) {
		level = GetCurrentMJBetLevel() + 1;	// make base 1
	}
	return level;
}

void SendProgHitInfo(unsigned long long winamt)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        char *ts=getTimeStamp();
	int level = GetProgLevel();	// progressive level based 1
	int gameid;

#ifdef BINGO
	gameid = _BCInfo.gameid;
#else
	gameid = _GlobalMeters.gameid;
#endif

#ifdef notdef1
        fprintf(_debugPort,"SendProgHitInfo: _currentBetLevel=%d\n",_currentBetLevel);
#endif
        sprintf(buf,"progId=%ld,progLevel=%d,progWin=%lld,hitDateTime=%s,denom=%d,GameName=%s,asset=%d,gameid=%d",
                _ExtendedConfig.SASGroup, level, winamt, ts, GetDenomX(), _ProductId, _GlobalConfig.assetID, gameid);
#ifdef notdef1
        fprintf(_debugPort,"SendProgHitInfo: buf=%s\n",buf);
#endif
	LastProgHitTime = SDL_GetTicks();
#ifdef BINGO
	if (_JackPotType != JP_BONUS) 
#endif
	{
		//strcpy(lastProgHitbuf, buf);
		//strcpy(lastProgCelebBuf, buf);
		//bonusInfo.waiting4ProgHitAck = 1;
		//SaveLastProgHitBuf();
		_GlobalMeters._ProgressiveWinReceived = SDL_FALSE;
		//_saveMetersRequired = SDL_TRUE;
	}
	strcpy(lastProgHitbuf, buf);
	strcpy(lastProgCelebBuf, buf);
	bonusInfo.waiting4ProgHitAck = 1;
	SaveLastProgHitBuf();
	_saveMetersRequired = SDL_TRUE;
        sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"progressiveHit",buf);
}

void SendProgCelebrate(void)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
#ifndef PRODUCTION
	fprintf(_debugPort, "SendProgCelebrate(%s)\n", lastProgCelebBuf);
#endif
	sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"progressiveCeleb", lastProgCelebBuf);
}

#ifdef BINGO
static char *sleptstr[] = {
	"none", "daub", "claim", "both"
};
#endif

void SendGameActivity(unsigned long long winamt, unsigned long long progamt)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        char *ts=getTimeStamp();
	unsigned long long handpayamt = 0;
	int timeout;
	unsigned long long endBalance;
	int costPerPlay = _numberOfLinesBet;
#ifdef BINGO
	unsigned long long startBalance = GetBingoStartingBalance();
#else
	unsigned long long startBalance = _GlobalMeters._startMoney4GA;
#endif
	int progLevel = GetProgLevel();
#ifdef TEST_GT
	static int test_greentrack = 1;
#endif
	
#ifdef LOADTEST
	if (progamt) fprintf(_debugPort, "[1] JACKPOT\n");
#endif

#ifdef PULLTAB
	costPerPlay = _PTInfo[_currentBetLevel - 1].price;
#else
	if (_GlobalConfig.price) costPerPlay = _GlobalConfig.price;
#endif

#ifdef BINGO
	_GlobalMeters._pendingWinner = 0;
	if (GetBingoTimeoutStatus() == 1) {		// daub timeout
		winamt = GetInterimPrize() + GetBingoPrize();
		progamt = 0;
		//if (IsBingoJackpot() == SDL_TRUE) {
		//	progamt = _GlobalMeters._ProgressiveWin;
		//	winamt += progamt;
		//}
	} else 
#endif
	if (winamt >= _ExtendedConfig.LockupAmount) {
#ifdef CLASS3_OR_BINGOSAS
 #ifndef LOADTEST
		handpayamt = _SASGlobalMeters.lastHandPayAmt;
 #else
		handpayamt = winamt;
 #endif
#else
		handpayamt = winamt;
#endif
	}
	

	if (_ExtendedConfig.ProgControllerType == 2) {
		// if networking is eanbled, must have send gameInfo to continue
		if (_GlobalMeters.GameInfoSent == 0) return;
		_GlobalMeters.GameInfoSent = 0;
	}
	
	if (winamt < progamt) return;	// not valid

//#ifdef MPPT	// meters per pay table
	{
		int levelMPPT = GetPayLevel()-1;

                IncrLongLongMeter(&_GlobalMeters.gamesPlayedPPT[levelMPPT],1,5);
                IncrLongLongMeter(&_GlobalMeters.cashPlayedPPT[levelMPPT],GetTotalBet(),5);
		if (winamt > 0) {
                	IncrLongLongMeter(&_GlobalMeters.gamesWonPPT[levelMPPT],1,5);
			if (progamt > 0) {
                		IncrLongLongMeter(&_GlobalMeters.cashWonPPT[levelMPPT],winamt-progamt,5);
                		IncrLongLongMeter(&_GlobalMeters.progWonPPT[levelMPPT],progamt,5);
                		IncrLongLongMeter(&_GlobalMeters.progWinPerLevel[_currentDenomination][_currentBetLevel-1],progamt,5);
			} else {
                		IncrLongLongMeter(&_GlobalMeters.cashWonPPT[levelMPPT],winamt,5);
			}
		}
	}
//#endif
	if (_ExtendedConfig.ProgControllerType != 2) {
		// network is not enabled, all we want is update performance meters. We are done.
		return;
	}
#ifdef BINGO
	
	endBalance = GetBingoEndingBalance();
	//endBalance = GetBingoEndingBalance() - GetTotalBet();
	switch (GetBingoTimeoutStatus()) {
	case 0: //claimed and daubed
		if (handpayamt || progamt)
			endBalance = endBalance - handpayamt + progamt;
		break;
	case 1: //daub timedout
		endBalance = GetBingoEndingBalance() - winamt;
                IncrLongLongMeter(&_GlobalMeters.PDaubSleptAmount,winamt,5);
                IncrLongLongMeter(&_GlobalMeters.GDaubSleptAmount,winamt,5);
		break;
	case 2: //claim timedout
		endBalance = GetBingoEndingBalance() - winamt;
                IncrLongLongMeter(&_GlobalMeters.PClaimSleptAmount,winamt,5);
                IncrLongLongMeter(&_GlobalMeters.GClaimSleptAmount,winamt,5);
		break;
	}
	
	SetLastActivityTime();
	timeout = GetBingoTimeoutStatus();

	//fprintf(_debugPort, "SendGameActivity()\n");
 //#ifdef BINGOSAS
 #if defined(BINGOSAS) && !defined(FAKECARDBASED)
        sprintf(buf,"gameid=%d,balance=%lld,BetLevel=%d,AmtWon=%lld,ProgAmt=%lld,AmtHandpay=%lld,TimeStamp=%s,CreditsWagered=%d,Denom=%d,Lines=%d,CoinsLine=%d,GameName=%s,cardnum=%lld,gamenum=%lld,wincount=%1d,prizes=%1d,bingoprize=%1d,paylevel=%d,setid=%d,macaddr=%s,timeout=%s,progGroup=%d,progLevel=%d,startBalance=%lld,asset=%d",
	_BCInfo.gameid,endBalance,_currentBetLevel,winamt-progamt,progamt,handpayamt,ts, costPerPlay*_creditsPerLine,GetDenomX(),_numberOfLinesBet, _creditsPerLine,_ProductId,_BCInfo.cardnum,_BCInfo.gamenumber,GetBingoWinCount(), GetInterimPrize(),GetBingoPrize(),GetPayLevel(),setid,macaddr,sleptstr[GetBingoTimeoutStatus()], _ExtendedConfig.SASGroup, progLevel, startBalance, _GlobalConfig.assetID);
	//fprintf(_debugPort, "buf[%d]\n", strlen(buf));
 #else
  #ifdef PULLTAB
        sprintf(buf,"gameid=%d,balance=%lld,BetLevel=%d,AmtWon=%lld,ProgAmt=%lld,AmtHandpay=%lld,TimeStamp=%s,CreditsWagered=%d,Denom=%d,Lines=%d,CoinsLine=%d,GameName=%s,passport=%s,paylevel=%d,setid=%d,macaddr=%s,progGroup=%d,progLevel=%d,startBalance=%lld,dealname=%s,ticknum=%lld,asset=%d",
	_BCInfo.gameid,endBalance,_currentBetLevel,winamt-progamt,progamt,handpayamt,ts,_creditsPerLine*costPerPlay,GetDenomX(),_numberOfLinesBet,_creditsPerLine,_ProductId,_BCInfo.passport,
	GetPayLevel(),setid,macaddr,_ExtendedConfig.SASGroup, _currentBetLevel, startBalance, 
	_BCInfo.DEAL_NAME, _BCInfo.TICK_NUM,
	_GlobalConfig.assetID);
	//fprintf(_debugPort, "buf[%d]\n", strlen(buf));
  #else
        sprintf(buf,"gameid=%d,balance=%lld,BetLevel=%d,AmtWon=%lld,ProgAmt=%lld,AmtHandpay=%lld,TimeStamp=%s,CreditsWagered=%d,Denom=%d,Lines=%d,CoinsLine=%d,GameName=%s,passport=%s,cardnum=%lld,gamenum=%lld,wincount=%1d,prizes=%1d,bingoprize=%1d,paylevel=%d,setid=%d,macaddr=%s,timeout=%s,progGroup=%d,progLevel=%d,startBalance=%lld,asset=%d",
                //_CurrentPlayerAccount,_currentBetLevel,winamt-progamt,progamt,handpayamt,ts,_numberOfLinesBet*_creditsPerLine,GetDenomX(),_numberOfLinesBet,_creditsPerLine,_ProductId,_BCInfo.passport,_BCInfo.cardnum,_BCInfo.gamenumber,GetBingoWinCount(),GetInterimPrize(),GetBingoPrize(),GetPayLevel(),setid,macaddr);
		_BCInfo.gameid,endBalance,_currentBetLevel,winamt-progamt,progamt,handpayamt,ts,costPerPlay*_creditsPerLine,GetDenomX(),_numberOfLinesBet,_creditsPerLine,_ProductId,_BCInfo.passport,_BCInfo.cardnum,_BCInfo.gamenumber,GetBingoWinCount(),
				      GetInterimPrize(),GetBingoPrize(),GetPayLevel(),setid,macaddr,sleptstr[GetBingoTimeoutStatus()],_ExtendedConfig.SASGroup, progLevel, startBalance, _GlobalConfig.assetID);
	//fprintf(_debugPort, "buf[%d]\n", strlen(buf));
  #endif
 #endif
#else //not BINGO
	endBalance = _CurrentPlayerAccount;
 #ifdef notdef
	if (handpayamt || progamt)
			endBalance = endBalance - handpayamt + progamt;
 #endif
	endBalance = _CurrentPlayerAccount + _GlobalMeters._pendingWinner;	// only time pending winner is non-zero is when there are free spins.
	if (handpayamt && _GlobalMeters._pendingWinner > 0)
		endBalance = endBalance - handpayamt;
 #ifdef notdef
        sprintf(buf,"BetLevel=%d,AmtWon=%lld,AmtHandpay=%lld,TimeStamp=%s,CreditsWagered=%d,Denom=%d,GameName=GCOLCL3",
                _currentBetLevel,winamt-progamt,progamt,ts,_numberOfLinesBet*_creditsPerLine,GetDenomX());
 #endif
        sprintf(buf,"gameid=%d,balance=%lld,BetLevel=%d,AmtWon=%lld,ProgAmt=%lld,AmtHandpay=%lld,TimeStamp=%s,CreditsWagered=%d,Denom=%d,Lines=%d,CoinsLine=%d,GameName=%s,macaddr=%s,timeout=none,progGroup=%d,progLevel=%d,startBalance=%lld,asset=%d",
	_GlobalMeters.gameid, endBalance, _currentBetLevel, winamt-progamt, progamt, handpayamt, ts, costPerPlay*_creditsPerLine, GetDenomX(), _numberOfLinesBet, _creditsPerLine,_ProductId, macaddr, _ExtendedConfig.SASGroup, progLevel, startBalance, _GlobalConfig.assetID);
	++_GlobalMeters.gameid;
#endif
	strcpy(lastGAbuf, buf);						// save off data for game activity
	SetWaiting4GameActivityAck();	// set flag to indicate waiting for ack
#ifdef BINGO
	//if ((bonusInfo.waiting4GAack & 0x02) == 0) 			// if not waiting for history ack
 #ifndef PRODUCTION
		if (doActivityTest == 1) {
			//doActivityTest = 0;
			_logOffAfterGameFlag = SDL_TRUE;
			fprintf(_debugPort, "force logoff\n");
		}
 #endif
 #ifdef TEST_OFS
		if (doActivityTest == 1) {
			doActivityTest = 0;
			SendBingoLogoff();
		}
 #endif
 #ifdef VICTORYLAND		
		if ((VNetOnLine() == SDL_TRUE) && (_GlobalMeters.serverLock != 4))
 #else
		if (VNetOnLine() == SDL_TRUE)
 #endif
#endif
		{		
#ifdef TEST_GT
			// test what happens when game activity is not sent
			if (test_greentrack == 0)
#endif
        		sendClass(_Socket,dest_addr,"progressive",_TheEgmID,"gameActivity",buf);	// send it
			LastGameActivityTime = SDL_GetTicks();
#ifdef TEST_GT
			// test what happens when game activity is not sent
			test_greentrack = 0;
#endif
		}
	
#ifdef notdef1
        fprintf(_debugPort,"SendGameActivity: buf=%s\n",buf);
#endif
	SaveLastActivityBuf();
#ifdef PULLTAB
	strcpy(cashlessLog.localDateTime,getTimeStamp());
	strcpy(cashlessLog.VNDateTime, "");		// timestamp from VNet
	cashlessLog.amount2Game = _creditsPerLine * _PTInfo[_currentBetLevel-1].price * _Denominations[_currentDenomination];	// transfer amount
	cashlessLog.amount2Server = winamt;	// transfer amount
	cashlessLog.handpay = handpayamt;
	cashlessLog.startBalance = startBalance;
	cashlessLog.endBalance = endBalance;
	strcpy(cashlessLog.type, "Game Play");
	cashlessLog.transactionSeq = _GlobalMeters.CashlessLogPtr + 1;
	strcpy(cashlessLog.passport, _BCInfo.passport);
	cashlessLog.crc = CRC((unsigned char *)&cashlessLog, sizeof(cashlessLog)-2, 0);
	CashlessLogWrite();
	IncrLongLongMeter(&_SASGlobalMeters.PCashlessAcctIn, cashlessLog.amount2Game, 4);
	IncrLongLongMeter(&_SASGlobalMeters.GCashlessAcctIn, cashlessLog.amount2Game, 4);
    	IncrLongLongMeter(&_SASGlobalMeters.PCashlessAcctOut, winamt, 4);
    	IncrLongLongMeter(&_SASGlobalMeters.GCashlessAcctOut, winamt, 4);
#endif
//#ifdef BINGOSAS
	_SASGlobalMeters.lastHandPayAmt = 0;
//#endif
#ifdef ntodef
	if (CreditExceeded() == SDL_TRUE) {
		_logOffAfterGameFlag = SDL_TRUE;
		fprintf(_debugPort, "testing logoff\n");
	}
#endif
#ifdef BINGO
	SetBingoState(BIS_INACTIVE, -1);
	if (handpayamt > 0) {
 #ifndef BINGOSAS
		_autoPlay = SDL_FALSE;
  #ifdef LOADTEST
		fprintf(_debugPort, "Handpay 1\n");
  #endif
		_BingoDisconnectState = BDIS_RECONNECT_ACKED;		// force a logoff
 #endif
	} else
#if defined(ATRIB)
	if ((winamt-progamt) != (GetInterimPrize()*GetDenomX()*costPerPlay+GetBingoPrize())) {
#else
	if ((winamt-progamt) != (GetInterimPrize()*GetDenomX()+GetBingoPrize())) {
#endif
		fprintf(_debugPort, "\n!!!!!!!!!!!!!!!!!!!!!!! winamt=%lld, progamt=%lld, interimprize=%d, denom=%d, costPerPlay=%d, bingoprize=%d\n",
		  winamt, progamt, GetInterimPrize(), GetDenomX(), costPerPlay, GetBingoPrize());
#ifndef PRODUCTION
		if (_ExtendedConfig.inDemoMode == 0) {		// demo mode will have discrepancies
			_autoPlay = SDL_FALSE;
		}
#endif
#ifndef BINGOSAS
		if (_ExtendedConfig.inDemoMode == 0) {		// demo mode will have discrepancies
#ifdef LOADTEST
			fprintf(_debugPort, "win amount mismatch1 \n");
#endif
			_BingoDisconnectState = BDIS_RECONNECT_ACKED;		// force a logoff
		}
#endif
		//SendBingoLogoff();
	}
#endif
	_saveMetersRequired = SDL_TRUE;
#ifdef FORCE_CNET_DISCONNECT_1
	if (++keepAliveCnt > 0) {
		_BrokenPipe = SDL_TRUE;
		keepAliveCnt = 0;
	}
#endif
}

#ifdef BINGO
void SendBingoLogin()
{
#if defined(FAKECARDBASED)
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
	
	strcpy(_BCInfo.passport, "260422");
	strcpy(_BCInfo.pin, "0001");
	sprintf(buf,"macaddr=%s,passport=%s,pin=%s,mindenom=%d",macaddr,_BCInfo.passport,_BCInfo.pin,_Denominations[0]);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"login",buf);
	return;
#else
#ifdef VICTORYLAND	// card based games only
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	SetBingoDisconnectState(BDIS_OK);
	if (strlen(_BCInfo.pin) == 0) {
#ifndef PRODUCTION
		if (doLoginTest == 1) {		// fake a bad passport
			doLoginTest = 0;
			sprintf(buf,"macaddr=%s,passport=00000000>,pin=0000,mindenom=1",macaddr);
		} else
#endif
		sprintf(buf,"macaddr=%s,passport=%s,pin=0000,mindenom=%d",macaddr,_BCInfo.passport,_Denominations[0]);
	} else {
		sprintf(buf,"macaddr=%s,passport=%s,pin=%s,mindenom=%d",macaddr,_BCInfo.passport,_BCInfo.pin,_Denominations[0]);
	}
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"login",buf);
	
#ifdef notdef3
    IncrLongLongMeter(&_CurrentPlayerAccount, 10000, 4);
    IncrLongLongMeter(&_GlobalMeters.PlayerAccount, 10000, 4);
    _saveMetersRequired = SDL_TRUE;
    DingUp(10000,0);
    SetAllButtonState(MSBTN_ON);
#endif
#endif
#endif
}

void SendBingoGetCard()
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();

#ifdef BINGOSAS
	sprintf(buf,"asset=%d",_GlobalConfig.assetID);
#else	
	sprintf(buf,"passport=%s",_BCInfo.passport);
#endif
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"getcard",buf);
	_BCInfo.gamenumber = 0;
}

void SendBingoStartPlay(char *cmd)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
//#ifdef FPP
	//int plevel = _currentBetLevel;
	int plevel = GetProgLevel();
//#else
//	technically, plevel should be progressive level. Cnet parses it into levelIndex
//	For FPP and HPP, bet level happens to be the same as paylevel. For HPP, Cnet
//	uses levelIndex to map into bingo paytable	
//	int plevel = GetProgLevel();
//#endif
	
	_BCInfo.gamenumber = 0;
#ifdef CLASS3_OR_BINGOSAS
//#ifdef BINGOSAS
#if defined(BINGOSAS) && !defined(FAKECARDBASED)
	if (_GlobalConfig.price > 0) {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,denom=%d,lines=%d,price=%d,coins=%d,paylevel=%d,balance=%lld,asset=%d",
			_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum, GetDenomX(), _numberOfLinesBet, _GlobalConfig.price, _creditsPerLine, GetPayLevel(), _GlobalMeters._startMoney, _GlobalConfig.assetID);
	} else {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,denom=%d,lines=%d,coins=%d,paylevel=%d,balance=%lld,asset=%d",
			_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum, GetDenomX(), _numberOfLinesBet, _creditsPerLine, GetPayLevel(), _GlobalMeters._startMoney, _GlobalConfig.assetID);
	}
#else
	if (_GlobalConfig.price > 0) {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,passport=%s,denom=%d,lines=%d,price=%d,coins=%d,paylevel=%d,balance=%lld,asset=%d",
		_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum,_BCInfo.passport, 	GetDenomX(), _numberOfLinesBet,_GlobalConfig.price, _creditsPerLine,GetPayLevel(), 		_GlobalMeters._startMoney, _GlobalConfig.assetID);
	} else {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,passport=%s,denom=%d,lines=%d,coins=%d,paylevel=%d,balance=%lld,asset=%d",
		_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum,_BCInfo.passport, 	GetDenomX(), _numberOfLinesBet, _creditsPerLine,GetPayLevel(), 		_GlobalMeters._startMoney, _GlobalConfig.assetID);
	}
#endif
#else
	if (_GlobalConfig.price > 0) {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,passport=%s,denom=%d,price=%d,coins=%d,paylevel=%d",
		_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum,_BCInfo.passport, GetDenomX(), _GlobalConfig.price, _creditsPerLine, GetPayLevel());
	} else {
		sprintf(buf,"progGroup=%1d,progLevel=%d,cardnum=%lld,passport=%s,denom=%d,lines=%d,coins=%d,paylevel=%d",
		_ExtendedConfig.SASGroup, plevel, _BCInfo.cardnum,_BCInfo.passport, GetDenomX(), _numberOfLinesBet, _creditsPerLine, GetPayLevel());
	}
#endif
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,cmd,buf);
	SetBingoWinCount(0);
}

void SendBingoPlay()
{
//#ifdef FPP
	//int plevel = _currentBetLevel;
	int plevel = GetProgLevel();
//#else
//	technically, plevel should be progressive level. But cnet parses it into levelIndex
//	For FPP and HPP, bet level happens to be the same as paylevel. For HPP, Cnet
//	uses levelIndex to map into bingo paytable	
//	int plevel = GetProgLevel();
//#endif
#ifndef PULLTAB
	SendBingoStartPlay("deal");
#else
	sprintf(buf,"progGroup=%1d,progLevel=%d,passport=%s,denom=%d,price=%d,coins=%d,paylevel=%d",
		_ExtendedConfig.SASGroup, plevel, _BCInfo.passport,
		_Denominations[_currentDenomination], _PTInfo[_currentBetLevel-1].price, _creditsPerLine, GetPayLevel());
	sendClass(_Socket,dest_addr,"pulltab",_TheEgmID,"dispense",buf);
	SetBingoWinCount(0);
#endif
	_GlobalMeters.GameInfoSent = 1;
	_saveMetersRequired = SDL_TRUE;
}

void SendBingoStart1()
{
	SendBingoStartPlay("start1");
}

void SendBingoStart2()
{
	SendBingoStartPlay("start2");
}

void SendBingoGetBalls()
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	_BCInfo.gamenumber = 0;
	sprintf(buf,"cardnum=%lld,passport=%s",_BCInfo.cardnum,_BCInfo.passport);
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"getballs",buf);
}

void SendBingoDaub()
{
#ifndef PULLTAB
#ifndef BINGOTEST 
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"gamenum=%lld,cardnum=%lld,passport=%s",_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport);
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"daub",buf);
#endif
#endif
}

void SendBingoClaim()
{
//#ifdef FPP
	int plevel = _currentBetLevel;
//#else
//	technically, plevel should be progressive level. But cnet parses it into levelIndex
//	For FPP and HPP, bet level happens to be the same as paylevel. For HPP, Cnet
//	uses levelIndex to map into bingo paytable	
//	int plevel = GetProgLevel();
//#endif
#ifndef PULLTAB
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	int bingoPrize = GetBingoPrize();
	int interimPrize = GetInterimPrize();
#if defined(ATRIB) || defined(ATRIB2)
	int mult = _GlobalConfig.price;
#else
	int mult = 1;
#endif
	int totalWin = bingoPrize + interimPrize * GetDenomX() * mult;
	//unsigned long long progWin = _GlobalMeters._ProgressiveWin;
	unsigned long long progWin = _LastProgWin4GameActivity;
	
	fprintf(_debugPort, "SendBingoClaim: %d, %d\n",_BCInfo.daubed, _BCInfo.claimed);
		//fprintf(_debugPort, "SendBingoClaim: bingoPrize=%d,interimPrize=%d,winamount=%d,ProgAmt=%lld\n",bingoPrize,interimPrize,totalWin,_GlobalMeters._ProgressiveWin);
	if ((_BCInfo.daubed == SDL_TRUE) && (_BCInfo.claimed == SDL_TRUE)) {
//		sprintf(buf,"gamenum=%lld,cardnum=%lld,passport=%s,winamount=%d,ProgAmt=%lld",_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport,totalWin,_GlobalMeters._ProgressiveWin);
		sprintf(buf,"gamenum=%lld,cardnum=%lld,passport=%s,winamount=%d,ProgAmt=%lld",_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport,totalWin,progWin);
		sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"claim",buf);
	} else {
		sprintf(buf,"progGroup=%1d,progLevel=%d,denom=%d,paylevel=%d,gamenum=%lld,cardnum=%lld,passport=%s,winamount=%d,ProgAmt=%lld",
			_ExtendedConfig.SASGroup, plevel, GetDenomX(), GetPayLevel(),
			_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport,totalWin,progWin);
		sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"slept",buf);
	}
#endif
}

void SendBingoGetWinAmts()
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"gamenum=%lld,cardnum=%lld,passport=%s",_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport);
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"getwinamt",buf);
}

#ifdef notdef
void SendBingoHistory(char *buffer)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"macaddr=%s,gamenum=%lld,cardnum=%lld,passport=%s,denom=%d,lines=%d,coins=%d,%s",
		macaddr,_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport,
  		GetDenomX(),_numberOfLinesBet,_creditsPerLine,buffer);
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"history",buf);
}
#endif

void SendBingoHistoryDetail(char *buffer)
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	char tbuf[32];
	char *multStr;
	int costPerPlay;

#ifdef PULLTAB
	costPerPlay = _PTInfo[_currentBetLevel - 1].price; 
#else
	if (_GlobalConfig.price) {
		sprintf(tbuf, "lines=%d,price", _numberOfLinesBet);
		multStr = tbuf;
		costPerPlay = _GlobalConfig.price;
	} else {
		multStr = "lines";
		costPerPlay = _numberOfLinesBet;
	}
#endif

#ifdef BINGOSAS
 #ifdef PULLTAB

	//fprintf(_debugPort, "SendBingoHistoryDetail(%s)\n", buffer);
	sprintf(buf,"macaddr=%s,gameid=%d,asset=%d,TimeStamp=%s, denom=%d,lines=%d,price=%d,coins=%d,%s",
		macaddr,_BCInfo.gameid,_GlobalConfig.assetID,getTimeStamp(),
  		GetDenomX(),_numberOfLinesBet,costPerPlay,_creditsPerLine,buffer);
	//fprintf(_debugPort, "SendBingoHistoryDetail(%s)\n", buf);
 #else
	sprintf(buf,"macaddr=%s,gamenum=%lld,cardnum=%lld,asset=%d,TimeStamp=%s, denom=%d,%s=%d,coins=%d,%s",
		macaddr,_BCInfo.gamenumber,_BCInfo.cardnum,_GlobalConfig.assetID,getTimeStamp(),
  		GetDenomX(), multStr, costPerPlay,_creditsPerLine,buffer);
 #endif
#else	
 #ifdef PULLTAB
	sprintf(buf,"macaddr=%s,gameid=%d,passport=%s,TimeStamp=%s, denom=%d,lines=%d,price=%d,coins=%d,%s",
		macaddr,_BCInfo.gameid,_BCInfo.passport,getTimeStamp(),
  		_Denominations[_currentDenomination],_numberOfLinesBet,costPerPlay,_creditsPerLine,buffer);
 #else	
	sprintf(buf,"macaddr=%s,gamenum=%lld,cardnum=%lld,passport=%s,TimeStamp=%s, denom=%d,%s=%d,coins=%d,%s",
		macaddr,_BCInfo.gamenumber,_BCInfo.cardnum,_BCInfo.passport,getTimeStamp(),
  		GetDenomX(), multStr, costPerPlay,_creditsPerLine,buffer);
 #endif
#endif
	sendClass(_Socket,dest_addr,gameStr,_TheEgmID,"history",buf);
	SetWaiting4HistoryAck();
	strcpy(lastGameHist,buf);
	SaveHistoryBuf();
	LastHistoryTime = SDL_GetTicks();		// save for timeout
	_saveMetersRequired = SDL_TRUE;
}

void SendBingoLogoff()
{
	fprintf(_debugPort, "SendBingoLogoff() \n");
#if defined(FAKECARDBASED)
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
	sprintf(buf,"macaddr=%s,passport=%s,balance=%lld",macaddr,_BCInfo.passport,_CurrentPlayerAccount);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"logoff",buf);
	return;
#else

#ifdef VICTORYLAND	// card based games only
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
#ifndef DO_TITO
	SetLastLoginStatus("Logging Off", "");
#endif
	if (bonusInfo.waiting4GAack) {
		return;			// don't log off until history and activity went out
	}
	//if (_BCInfo.serialnum == 0) _BCInfo.serialnum = 2222;
	sprintf(buf,"macaddr=%s,passport=%s,balance=%lld",macaddr,_BCInfo.passport,_CurrentPlayerAccount-_GlobalMeters.OOS_handpay_adjust);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"logoff",buf);
	ClearBingoDisconnectState();
#ifndef LOADTEST
	_logOffAfterGameFlag = SDL_FALSE;
#else
	if (doAutoPlay == 1) {
	  _logOffAfterGameFlag = SDL_FALSE;
	}
#endif
	_saveMetersRequired = SDL_TRUE;
#ifdef notdef3
    _BCInfo.serialnum = 0;
    _CurrentPlayerAccount = 0;
    _PlayerAccount = 0;
    _GlobalMeters.PlayerAccount = 0;
    _saveMetersRequired = 0;
    ButtonSetState(MSBTN_PRINT,MSBTN_ON);		// this is to allow us to enter config
#endif
#endif
#endif
}

void SendForceBingoLogoff(char *passport)
{
#ifdef VICTORYLAND				// card based games only
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	//if (_BCInfo.serialnum == 0) _BCInfo.serialnum = 2222;
	sprintf(buf,"macaddr=%s,passport=%s,balance=%lld",macaddr,passport,0);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"logoff",buf);
	ClearBingoDisconnectState();
	_logOffAfterGameFlag = SDL_FALSE;
	_saveMetersRequired = SDL_TRUE;
#endif
}

void SendBingoCancelPlay()
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	char tbuf[32];
	char *multStr;
	int costPerPlay;

#ifdef PULLTAB
		sprintf(tbuf, "lines=%d,price", _numberOfLinesBet);
		multStr = tbuf;
	costPerPlay = _PTInfo[_currentBetLevel - 1].price; 
#else
	if (_GlobalConfig.price) {
		sprintf(tbuf, "lines=%d,price", _numberOfLinesBet);
		multStr = tbuf;
		costPerPlay = _GlobalConfig.price;
	} else {
		multStr = "lines";
		costPerPlay = _numberOfLinesBet;
	}
#endif
	
	sprintf(buf,"cardnum=%lld,passport=%s,denom=%d,%s=%d,coins=%d,paylevel=%d",_BCInfo.cardnum,_BCInfo.passport,
		GetDenomX(), multStr, costPerPlay,_creditsPerLine,GetPayLevel());
#ifdef PULLTAB
	sendClass(_Socket,dest_addr,gameStr,_TheEgmID,"canceldispense",buf);
#else
	sendClass(_Socket,dest_addr,"bingo",_TheEgmID,"canceldeal",buf);
#endif
	_GlobalMeters.GameInfoSent = 0;
	_saveMetersRequired = SDL_TRUE;
}

void SendBingoReconnect()
{
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"macaddr=%s,passport=%s,pin=%s",macaddr,_BCInfo.passport,_BCInfo.pin);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"reconnect",buf);
}

void SendBingoRegister()
{
#ifndef LOADTEST
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"title=%s,asset=%d,regid=0001", _ProductId, _GlobalConfig.assetID);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"register",buf);
#endif
}

void SendBingoUnRegister()
{
#ifndef LOADTEST
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"asset=%d,regid=0001", _GlobalConfig.assetID);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"regclearasset",buf);
#endif
}

void SendBingoGetPin()
{
#ifdef CASHPLAY
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();
	
	sprintf(buf,"macaddr=%s,",macaddr);
	sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"getnewpin",buf);
	lastGetNewPinTime = SDL_GetTicks();
#endif
}


#endif	//BINGO

#ifndef LOADTEST
extern int GetEventCode(int evType, char *subev);
extern unsigned long long GetNextEventNum(void);
void SendEventLog(int evType, char *subev, char *ts, int eventCode, unsigned long long eventNum)
{
//#ifdef notdef
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
        //char *ts=getTimeStamp();

	fprintf(_debugPort, "SendEventLog(%d,%s,%s,%d,%lld)\n", evType, subev, ts, eventCode, eventNum);
	EQElem.eventCode = eventCode;
	strcpy(EQElem.evText, subev);
	strcpy(EQElem.evTime, ts);
	EQElem.eventNum = eventNum; 	//GetNextEventNum();

	if (AddEventQ(&EQ, &EQElem) == 2) {	
		sprintf(buf,"asset=%d,eventcode=%d,eventtext=%s,eventtime=%s,eventnum=%16lld",_GlobalConfig.assetID, eventCode, subev, ts, eventNum + (_GlobalConfig.assetID * 10000000000ull));
		sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"eventlog",buf);
		lastEventTime = SDL_GetTicks();
	}
//#endif
}
#endif

void ResendEvent()
{
#ifndef LOADTEST
//#ifdef notdef
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];

	if (GetEventQ(&EQ, &EQElem, 0, 0ll) == 1) {		// read next event from queue
		sprintf(buf,"asset=%d,eventcode=%d,eventtext=%s,eventtime=%s,eventnum=%16lld",_GlobalConfig.assetID, EQElem.eventCode, EQElem.evText, EQElem.evTime, EQElem.eventNum + (_GlobalConfig.assetID * 10000000000ull));
		sendClass(_Socket,dest_addr,acctStr,_TheEgmID,"eventlog",buf);
		lastEventTime = SDL_GetTicks();
	}
//#endif
#endif
}


void processProgressiveClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
//			setProgressiveValue 	No response required. 
//			getProgressiveStatus 	progressiveStatus
//			setDeviceState 		progressiveStatus
//			setLockOut 		progressiveStatus 
//			getProgressiveLogStatus 	progressiveLogStatus 
//			getProgressiveLog 		progressiveLogList
#ifdef notdef
        fprintf(_debugPort,"processProgressiveClass[%d]: egmclass->Command=%s,egmclas->Data=%s\n",_JackPotType, egmclass->Command,egmclass->Data);
#endif
	
        if ((strcmp(egmclass->Command,"setProgressiveValue")==0) || (strcmp(egmclass->Command,"progressiveHitack")==0))
        {
                int Pgrp=0;
                unsigned long long Pamts[5] = {0,0,0,0,0};
                int i,dlevel,ii,iii;
                //int levj;
		DATA_PAIRS ProgDatapairs[]={
                    {"ProgGroup",""},
                    {"Denom",""},
                    {"S01amt",""},
                    {"S02amt",""},
                    {"S03amt",""},
                    {"S04amt",""},
                    {"S05amt",""}
        	};
        	int count=7;
		int level,levj;
                
		if (strcmp(egmclass->Command, "progressiveHitack") == 0) {
			LastProgHitTime = 0;
			bonusInfo.waiting4ProgHitAck = 0;
			fprintf(_debugPort, "progressiveHitack\n");
			_saveMetersRequired = SDL_TRUE;
#ifdef BINGO
			if (_JackPotType == JP_BONUS) return;
#endif
		}
                extractDataPairs(egmclass->Data,ProgDatapairs,count);
                if (strlen(ProgDatapairs[0].data)>0)
                        sscanf(ProgDatapairs[0].data,"%d",&Pgrp);

#ifdef notdef2
                fprintf(_debugPort,"\nsetProgressiveValue received Pgrp=%d ProgControllerType=%x SASGroup=%x",Pgrp,
                                _ExtendedConfig.ProgControllerType,_ExtendedConfig.SASGroup);
#endif

                if (_ExtendedConfig.ProgControllerType != 1)   // we are not controlled by SAS so take over
                {
                        if (_ExtendedConfig.SASGroup && (_ExtendedConfig.SASGroup == Pgrp))     // if it matches our SAS Group number...
                        {
                                
                                dlevel=0;
                                if (strlen(ProgDatapairs[1].data)>0)
                                        sscanf(ProgDatapairs[1].data,"%d",&dlevel);
#ifdef notdef2
                                fprintf(_debugPort,"dlevel=%d _dToLevel[%d]=%d",dlevel,dlevel,_dToLevel[dlevel]);
#endif

                                for (i=2; i<=6; i++) {
                                        if ((dlevel > 0) && (dlevel < 6) && (strlen(ProgDatapairs[i].data)>0)) 
                                                sscanf(ProgDatapairs[i].data,"%lld",&Pamts[i-2]);
                                }
#ifdef notdef2
                                fprintf(_debugPort,"%lld %lld %lld %lld %lld\n",Pamts[0],Pamts[1],Pamts[2],Pamts[3],Pamts[4]);
#endif
                                // get 1st index into CNjackportValues[][]
#ifdef notdef
                                for (iii=0; iii<9; iii++) 
                                        if (_dToLevel[dlevel] == _Denominations[iii]) 
                                                break;
#endif
				
#ifdef notdef
                                fprintf(_debugPort,"iii=%d\n",iii);
#endif
                                for (ii=0; ii<5; ii++) {
					//if (ii == 0) CNjackpotValues[iii][ii+1] = 0;	//DEBUG only
					//else	//DEBUG only
                                        if (Pamts[ii] > 0) {
                                                CNjackpotValues[dlevel][ii+1] = Pamts[ii]*100;
                                                if (_ExtendedConfig.ProgControllerType == 0) {
                                                        _ExtendedConfig.ProgControllerType = 2;
                                                        _saveConfigRequired = SDL_TRUE;
                                                }
                                        }
                                }
                                if (_progressiveValueReceived == SDL_FALSE) {
                                        progrcvd[dlevel-1] = 1;
                                        for (i=0; i<_numDenomLevels; i++) {
                                                if (progrcvd[i] == 0)
                                                        break;
                                        }
#ifdef notdef2
					fprintf(_debugPort, "_progressiveValueReceived == SDL_FALSE, dlevel=%d, _numDenomLevels=%d, i=%d\n", dlevel, _numDenomLevels, i);
#endif
                                        if (i == _numDenomLevels)  {
						//if (serverConfigError == 0) {
						if ((serverConfigError & ~JACKPOTYPE_ERR) == 0){
							char buf[256];
                                                	_progressiveValueReceived = SDL_TRUE;
#ifdef notdef2
							fprintf(_debugPort, "_progressiveValueReceived = TRUE\n");
#endif
							if (_GEPamtReceived == SDL_FALSE) {
								SendKeepAlive(destAddr);
#ifdef notdef1
                                				fprintf(_debugPort,"ka3 sent\n");
#endif
							}
						}
#ifdef notdef
                                                fprintf(_debugPort,"values rcvd:_numDenomLevels=%d %d %d %d %d %d\n",_numDenomLevels,
                                                        progrcvd[0],progrcvd[1],progrcvd[2],progrcvd[3],progrcvd[4]);
						
						for (ii=0; ii<6; ii++) {
							fprintf(_debugPort, "CNjackpotValues[%d]:%lld,%lld,%lld,%lld,%lld,%lld\n",
									ii,CNjackpotValues[ii][0],CNjackpotValues[ii][1],CNjackpotValues[ii][2],
	 								CNjackpotValues[ii][3],CNjackpotValues[ii][4],CNjackpotValues[ii][5]);
						}
#endif
                                        }
                                }                
                        }
                }
		
#ifdef BINGO
                //if (strcmp(egmclass->Command,"progressiveHitack")==0) {
	        //       	_GlobalMeters._ProgressiveWin = (CNjackpotValues[_currentDenomination+1][_currentBetLevel] / 100);
    		//	SendBingoClaim();
		//} 
		//else 
#endif
		{
		     //if (_progressiveValueReceived == SDL_TRUE)  {         //send the ack
                      sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressive",ProgDatapairs[1].data);   //DenomLevel
		}
                      //fprintf(_debugPort,"pa sent\n");
                //}
        }

        else if(strcmp(egmclass->Command,"getProgressiveStatus")==0)
        {
                //printf("cabinet : getProgressiveStatus received\n");
                sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressiveStatus","hostEnabled=true,egmEnabled=true,lockedOut=false,paytableIndex=1,progValue=9876");
        }
#ifndef BINGO
	else  if (strcmp(egmclass->Command, "gameinfoack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"gameid",""},
			{"progwin", ""},
			{"status", ""},
			{"vnetts", ""},
		};
		int count=4;
		unsigned long long progAmt = 0;
		unsigned long gameid = 0;

		if ((_JackPotType == JP_BONUS) && ((_GlobalMeters.GameInfoSent == 1) || (_gameState == GS_RUNREELS))) {
			extractDataPairsDelim(egmclass->Data,datapairs,count,':');
			sscanf(datapairs[0].data, "%ld",&gameid);
			if (_GlobalMeters.gameid == gameid) {
				_GlobalMeters.GameInfoSent = 2;
				if (strlen(datapairs[1].data) > 0)
					sscanf(datapairs[1].data, "%ld", &progAmt);
				_GlobalMeters._ProgressiveWin = progAmt;
				_GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
				//fprintf(_debugPort, "gameinfoack: progAmt=%lld\n", progAmt);
				if (progAmt > 0) {
#ifdef LOADTEST
					fprintf(_debugPort, "[0] JACKPOT\n");
#endif
					SendProgHitInfo(_GlobalMeters._ProgressiveWin);
					SetSentProgHitInfo();
				}
			} else {
#ifndef PRODUCTION
				fprintf(_debugPort, "last gameid=%d, gameid=%d\n",_GlobalMeters.gameid, gameid);
#endif
			}
			//_BCInfo.gameid = gameid;
			_saveMetersRequired = SDL_TRUE;
		}
	}
	else  if (strcmp(egmclass->Command, "gameinfonack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"gameid",""},
			{"progwin", ""},
			{"status", ""},
			{"vnetts", ""},
		};
		int count=4;
		unsigned long long progAmt = 0;
		unsigned long long gameid;

		if ((_JackPotType == JP_BONUS) && ((_GlobalMeters.GameInfoSent == 1) || (_gameState == GS_RUNREELS))) {
			extractDataPairsDelim(egmclass->Data,datapairs,count,':');
			sscanf(datapairs[0].data, "%lld",&gameid);
			if (_GlobalMeters.gameid == gameid) {
				_GlobalMeters.GameInfoSent = 2;
				if (strlen(datapairs[1].data) > 0)
					sscanf(datapairs[1].data, "%lld", &progAmt);
				_GlobalMeters._ProgressiveWin = progAmt;
				_GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
				fprintf(_debugPort, "gameinfonack: progAmt=%lld\n", progAmt);
			} else {
#ifndef PRODUCTION
				fprintf(_debugPort, "last gameid=%d, gameid=%d\n",_GlobalMeters.gameid, gameid);
#endif
			}
			//_BCInfo.gameid = gameid;
			_saveMetersRequired = SDL_TRUE;
		}
	}
#endif
	else if ( ( (_JackPotType == JP_GAMEBASED) && (strcmp(egmclass->Command,"setProgressiveDenoms") == 0)) || ((_JackPotType == JP_BONUS) && (strcmp(egmclass->Command,"setGameDenoms") == 0)))
	{
                int Pgrp=0;
                unsigned long newDenoms[5] = {0,0,0,0,0};
		unsigned long newCoinsBet[5] = {0,0,0,0,0};
		unsigned long newLines[10] = {0,0,0,0,0,0,0,0,0,0};
		unsigned long newPay[5] = {0,0,0,0,0};
		int _newMaxBetLevel = 0;
		int _newLevelToNumCoins[5] = {0,0,0,0,0};;
		int newPercent[5]={0,0,0,0,0};
		int newJackpots[5]={0,0,0,0,0};
		int newBonus=0;
                int i,dlevel,ii,iii;
		DATA_PAIRS ProgDatapairs[]={
			{"ProgGroup",""},		//0
			{"S01level",""},		//1
			{"S02level",""},
			{"S03level",""},
			{"S04level",""},
			{"S05level",""},
			{"S01denom",""},		//6
			{"S02denom",""},
			{"S03denom",""},
			{"S04denom",""},
			{"S05denom",""},
			{"S01line",""},			//11
			{"S02line",""},
			{"S03line",""},
			{"S04line",""},
			{"S05line",""},
			{"S11qual",""},			//16
			{"S12qual",""},
			{"S13qual",""},
			{"S14qual",""},
			{"S15qual",""},
			{"S21qual",""},			//21
			{"S22qual",""},
			{"S23qual",""},
			{"S24qual",""},
			{"S25qual",""},
			{"S31qual",""},			//26
			{"S32qual",""},
			{"S33qual",""},
			{"S34qual",""},
			{"S35qual",""},
			{"S41qual",""},			//31
			{"S42qual",""},
			{"S43qual",""},
			{"S44qual",""},
			{"S45qual",""},
 			{"S51qual",""},			//36
			{"S52qual",""},
			{"S53qual",""},
			{"S54qual",""},
			{"S55qual",""},
			{"Payout1",""},			//41
			{"Payout2",""},
			{"Payout3",""},
			{"Payout4",""},
			{"Payout5",""},
			{"Paylevel1",""},		//46
			{"Paylevel2",""},
			{"Paylevel3",""},
			{"Paylevel4",""},
			{"Paylevel5",""},
			{"price",""},			//51
 
        	};
#define PAYOUT_ENTRY	41
#define PAYLEVEL_ENTRY	46
#define	PRICE_ENTRY	51
		int count=16+25+5+5+1;
		int price=0;
		
        	//fprintf(_debugPort,"processProgressiveClass: egmclass->Command=%s,egmclas->Data=%s\n",egmclass->Command,egmclass->Data);
		//fprintf(_debugPort, "b4 extractDataPairs\n");
                extractDataPairs(egmclass->Data,ProgDatapairs,count);
		//for (i=0; i<count; i++) {
		//	fprintf(_debugPort, "[%d]%s:%s\n",i,ProgDatapairs[i].key, ProgDatapairs[i].data);
		//}
		//fprintf(_debugPort, "1\n");
                if (strlen(ProgDatapairs[0].data)>0)
                        sscanf(ProgDatapairs[0].data,"%d",&Pgrp);

		if (strlen(ProgDatapairs[PRICE_ENTRY].data) > 0) {
			sscanf(ProgDatapairs[PRICE_ENTRY].data, "%d", &price);
		} else	price = _GlobalConfig.price;

#ifndef BINGO
		_maxPayLevel = 0;
#endif
		for (i=0; i<5; i++) {
#ifdef BINGO
			//fprintf(_debugPort, "[%d]%s:%s\n",PAYLEVEL_ENTRY+i,ProgDatapairs[PAYLEVEL_ENTRY+i].key, ProgDatapairs[PAYLEVEL_ENTRY+i].data);
			if (strlen(ProgDatapairs[PAYLEVEL_ENTRY+i].data) > 0) { 	// Payout
				sscanf(ProgDatapairs[PAYLEVEL_ENTRY+i].data, "%d", &newPay[i]);
				//fprintf(_debugPort, "newPay[%d]=%d\n",i,newPay[i]);
			}
			if (newPay[i] >= 0) 
			{					// Payout
				sscanf(ProgDatapairs[PAYLEVEL_ENTRY+i].data, "%d", &newPay[i]);
				// newPay[i] should correspond to one of the levels in paylevelvalues
				// for now, 0=90%, 1=92%, 2=94%, and 3=95.01%
				newPercent[i] = newPay[i] & 0x0f;
				if (newPercent[i] == -1) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPercent error\n");
					return;
				}
 #ifndef PULLTAB
				_BCInfo.payLevel[i] = newPercent[i];
 #else
 				_BCInfo.payLevel[i] = i;
 #endif
				{
				  int dlev, llev;
				  for (dlev=0; dlev<5; dlev++) {
				    for (llev=0; llev<5; llev++) {
				      _PayLevels[dlev][llev][i] = _BCInfo.payLevel[i];
				    }
				  }
				}
				fprintf(_debugPort, "_BCInfo.payLevel[%d]=%d\n",i,_BCInfo.payLevel[i]);
				//fprintf(_debugPort, "newPercent[%d]=%d\n",i,newPercent[i]);
#else // not BINGO
			if (strlen(ProgDatapairs[PAYOUT_ENTRY+i].data) > 0) 	// Payout
				sscanf(ProgDatapairs[PAYOUT_ENTRY+i].data, "%d", &newPay[i]);
			if (newPay[i] >= 0) {					// Payout
				int j;
				int dupPay = 0;
				sscanf(ProgDatapairs[PAYOUT_ENTRY+i].data, "%d", &newPay[i]);
				if (i==0) {
				} else for (j=0; j<i; j++) {
					if (newPay[j] == newPay[i]) {
						dupPay = 1;
						break;
					}
				}
				
				if (dupPay == 0) _maxPayLevel++;
				newJackpots[i] = (newPay[i] >> 4) & 0x0f;
				//fprintf(_debugPort, "Pay percentage[%d] = %d, num=%d\n", i, newPay[i]&7, newJackpots[i]);
				// we don't have all the pay tables yet. Only 92% 1-7 jackpots and 94% 1-7 jackpots
				switch (newPay[i] & 0x0f) {
				case 0:			//88%	no bonus
					newPercent[i] = 88;
					newBonus &= ~(1<<i);
					break;
				case 2:			//90%	no bonus
					newPercent[i] = 90;
					newBonus &= ~(1<<i);
					break;
				case 3:			//91%
					newPercent[i] = 91;
					newBonus &= ~(1<<i);
					break;
				case 4:			//92%
					newPercent[i] = 92;
					if (newPay[i] & 0x100)
						newBonus |= (1<<i);
					else
						newBonus &= ~(1<<i);
					break;
 #ifdef MAMBOSKIN
				case 5:			//93%
					newPercent[i] = 93;
					newBonus |= (1<<i);
					break;
				case 7:			//95%
					newPercent[i] = 95;
					newBonus |= (1<<i);
					break;
 #endif
				case 6:			//94%
					newPercent[i] = 94;
					newBonus |= (1<<i);
					break;
				case 1:			//89%
 #ifndef MAMBOSKIN
				case 5:			//93%
				case 7:			//95%
					
 #endif
				default:
					newPercent[i] = -1;
					break;
				}
 #ifndef MAMBOSKIN
				if (newPercent[i] != -1) {
					if ((newJackpots[i] < 1) || (newJackpots[i] > 7))
						newPercent[i] = -1;
				}
 #endif
 #ifndef MEXICO
				if (newPercent[i] == -1) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPercent error\n");
					return;
				}
 #endif
#endif //BINGO
			}
		}
		

	  if (_JackPotType == JP_GAMEBASED) {
		for (i=16; i<PAYOUT_ENTRY; i++) {
			if (strlen(ProgDatapairs[i].data) > 0) {
				ii = ProgDatapairs[i].key[1] - '1';
				iii = ProgDatapairs[i].key[2] - '1';
				if (iii == 0) {
					sscanf(ProgDatapairs[i].data, "%d", &_minJPqualifier[ii]);
					//fprintf(_debugPort, "%d:%d min qual = %d\n", ii, iii, _minJPqualifier[ii]);
				}
			}
		}
	  }
#ifndef PRODUCTION
 #ifndef PULLTAB
		// PullTab min qualifier is 25. This is only for developement, when switching between Bingo and PullTab
		//if (_JackPotType == JP_GAMEBASED && _minJPqualifier[0] == 25)
		//	_minJPqualifier[0] = 20;
 #endif
#endif
		//fprintf(_debugPort, "2\n");
#ifdef notdef2
                fprintf(_debugPort,"\nsetProgressiveDenoms received Pgrp=%d ProgControllerType=%x SASGroup=%x",Pgrp,
                                _ExtendedConfig.ProgControllerType,_ExtendedConfig.SASGroup);
#endif

                if (_ExtendedConfig.ProgControllerType != 1)   // we are not controlled by SAS so take over
                {
			//serverConfigError = 0;			// clear error
			serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
			
			//fprintf(_debugPort, "_ExtendedConfig.SASGroup=%d, Pgrp=%d\n",_ExtendedConfig.SASGroup, Pgrp);
                        if (_ExtendedConfig.SASGroup && (_ExtendedConfig.SASGroup == Pgrp))     // if it matches our SAS Group number...
                        {
                                
                                for (i=1; i<=5; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newCoinsBet[i-1]);
                                }
				//sort(&newCoinsBet[0],5);
#if defined(ATRIB)
				// P7 only has 3 bet levels
				newCoinsBet[3] = 0;
				newCoinsBet[4] = 0;
#endif
#ifdef notdef2
                                fprintf(_debugPort,"CoinsBet %ld %ld %ld %ld %ld\n",newCoinsBet[0],newCoinsBet[1],newCoinsBet[2],newCoinsBet[3],newCoinsBet[4]);
#endif
                                for (i=6; i<=10; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newDenoms[i-6]);
                                }
				//sort(&newDenoms[0], 5);
#ifdef notdef2
                                fprintf(_debugPort,"Denoms %ld %ld %ld %ld %ld\n",newDenoms[0],newDenoms[1],newDenoms[2],newDenoms[3],newDenoms[4]);
				
#endif
                                for (i=11; i<=15; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newLines[i-11]);
#ifdef FAKING_40LINES
						newLines[i-11] = 40;
#endif
#ifdef MLSKIN
						newLines[i-11] = 30;
#endif
                                }
				//sort(&newLines[0], 10);
#ifdef notdef2
                                fprintf(_debugPort,"LinesBet %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\n",
					newLines[0],newLines[1],newLines[2],newLines[3],newLines[4],
				        newLines[5],newLines[6],newLines[7],newLines[8],newLines[9]);
				
#endif
			}
			// make sure valid coins bet
			for (i=0; i<5; i++) {
				if (newCoinsBet[i] > MAXCREDITSPERLINE) {
#ifdef notdef2
					fprintf(_debugPort, "newCoinsBet[%d]=%d\n",i,newCoinsBet[i]);
#endif
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= COINS_ERR;							
					_progressiveValueReceived = SDL_FALSE;
					return;
				}
			}
			// make sure valie lines bet for this game
			for (i=0; i<10; i++) {
				if (newLines[i] > 0) {
					iii = -1;
					for (ii=0; ii<5; ii++) {
						if (availLinesBet[ii] == newLines[i])
							iii = ii;
					}
					if (iii == -1) {
						processBadClass(sockfd, destAddr, egmclass);
						serverConfigError |= LINES_ERR;
						_progressiveValueReceived = SDL_FALSE;
						return;
					}
						
				}
			}
			
			// make sure valid denoms
#ifdef notdef2
			fprintf(_debugPort, "_ExtendedConfig.denominations[0]=%d\n",_ExtendedConfig.denominations[0]);
#endif
			//if (_ExtendedConfig.denominations[0] == 0) {			// 1st time from server
			if (_NeedServerConfig == 1) {	// 1st time from server
				_GlobalConfig.price = price;
				_numDenomLevels = 0;
				for (i=0; i<NUM_DENOMS; i++) {
					_Denominations[i] = (_ExtendedConfig.denominations[i] = newDenoms[i]);
					if (_Denominations[i] > 0) {
						_ExtendedConfig.Denoms[i] = SDL_TRUE;
						_numDenomLevels++;
					} else
						_ExtendedConfig.Denoms[i] = SDL_FALSE;
				}
#ifdef notdef2
				fprintf(_debugPort, "_numDenomLevels = %d\n",_numDenomLevels);
#endif
				for (i=0; i<MAX_COINS_PER_LINE; i++) {
					_GlobalConfig.betsPerLine[i] = 0;
				}
				_maxBetLevel = 0;
				for (i=0; i<5; i++) {
					if (newCoinsBet[i] > 0) {
						++_maxBetLevel;
						_GlobalConfig.betsPerLine[newCoinsBet[i]-1] = 1;
						_LevelToNumCoins[_maxBetLevel]  = newCoinsBet[i];
					}
				}
			
				for (i=0; i<5; i++) {
					if (_creditsPerLine == newCoinsBet[i])
						break;
				}	
				if ((i==5) || (_currentBetLevel != (i+1))) {
					_creditsPerLine = newCoinsBet[0];
					_currentBetLevel = 1;
					_GlobalMeters.LastCreditsPerLine = _creditsPerLine;
				}
				// set up number of lines bet
#ifdef notdef2
				fprintf(_debugPort, "setting up validBetLines\n");
#endif
				_GlobalConfig.validBetLines = 0;
				for (i=0; i<5; i++) {
					if (newLines[i] > 0) {
						for (ii=0; ii<5; ii++) {
							if (availLinesBet[ii] == newLines[i])
								_GlobalConfig.validBetLines |= 1 << ii;
						}		
					}
				}
#ifdef notdef2
				fprintf(_debugPort, "Have valid lines bet %d?\n", _numberOfLinesBet);
#endif
				for (i=0; i<5; i++) {
					if (_numberOfLinesBet == newLines[i]) {
						break;
					}
				}
				if (i==5) _numberOfLinesBet = newLines[0];
#ifdef notdef2
				fprintf(_debugPort, "_numberOfLinesBet=%d\n",_numberOfLinesBet);
#endif
#ifdef notdef
				for (i=0; i<NUM_DENOMS; i++) {
					_ExtendedConfig.Denoms[i] = SDL_FALSE;
					if (newDenoms[i] > 0) {
						for (ii=0; ii<5; ii++) {
							if (newDenoms[ii] == _Denominations[i]) {
								//fprintf(_debugPort, "setting _Denominations[%d] %d %d to true\n",
								//		i, _Denominations[i], _ExtendedConfig.denominations[i]);
								_ExtendedConfig.Denoms[i] = SDL_TRUE;
							}
						}
					}
				}
#endif
#ifdef BINGO
				// set up pay table and number of jackpots
				for (i=0; i<5; i++) {
					//if (newPay[i] > 0) 
					{
						//_GlobalConfig.payPercent[i] = newPercent[i];
 #ifndef ZEUSKLUDGE
  #ifndef PULLTAB
						_BCInfo.payLevel[i] = newPercent[i];
  #else
						_BCInfo.payLevel[i] = i;
  #endif
 #endif
						//fprintf(_debugPort, "_BCInfo.payLevel[%d]=%d\n",i,newPercent[i]);
					}
				}
#else
				// set up pay table and number of jackpots
//#ifndef MAMBOSKIN
				for (i=0; i<5; i++) {
					if (newPay[i] > 0) {
 #ifdef notdef2
						fprintf(_debugPort, "newPay[%d]=%d\n",i, newPercent[i]);
 #endif
						_GlobalConfig.payPercent[i] = newPercent[i];
						_GlobalConfig.numJackpots[i] = newJackpots[i];
					}
				}
//#endif
				_GlobalConfig.bonusFlag = newBonus;
 #ifdef notdef2
				fprintf(_debugPort, "got newPay\n");
 #endif
				JackpotInfoReInit();
 #ifdef notdef2
				fprintf(_debugPort, "after JackpotInfoReInit\n");
 #endif
				InitReelStrips();
 #ifdef notdef2
				fprintf(_debugPort, "after InitReelStrips\n");
 #endif
#endif
                		_saveConfigRequired = SDL_TRUE;
				need2Send3C = SDL_TRUE;
#ifdef VICTORYLAND
				FlashEvent(3, "Initial setup", EV_CF_CHNG);
				fprintf(_debugPort, "b4 SendBingoUnRegister()\n");
				SendBingoUnRegister();
				fprintf(_debugPort, "b4 SendBingoRegister()\n");
				SendBingoRegister();
#endif
				
			} else {
				for (i=0; i<5; i++) {
					iii = -1;
					if (newDenoms[i] > 0) {
						for (ii=0; ii<NUM_DENOMS; ii++) {
							if (newDenoms[i] == _Denominations[ii]) {
								if (_ExtendedConfig.Denoms[ii] == SDL_TRUE) {
									iii = ii;
								}
							}
						}
						if (iii == -1) {
							//fprintf(_debugPort, "newDenoms[%d]=%d\n",i,newDenoms[i]);
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= DENOM_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							fprintf(_debugPort, "denom error\n");
							return;
						}
					} else if (_ExtendedConfig.Denoms[i] == SDL_TRUE) {	// denom is enabled, but server not sending it
						// server changed denoms. Not allowed.
						processBadClass(sockfd,destAddr,egmclass);
						serverConfigError |= DENOM_ERR;
						_progressiveValueReceived = SDL_FALSE;
						return;
					}
				}
				
				// make sure coins bet per line didn't change from last nvram clear
				_newMaxBetLevel = 0;
				for (i=0; i<5; i++) {
					if (newCoinsBet[i] > 0) {
						++_newMaxBetLevel;
						
						//_GlobalConfig.betsPerLine[newCoinsBet[i]-1] = 1;
						_newLevelToNumCoins[_newMaxBetLevel]  = newCoinsBet[i];
						if (_newLevelToNumCoins[i] != _LevelToNumCoins[i]) {
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= COINS_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							fprintf(_debugPort, "coins bet error\n");
						}
					}
				}
				if (_newMaxBetLevel != _maxBetLevel) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= COINS_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "coins bet error\n");
				}
//#ifndef MAMBOSKIN
 #ifndef MEXICO
  #ifndef BINGOSAS
				for (i=0; i<5; i++) {
					if (newPay[i] > 0) {
   #ifdef MAMBOSKIN
    #ifdef BINGO
     #ifndef PULLTAB
						if (_BCInfo.payLevel[i] != newPercent[i])
     #else
						if (_BCInfo.payLevel[i] != i)
     #endif
    #else
						if (_GlobalConfig.payPercent[i] != newPercent[i])
    #endif
   #else
    #ifdef BINGO
     #ifndef PULLTAB
						if (_BCInfo.payLevel[i] != newPercent[i])
     #else
						if (_BCInfo.payLevel[i] != i)
     #endif
    #else
						if ((_GlobalConfig.payPercent[i] != newPercent[i]) ||
								(_GlobalConfig.numJackpots[i] != newJackpots[i]))
    #endif
   #endif
						{
							fprintf(_debugPort, "newPay error\n");
							fprintf(_debugPort, "level %d _GlobalConfig.payPercent=%d, newPercent=%d\n", i,  _GlobalConfig.payPercent[i], newPercent[i]);
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= PAY_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							return;
						}
					}
				}
  #endif
				
  #ifndef BINGO
   #ifdef NEWMATH
				if (_GlobalConfig.bonusFlag != newBonus) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newBonus error\n");
					return;
				}
   #endif
  #endif
 #endif
//#endif
 #ifdef BINGO
				if (_GlobalConfig.price != price) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PRICE_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPrice error\n");
					return;
				}
 #endif
			}
			
		}
                      
                for (i=0; i<5; i++) 
		{
			int dlev, llev;
			for (dlev=0; dlev<_numDenomLevels; dlev++) {
				for (llev=0; llev<5; llev++) {
					if (i >= _maxBetLevel) {
					  _PayLevels[dlev][llev][i] = 0;
					} 
					else
					{
#ifdef BINGO
					  _PayLevels[dlev][llev][i] = i;
#else
					  _PayLevels[dlev][llev][i] = newPercent[i];
#endif
					}
				}
			}
		}

		sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressive",ProgDatapairs[1].data);   //DenomLevel
		for (i=0; i<6; i++)
			_dToLevel[i] = 0;	// make sure it is cleared
		for (i=NUM_DENOMS-1,ii=0; i>=0; i--) {
			if (_ExtendedConfig.Denoms[i] == SDL_TRUE) {
				ii++;
				_dToLevel[ii]=_Denominations[i];
#ifdef notdef
				fprintf(_debugPort,"_denomToLevel[%d]=%d\n",ii, _dToLevel[ii]  );
#endif
			}
		}
		//if (_GlobalConfig.PayRangeFlag > 0) 
		{
			// _numDenomLevels is number of active denoms
			// _maxBetLevel is number of coins bet level
			for (i=0; i<_numDenomLevels; i++) {
			      int llev; //line level (carnival Lotto is always 1-4 cards
			      int clev;	// coins bet level
			      int p1 = price;
#ifdef ATRIB2
			      if (p1 == 0) p1 = 9;
#endif
			      for (llev=0; llev<1; llev++) {
					for (clev=0; clev<_maxBetLevel; clev++) {
						_TotalBet[i][llev][clev] = newDenoms[i]*(p1)*newCoinsBet[clev];
					}
					//fprintf(_debugPort, "_TotalBet[%1d][%1d] = %d,%d,%d,%d,%d\n",
					//	i, llev, _TotalBet[i][llev][0],_TotalBet[i][llev][1],_TotalBet[i][llev][2],
					//	_TotalBet[i][llev][3],_TotalBet[i][llev][4]);
			      }
			}
			
		}
	}
	else if ( (strcmp(egmclass->Command,"setGameDenom1") == 0 )
		|| (strcmp(egmclass->Command,"setGameDenom2") == 0 )
		|| (strcmp(egmclass->Command,"setGameDenom3") == 0 )
		|| (strcmp(egmclass->Command,"setGameDenom4") == 0 )
		|| (strcmp(egmclass->Command,"setGameDenom5") == 0 ) )
	{
                int Pgrp=0;
                unsigned long newDenoms[5] = {0,0,0,0,0};
		unsigned long newCoinsBet[5] = {0,0,0,0,0};
		unsigned long newLines[10] = {0,0,0,0,0,0,0,0,0,0};
		unsigned long newPay[5] = {0,0,0,0,0};
		int _newMaxBetLevel = 0;
		int _newLevelToNumCoins[5] = {0,0,0,0,0};;
		int newPercent[5]={0,0,0,0,0};
		int newJackpots[5]={0,0,0,0,0};
		int newBonus=0;
                int i,dlevel,ii,iii;
		int minbet[5];
		int denomInx;
		DATA_PAIRS ProgDatapairs[]={
			{"ProgGroup",""},		//0
			{"S01level",""},		//1
			{"S02level",""},
			{"S03level",""},
			{"S04level",""},
			{"S05level",""},
			{"S01denom",""},		//6
			{"S02denom",""},
			{"S03denom",""},
			{"S04denom",""},
			{"S05denom",""},
			{"S01line",""},			//11
			{"S02line",""},
			{"S03line",""},
			{"S04line",""},
			{"S05line",""},
			{"P11minbet",""},			//16
			{"S12qual",""},
			{"S13qual",""},
			{"S14qual",""},
			{"S15qual",""},
			{"P21minbet",""},			//21
			{"S22qual",""},
			{"S23qual",""},
			{"S24qual",""},
			{"S25qual",""},
			{"P31minbet",""},			//26
			{"S32qual",""},
			{"S33qual",""},
			{"S34qual",""},
			{"S35qual",""},
			{"P41minbet",""},			//31
			{"S42qual",""},
			{"S43qual",""},
			{"S44qual",""},
			{"S45qual",""},
 			{"P51minbet",""},			//36
			{"S52qual",""},
			{"S53qual",""},
			{"S54qual",""},
			{"S55qual",""},
			{"Payout1",""},			//41
			{"Payout2",""},
			{"Payout3",""},
			{"Payout4",""},
			{"Payout5",""},
			{"Paylevel1",""},		//46
			{"Paylevel2",""},
			{"Paylevel3",""},
			{"Paylevel4",""},
			{"Paylevel5",""},
			{"price",""},			//51
 
        	};
#define PAYOUT_ENTRY	41
#define PAYLEVEL_ENTRY	46
#define	PRICE_ENTRY	51
		int count=16+25+5+5+1;
		int price=0;
		
		denomInx = egmclass->Command[strlen(egmclass->Command) - 1] - '1';
        	//fprintf(_debugPort,"processProgressiveClass: egmclass->Command=%s,egmclas->Data=%s\n",egmclass->Command,egmclass->Data);
		//fprintf(_debugPort, "b4 extractDataPairs\n");
                extractDataPairs(egmclass->Data,ProgDatapairs,count);
		//for (i=0; i<count; i++) {
		//	fprintf(_debugPort, "[%d]%s:%s\n",i,ProgDatapairs[i].key, ProgDatapairs[i].data);
		//}
		//fprintf(_debugPort, "1\n");
                if (strlen(ProgDatapairs[0].data)>0)
                        sscanf(ProgDatapairs[0].data,"%d",&Pgrp);

		if (strlen(ProgDatapairs[PRICE_ENTRY].data) > 0) {
			sscanf(ProgDatapairs[PRICE_ENTRY].data, "%d", &price);
		} else	price = _GlobalConfig.price;

		for (i=0; i<5; i++) {
#ifdef BINGO
			//fprintf(_debugPort, "[%d]%s:%s\n",PAYLEVEL_ENTRY+i,ProgDatapairs[PAYLEVEL_ENTRY+i].key, ProgDatapairs[PAYLEVEL_ENTRY+i].data);
			if (strlen(ProgDatapairs[PAYLEVEL_ENTRY+i].data) > 0) { 	// Payout
				sscanf(ProgDatapairs[PAYLEVEL_ENTRY+i].data, "%d", &newPay[i]);
				//fprintf(_debugPort, "newPay[%d]=%d\n",i,newPay[i]);
			}
			if (newPay[i] >= 0) 
			{					// Payout
				//sscanf(ProgDatapairs[PAYLEVEL_ENTRY+i].data, "%d", &newPay[i]);
				// newPay[i] should correspond to one of the levels in paylevelvalues
				// for now, 0=90%, 1=92%, 2=94%, and 3=95.01%
				newPercent[i] = newPay[i] & 0x0f;
				if (newPercent[i] == -1) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPercent error\n");
					return;
				}
				//_BCInfo.payLevel[i] = newPercent[i];
				_BCInfo.payLevel[i] = i;
				fprintf(_debugPort, "_BCInfo.payLevel[%d]=%d\n",i,_BCInfo.payLevel[i]);
				//fprintf(_debugPort, "newPercent[%d]=%d\n",i,newPercent[i]);
#else // not BINGO
			if (strlen(ProgDatapairs[PAYOUT_ENTRY+i].data) > 0) 	// Payout
				sscanf(ProgDatapairs[PAYOUT_ENTRY+i].data, "%d", &newPay[i]);
			if (newPay[i] >= 0) {					// Payout
				sscanf(ProgDatapairs[PAYOUT_ENTRY+i].data, "%d", &newPay[i]);
				newJackpots[i] = (newPay[i] >> 4) & 0x0f;
				fprintf(_debugPort, "Pay percentage[%d] = %d, num=%d\n", i, newPay[i]&7, newJackpots[i]);
				// we don't have all the pay tables yet. Only 92% 1-7 jackpots and 94% 1-7 jackpots
				switch (newPay[i] & 0x0f) {
				case 0:			//88%	no bonus
					newPercent[i] = 88;
					newBonus &= ~(1<<i);
					break;
				case 2:			//90%	no bonus
					newPercent[i] = 90;
					newBonus &= ~(1<<i);
					break;
				case 3:			//91%
					newPercent[i] = 91;
					newBonus &= ~(1<<i);
					break;
				case 4:			//92%
					newPercent[i] = 92;
					if (newPay[i] & 0x100)
						newBonus |= (1<<i);
					else
						newBonus &= ~(1<<i);
					break;
 #ifdef MAMBOSKIN
				case 5:			//93%
					newPercent[i] = 93;
					newBonus |= (1<<i);
					break;
				case 7:			//95%
					newPercent[i] = 95;
					newBonus |= (1<<i);
					break;
				case 8:			//96%
					newPercent[i] = 96;
					newBonus |= (1<<i);
					break;
 #endif
				case 6:			//94%
					newPercent[i] = 94;
					newBonus |= (1<<i);
					break;
				case 1:			//89%
 #ifndef MAMBOSKIN
				case 5:			//93%
				case 7:			//95%
					
 #endif
				default:
					newPercent[i] = -1;
					break;
				}
 #ifndef MAMBOSKIN
				if (newPercent[i] != -1) {
					if ((newJackpots[i] < 1) || (newJackpots[i] > 7))
						newPercent[i] = -1;
				}
 #endif
 #ifndef MEXICO
				if (newPercent[i] == -1) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPercent error\n");
					return;
				}
 #endif
#endif //BINGO
			}
		}
		
		fprintf(_debugPort, "after newPercent\n");
		//if (_JackPotType == JP_GAMEBASED) {
		for (i=16; i<PAYOUT_ENTRY; i++) {
			if (strlen(ProgDatapairs[i].data) > 0) {
				ii = ProgDatapairs[i].key[1] - '1';
				iii = ProgDatapairs[i].key[2] - '1';
				if (iii == 0) {
					sscanf(ProgDatapairs[i].data, "%d", &minbet[ii]);
					fprintf(_debugPort, "%d:%d min qual = %d\n", ii, iii, minbet[ii]);
				}
			}
		}
	//  }
#ifndef PRODUCTION
 #ifndef PULLTAB
		// PullTab min qualifier is 25. This is only for developement, when switching between Bingo and PullTab
		//if (_JackPotType == JP_GAMEBASED && _minJPqualifier[0] == 25)
		//	_minJPqualifier[0] = 20;
 #endif
#endif
		//fprintf(_debugPort, "2\n");
#ifdef notdef2
                fprintf(_debugPort,"\n%s received Pgrp=%d ProgControllerType=%x SASGroup=%x",
                                egmclass->Command, Pgrp, _ExtendedConfig.ProgControllerType,_ExtendedConfig.SASGroup);
#endif

                if (_ExtendedConfig.ProgControllerType != 1)   // we are not controlled by SAS so take over
                {
			//serverConfigError = 0;			// clear error
			serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
			
			//fprintf(_debugPort, "_ExtendedConfig.SASGroup=%d, Pgrp=%d\n",_ExtendedConfig.SASGroup, Pgrp);
                        if (_ExtendedConfig.SASGroup && (_ExtendedConfig.SASGroup == Pgrp))     // if it matches our SAS Group number...
                        {
                                
                                for (i=1; i<=5; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newCoinsBet[i-1]);
#ifndef PRODUCTION
					//else
					//	newCoinsBet[i-1] = i;
#endif
                                }
				//sort(&newCoinsBet[0],5);
#ifdef notdef2
                                fprintf(_debugPort,"CoinsBet %ld %ld %ld %ld %ld\n",newCoinsBet[0],newCoinsBet[1],newCoinsBet[2],newCoinsBet[3],newCoinsBet[4]);
#endif
                                for (i=6; i<=10; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newDenoms[i-6]);
                                }
				//sort(&newDenoms[0], 5);
#ifdef notdef2
                                fprintf(_debugPort,"Denoms %ld %ld %ld %ld %ld\n",newDenoms[0],newDenoms[1],newDenoms[2],newDenoms[3],newDenoms[4]);
				
#endif
                                for (i=11; i<=15; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newLines[i-11]);
#ifdef FAKING_40LINES
						newLines[i-11] = 40;
#endif
#ifdef MLSKIN
						newLines[i-11] = 30;
#endif
                                }
				//sort(&newLines[0], 10);
#ifdef notdef2
                                fprintf(_debugPort,"LinesBet %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld\n",
					newLines[0],newLines[1],newLines[2],newLines[3],newLines[4],
				        newLines[5],newLines[6],newLines[7],newLines[8],newLines[9]);
				
#endif
			}
			// make sure valid coins bet
			for (i=0; i<5; i++) {
				if (newCoinsBet[i] > MAXCREDITSPERLINE) {
#ifdef notdef2
					fprintf(_debugPort, "newCoinsBet[%d]=%d\n",i,newCoinsBet[i]);
#endif
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= COINS_ERR;							
					_progressiveValueReceived = SDL_FALSE;
					return;
				}
			}
			// make sure valie lines bet for this game
			for (i=0; i<10; i++) {
				if (newLines[i] > 0) {
					iii = -1;
					for (ii=0; ii<5; ii++) {
						if (availLinesBet[ii] == newLines[i])
							iii = ii;
					}
					if (iii == -1) {
						processBadClass(sockfd, destAddr, egmclass);
						serverConfigError |= LINES_ERR;
						_progressiveValueReceived = SDL_FALSE;
						return;
					}
						
				}
			}
			
			// make sure valid denoms
#ifdef notdef2
			fprintf(_debugPort, "_ExtendedConfig.denominations[0]=%d\n",_ExtendedConfig.denominations[0]);
#endif
			//if (_ExtendedConfig.denominations[0] == 0) {			// 1st time from server
			if (_NeedServerConfig == 1) {		//1st time after ram clear
				if (denomInx == 0) {
				  _GlobalConfig.price = price;
				  _numDenomLevels = 0;
				}
				i = denomInx;
				{
					_Denominations[i] = (_ExtendedConfig.denominations[i] = newDenoms[i]);
					if (_Denominations[i] > 0) {
						_ExtendedConfig.Denoms[i] = SDL_TRUE;
						_numDenomLevels++;
					} else
						_ExtendedConfig.Denoms[i] = SDL_FALSE;
				}
#ifdef notdef2
				fprintf(_debugPort, "_numDenomLevels = %d\n",_numDenomLevels);
#endif
			      if (denomInx == 0) {
				for (i=0; i<MAX_COINS_PER_LINE; i++) {
					_GlobalConfig.betsPerLine[i] = 0;
				}
				_maxBetLevel = 0;
				ii = 0;		// number of betsPerLine > 20
				for (i=0; i<5; i++) {
					if (newCoinsBet[i] > 0) {
						++_maxBetLevel;
						_GlobalConfig.betsPerLine[newCoinsBet[i]-1] = 1;
						_LevelToNumCoins[_maxBetLevel]  = newCoinsBet[i];
#ifdef CARNIVAL_LOTTO
						if (newCoinsBet[i] > 20) {
						    _GlobalConfig.extraCoinsBet[ii++] = newCoinsBet[i];
						}
#endif
					}
				}
			
				for (i=0; i<5; i++) {
					if (_creditsPerLine == newCoinsBet[i])
						break;
				}	
				if ((i==5) || (_currentBetLevel != (i+1))) {
					_creditsPerLine = newCoinsBet[0];
					_currentBetLevel = 1;
					_GlobalMeters.LastCreditsPerLine = _creditsPerLine;
				}
				// set up number of lines bet
#ifdef notdef2
				fprintf(_debugPort, "setting up validBetLines\n");
#endif
				_GlobalConfig.validBetLines = 0;
				for (i=0; i<5; i++) {
					if (newLines[i] > 0) {
						for (ii=0; ii<5; ii++) {
							if (availLinesBet[ii] == newLines[i])
								_GlobalConfig.validBetLines |= 1 << ii;
						}		
					}
				}
#ifdef notdef2
				fprintf(_debugPort, "Have valid lines bet %d?\n", _numberOfLinesBet);
#endif
				for (i=0; i<5; i++) {
					if (_numberOfLinesBet == newLines[i]) {
						break;
					}
				}
				if (i==5) _numberOfLinesBet = newLines[0];
#ifdef notdef2
				fprintf(_debugPort, "_numberOfLinesBet=%d\n",_numberOfLinesBet);
#endif
			      } //denomInx==0
#ifdef BINGO
				// set up pay table and number of jackpots
				for (i=0; i<5; i++) {
					//if (newPay[i] > 0) 
					{
						//_GlobalConfig.payPercent[i] = newPercent[i];
  #if !defined(PULLTAB) && !defined(LOTTO_C2)
						_BCInfo.payLevel[i] = newPercent[i];
  #else
						_BCInfo.payLevel[i] = i;
  #endif
						//fprintf(_debugPort, "_BCInfo.payLevel[%d]=%d\n",i,newPercent[i]);
					}
				}
#else // not BINGO
				// set up pay table and number of jackpots
//#ifndef MAMBOSKIN
				for (i=0; i<5; i++) {
					if (newPay[i] >= 0) {
 #ifdef notdef2
						fprintf(_debugPort, "newPay[%d]=%d\n",i, newPercent[i]);
 #endif
						_GlobalConfig.payPercent[i] = newPercent[i];
						_GlobalConfig.numJackpots[i] = newJackpots[i];
					}
				}
//#endif
				_GlobalConfig.bonusFlag = newBonus;
 #ifdef notdef2
				fprintf(_debugPort, "got newPay\n");
 #endif
				JackpotInfoReInit();
 #ifdef notdef2
				fprintf(_debugPort, "after JackpotInfoReInit\n");
 #endif
				InitReelStrips();
 #ifdef notdef2
				fprintf(_debugPort, "after InitReelStrips\n");
 #endif
#endif // not bingo
                		_saveConfigRequired = SDL_TRUE;
				need2Send3C = SDL_TRUE;
#ifdef VICTORYLAND
				FlashEvent(3, "Initial setup", EV_CF_CHNG);
				fprintf(_debugPort, "b4 SendBingoUnRegister()\n");
				SendBingoUnRegister();
				fprintf(_debugPort, "b4 SendBingoRegister()\n");
				SendBingoRegister();
#endif
				
			} else { // _NeedServerConfig is 0
				//for (i=0; i<5; i++) 
				{
					iii = -1;
					i = denomInx;
					if (newDenoms[i] > 0) {
						for (ii=0; ii<NUM_DENOMS; ii++) {
							if (newDenoms[i] == _Denominations[ii]) {
								if (_ExtendedConfig.Denoms[ii] == SDL_TRUE) {
									iii = ii;
								}
							}
						}
						if (iii == -1) {
							//fprintf(_debugPort, "newDenoms[%d]=%d\n",i,newDenoms[i]);
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= DENOM_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							fprintf(_debugPort, "denom error\n");
							return;
						}
					} else if (_ExtendedConfig.Denoms[i] == SDL_TRUE) {	// denom is enabled, but server not sending it
						// server changed denoms. Not allowed.
						processBadClass(sockfd,destAddr,egmclass);
						serverConfigError |= DENOM_ERR;
						_progressiveValueReceived = SDL_FALSE;
						return;
					}
				}
				
				// make sure coins bet per line didn't change from last nvram clear
				_newMaxBetLevel = 0;
				for (i=0; i<5; i++) {
					if (newCoinsBet[i] > 0) {
						++_newMaxBetLevel;
						
						//_GlobalConfig.betsPerLine[newCoinsBet[i]-1] = 1;
						_newLevelToNumCoins[_newMaxBetLevel]  = newCoinsBet[i];
						if (_newLevelToNumCoins[i] != _LevelToNumCoins[i]) {
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= COINS_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							fprintf(_debugPort, "coins bet error\n");
						}
					}
				}
				if (_newMaxBetLevel != _maxBetLevel) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= COINS_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "coins bet error\n");
				}
//#ifndef MAMBOSKIN
 #ifndef MEXICO
  #ifndef BINGOSAS
				for (i=0; i<5; i++) {
					if (newPay[i] > 0) {
   #ifdef MAMBOSKIN
    #ifdef BINGO
     #ifndef PULLTAB
						if (_BCInfo.payLevel[i] != newPercent[i])
     #else
						if (_BCInfo.payLevel[i] != i)
     #endif
    #else
						if (_GlobalConfig.payPercent[i] != newPercent[i])
    #endif
   #else
    #ifdef BINGO
     #ifndef PULLTAB
						if (_BCInfo.payLevel[i] != newPercent[i])
     #else
						if (_BCInfo.payLevel[i] != i)
     #endif
    #else
						if ((_GlobalConfig.payPercent[i] != newPercent[i]) ||
								(_GlobalConfig.numJackpots[i] != newJackpots[i]))
    #endif
   #endif
						{
							fprintf(_debugPort, "newPay error\n");
							fprintf(_debugPort, "level %d _GlobalConfig.payPercent=%d, newPercent=%d\n", i,  _GlobalConfig.payPercent[i], newPercent[i]);
                					processBadClass(sockfd,destAddr,egmclass);
							serverConfigError |= PAY_ERR;			
							_progressiveValueReceived = SDL_FALSE;
							return;
						}
					}
				}
  #endif
				
  #ifndef BINGO
   #ifdef NEWMATH
				if (_GlobalConfig.bonusFlag != newBonus) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PAY_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newBonus error\n");
					return;
				}
   #endif
  #endif
 #endif
//#endif
 #ifdef BINGO
				if (_GlobalConfig.price != price) {
                			processBadClass(sockfd,destAddr,egmclass);
					serverConfigError |= PRICE_ERR;			
					_progressiveValueReceived = SDL_FALSE;
					fprintf(_debugPort, "newPrice error\n");
					return;
				}
 #endif
			}
			
		}
                      
		sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressive",ProgDatapairs[1].data);   //DenomLevel
                for (i=0; i<5; i++) 
		{
			int dlev, llev;
			dlev = denomInx; 
			{
				for (llev=0; llev<5; llev++) {
					int totalCreditsBet = newLines[llev] * newCoinsBet[i];
					int mlev;
					
					if (i >= _maxBetLevel || llev) {
						  _PayLevels[dlev][llev][i] = 0;
					} else
					for (mlev=1; mlev<6; mlev++) {
						if ((mlev == 5) || (minbet[mlev] <= 0) || (minbet[mlev] > totalCreditsBet)) {
#ifdef BINGO
						  _PayLevels[dlev][llev][i] = mlev - 1;
#else
						  _PayLevels[dlev][llev][i] = newPercent[mlev-1];
#endif
						  break;
						}
					}
				}
			}
		}

//#ifdef notdef
		for (i=0; i<5; i++) {
			fprintf(_debugPort, "_PayLevels[%1d][%1d] = %d:%d:%d:%d:%d\n", denomInx, i, _PayLevels[denomInx][i][0],
				_PayLevels[denomInx][i][1],_PayLevels[denomInx][i][2],_PayLevels[denomInx][i][3],_PayLevels[denomInx][i][4]);
		}
//#endif
		for (i=0; i<6; i++)
			_dToLevel[i] = 0;	// make sure it is cleared
		for (i=NUM_DENOMS-1,ii=0; i>=0; i--) {
			if (_ExtendedConfig.Denoms[i] == SDL_TRUE) {
				ii++;
				_dToLevel[ii]=_Denominations[i];
#ifdef notdef
				fprintf(_debugPort,"_denomToLevel[%d]=%d\n",ii, _dToLevel[ii]  );
#endif
			}
		}
	}
	else if (strcmp(egmclass->Command,"SetPaytableRange")==0)
	{
		DATA_PAIRS Datapairs[]={
			{"C",""},		//0
			{"P1",""},
			{"M1",""},
			{"P2",""},
			{"M2",""},
			{"P3",""},
			{"M3",""},
			{"P4",""},
			{"M4",""},
			{"P5",""},
			{"M5",""},
			{"P6",""},
			{"M6",""},
			{"P7",""},
			{"M7",""},
			{"P8",""},
			{"M8",""},
			{"P9",""},
			{"M9",""},
			{"P10",""},
			{"M10",""},
			{"P11",""},
			{"M11",""},
			{"P12",""},
			{"M12",""},
			{"P13",""},
			{"M13",""},
			{"P14",""},
			{"M14",""},
			{"P15",""},
			{"M15",""},
			{"P16",""},
			{"M16",""},
			{"P17",""},
			{"M17",""},
			{"P18",""},
			{"M18",""},
			{"P19",""},
			{"M19",""},
			{"P20",""},
			{"M20",""},
		};
		int count=41;
		int rangeCt;
		int i1;
		int minbetamount;
		
#ifdef	IGNORE_MINBET_RANGE
		// do nothing
		return;
#endif
                extractDataPairs(egmclass->Data,Datapairs,count);
		
 		sscanf(Datapairs[0].data, "%d", &rangeCt);
		fprintf(_debugPort, "SetPaytableRange: %d\n", rangeCt);
		if (_GlobalConfig.PayRangeFlag != rangeCt) {
			_GlobalConfig.PayRangeFlag = rangeCt;
			payRangeChanged = 1;
		}
		for (i1=0; i1<rangeCt; i1++) {
			int namelen;
			sscanf(Datapairs[1+i1*2+1].data, "%d", &minbetamount);
		//fprintf(_debugPort, "3\n");
			namelen = strlen(_MinBetRange.payName[i1]);
			//if (namelen > 0) {
				//if (_MinBetRange.payName[i1][namelen-1] == ' ')
				//	_MinBetRange.payName[i1][namelen-1] = '\0';
			//}
			if (strcmp(_MinBetRange.payName[i1], Datapairs[1+i1*2].data) != 0) {
		//fprintf(_debugPort, "4\n");
				strcpy(_MinBetRange.payName[i1], Datapairs[1+i1*2].data);
		//fprintf(_debugPort, "5\n");
				_MinBetRange.payPercent[i1] = 0; //not known
		//fprintf(_debugPort, "6\n");
				_MinBetRange.payLevel[i1] = -1;
		//fprintf(_debugPort, "7\n");
#ifdef notdef
				_MinBetRange.payPercent[i1] = PayName2Percent(_MinBetRange.payName[i1]);
				_MinBetRange.payLevel[i1] = PayName2Level(_MinBetRange.payName[i1]);
#endif
				payRangeChanged = 1;
		//fprintf(_debugPort, "8\n");
			}
		//fprintf(_debugPort, "9\n");
			if (minbetamount != _MinBetRange.minBet[i1]) {
		//fprintf(_debugPort, "10\n");
				_MinBetRange.minBet[i1] = minbetamount;
		//fprintf(_debugPort, "11\n");
				payRangeChanged = 1;
		//fprintf(_debugPort, "12\n");
			}
			fprintf(_debugPort, "[%d] %s, %d\n", i1+1, _MinBetRange.payName[i1], _MinBetRange.minBet[i1]);
		}
		sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressive",egmclass->Command);   //DenomLevel
	  
	}
//#ifdef MYSTERYJP
	else if ((_JackPotType == JP_BONUS) && (strcmp(egmclass->Command,"setProgressiveDenoms")==0))
	{
                int Pgrp=0;
                unsigned long newProgDenoms[5] = {0,0,0,0,0};
		unsigned long newTotalCoinsBetMin[5] = {0,0,0,0,0};
		int _newMaxBetLevel = 0;
		int _newLevelToNumCoins[5] = {0,0,0,0,0};;
                int i,dlevel,ii,iii;
		DATA_PAIRS ProgDatapairs[]={
			{"ProgGroup",""},		//0
			{"S01level",""},		//1
			{"S02level",""},
			{"S03level",""},
			{"S04level",""},
			{"S05level",""},
			{"S01denom",""},		//6
			{"S02denom",""},
			{"S03denom",""},
			{"S04denom",""},
			{"S05denom",""},
			{"S11qual",""},			//11
			{"S21qual",""},			//12
			{"S31qual",""},			//13
			{"S41qual",""},			//14
 			{"S51qual",""},			//15
         	};
		int count=16;
		
                extractDataPairs(egmclass->Data,ProgDatapairs,count);
		//for (i=0; i<count; i++) {
		//	fprintf(_debugPort, "[%d]%s:%s\n",i,ProgDatapairs[i].key, ProgDatapairs[i].data);
		//}
                if (strlen(ProgDatapairs[0].data)>0)
                        sscanf(ProgDatapairs[0].data,"%d",&Pgrp);


		for (i=11; i<count; i++) {
			if (strlen(ProgDatapairs[i].data) > 0) {
				ii = ProgDatapairs[i].key[1] - '1';
				iii = ProgDatapairs[i].key[2] - '1';
				if (iii == 0) {
					sscanf(ProgDatapairs[i].data, "%d", &_minJPqualifier[ii]);
					fprintf(_debugPort, "%d:%d min qual = %d\n", ii, iii, _minJPqualifier[ii]);
				}
			}
		}
		//fprintf(_debugPort, "2\n");
                if (_ExtendedConfig.ProgControllerType != 1)   // we are not controlled by SAS so take over
                {
			//serverConfigError = 0;			// clear error
			//serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
			
			//fprintf(_debugPort, "_ExtendedConfig.SASGroup=%d, Pgrp=%d\n",_ExtendedConfig.SASGroup, Pgrp);
                        if (_ExtendedConfig.SASGroup && (_ExtendedConfig.SASGroup == Pgrp))     // if it matches our SAS Group number...
                        {
                                
				Pgrp--;
                                for (i=1; i<=5; i++) {
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data,"%ld",&newTotalCoinsBetMin[i-1]);
                                }
				//sort(&newTotalCoinsBetMin[0],5);
//#ifdef notdef1
                                fprintf(_debugPort,"TotalCoinsBetMin %ld %ld %ld %ld %ld\n",newTotalCoinsBetMin[0],newTotalCoinsBetMin[1],newTotalCoinsBetMin[2],newTotalCoinsBetMin[3],newTotalCoinsBetMin[4]);
//#endif
#ifdef ATRIB2_1
                                for (i=6; i<=6; i++) {
#else
                                for (i=6; i<=10; i++) {
#endif
                                        if (strlen(ProgDatapairs[i].data)>0) 
                                                sscanf(ProgDatapairs[i].data, "%ld", &newProgDenoms[i-6]);
                                }
				//sort(&newDenoms[0], 5);
//#ifdef notdef1
                                fprintf(_debugPort,"progDenoms %ld %ld %ld %ld %ld\n", newProgDenoms[0], newProgDenoms[1], newProgDenoms[2], newProgDenoms[3], newProgDenoms[4]);
				
//#endif
				multiProg[Pgrp].progGroup = Pgrp;
				for (i=0; i<5; i++) {
					multiProg[Pgrp].denom[i] = newProgDenoms[i];
					multiProg[Pgrp].coins[i] = newTotalCoinsBetMin[i];
					multiProg[Pgrp].qual[i] = _minJPqualifier[i];
				}
#ifndef PRODUCTION
				//fprintf(_debugPort, "setProgressiveDenoms() JackpotInfoReInit\n");
#endif
				JackpotInfoReInit();
			}
			
			
		}
                      
		sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressive",ProgDatapairs[1].data);   //DenomLevel
	}
//#endif
        else if(strcmp(egmclass->Command,"setDeviceState")==0)
        {
                //printf("cabinet : setDeviceState received\n");
                sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressiveStatus","hostEnabled=true,egmEnabled=true,lockedOut=false,paytableIndex=1,progValue=9876");
        }
        else if(strcmp(egmclass->Command,"setLockOut")==0)
        {
                //printf("cabinet : setLockOut received\n");
                sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressiveStatus","hostEnabled=true,egmEnabled=true,lockedOut=false,paytableIndex=1,progValue=9876");
        }
        else if(strcmp(egmclass->Command,"getProgressiveLogStatus")==0)
        {
                //printf("cabinet : getProgressiveLogStatus received\n");
                sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressiveLogStatus","lastSequence=12345,totalEntries=10");
        }
        else if(strcmp(egmclass->Command,"getProgressiveLog")==0)
        {
                //printf("cabinet : getProgressiveLog received\n");
                sendClass(sockfd,destAddr,"progressive",_TheEgmID,"progressiveLogList","ProgLog1transactionId=123456788,hitDateTime=20060301100058321,progId=7,progLevel=1,progValue=123450,hitAck=true,   	  	  winDateTime=20040316184627432,progWin=123450,winAck=true,transactionSeq=12346,transactionReset=false,		  	  ProgLog2transactionId=123456789,hitDateTime=20060301100158321,progId=7,progLevel=1,progValue=123450,hitAck=true,		  	  winDateTime=20040316184627432,progWin=123450,winAck=true,transactionSeq=12347,transactionReset=false");
        }
	else if (strcmp(egmclass->Command,"setProgressiveWin") == 0)
	{
                int Pgrp=0;
                int i,level,ii,iii,denom,machine;
		
		DATA_PAIRS ProgDatapairs[]={
                    {"progGroup",""},
                    {"denom",""},
                    {"progLevel",""},
                    {"progWin",""},
                    {"machineNum",""},
        	};
		int count=5;
		
		//fprintf(_debugPort, "b4 extractDataPairs\n");
                extractDataPairs(egmclass->Data,ProgDatapairs,count);
		//for (i=0; i<count; i++) {
			//fprintf(_debugPort, "%s:%s\n",ProgDatapairs[i].key, ProgDatapairs[i].data);
		//}
		//fprintf(_debugPort, "1\n");
                if (strlen(ProgDatapairs[0].data)>0) {
                        sscanf(ProgDatapairs[0].data,"%d",&Pgrp);
		}

                if (_ExtendedConfig.ProgControllerType != 1)   // we are not controlled by SAS so take over
                {
			//serverConfigError = 0;			// clear error
			serverConfigError &= JACKPOTYPE_ERR;	// clear all errors except jackpot type
			
			//fprintf(_debugPort, "_ExtendedConfig.SASGroup=%d, Pgrp=%d\n",_ExtendedConfig.SASGroup, Pgrp);
                        if (_ExtendedConfig.SASGroup && (_ExtendedConfig.SASGroup == Pgrp))     // if it matches our SAS Group number...
                        {
				if (_JackPotType == JP_GAMEBASED) {
					//fprintf(_debugPort, "_ProgressiveWin was %lld\n", _GlobalMeters._ProgressiveWin);
					sscanf(ProgDatapairs[1].data,"%d",&denom);
					sscanf(ProgDatapairs[2].data,"%d",&level);
					sscanf(ProgDatapairs[4].data,"%d",&machine);
					sscanf(ProgDatapairs[3].data,"%lld",&_GlobalMeters._ProgressiveWin);
					//fprintf(_debugPort, "_ProgressiveWin is %lld\n", _GlobalMeters._ProgressiveWin);
				}
#ifndef BINGO
				_GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
				bonusInfo.waiting4ProgHitAck = 0;
#else
				if (bonusInfo.waiting4ProgHitAck == 2) {
				  _GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
				  bonusInfo.waiting4ProgHitAck = 0;
				} else if (bonusInfo.waiting4ProgHitAck == 1)
				  bonusInfo.waiting4ProgHitAck = 2;
#endif
#ifdef BINGO
    				//SendBingoClaim();	// do it in GS_CLAIM
#endif
			}
		}
	}
        else if ((strcmp(egmclass->Command,"gameActivityAck")==0) || 		(strcmp(egmclass->Command,"activityack")==0))

        {
		DATA_PAIRS datapairs[]={
                    {"balance",""},
		    {"vnetts",""},
        	};
		int count=2;
		
		lastTouchButtonTime = SDL_GetTicks();
#ifdef LOADTEST
		PrintGameTime();
#endif

#ifndef PRODUCTION
#ifdef notdef
#ifndef TEST_OFS
		if (doActivityTest == 1) {
			doActivityTest = 0;
			fprintf(_debugPort, "ignoring activity\n");
		}
		else
#endif
#endif
#endif
		{
			//fprintf(_debugPort, "b4 extractDataPairs\n");
			unsigned long long balance;
                	extractDataPairsDelim(egmclass->Data,datapairs,count,':');
			sscanf(datapairs[0].data, "%lld",&balance);
#ifdef FAKE0BALANCE
			balance = 0;
			_GlobalMeters.PlayerAccount = 0;
			_CurrentPlayerAccount = 0;
#endif
#ifdef PULLTAB
			if (IsWaiting4GameActivityAck() == SDL_TRUE) {
				ReadLog("CashlessLog", (char *)&cashlessLog, sizeof(cashlessLog), _GlobalMeters.CashlessLogPtr%CASHLESSHISTCOUNT);
				strcpy(cashlessLog.VNDateTime, datapairs[1].data);		// timestamp from VNet
				//if (cashlessLog.handpay) {
					//cashlessLog.amount2Server -= cashlessLog.handpay;	// transfer amount
					//cashlessLog.endBalance = balance;
				//}
				cashlessLog.transactionSeq = ++_GlobalMeters.CashlessLogPtr;
				cashlessLog.crc = CRC((unsigned char *)&cashlessLog, sizeof(cashlessLog)-2, 0);
				CashlessLogWrite();
				if (cashlessLog.handpay) {
					char tmpbuf[20];
					sprintf(tmpbuf, "IRS $%lld.%02d", cashlessLog.handpay/100, (long)(cashlessLog.handpay % 100));
					FlashEventWithTimeStamp(3, tmpbuf, cashlessLog.VNDateTime, EV_HANDPAY);

					strcpy(handpayLog.localDateTime,getTimeStamp());
					strcpy(handpayLog.VNDateTime, cashlessLog.VNDateTime);
					strcpy(handpayLog.passport, cashlessLog.passport);
					handpayLog.handpay = cashlessLog.handpay;
					strcpy(handpayLog.type, tmpbuf);
					handpayLog.transactionSeq = ++_GlobalMeters.handpaySeq;
					handpayLog.crc = CRC((unsigned char *)&handpayLog, sizeof(handpayLog)-2, 0);
					HandpayLogWrite();
				} 
			}

#endif
			ClearWaiting4GameActivityAck();		// clear waiting for gameActivity ack flag
			LastGameActivityTime = 0;
#ifdef BINGO
			if (CreditExceeded() == SDL_TRUE) {
	    			SetLastLoginStatus("Maximum Credit Exceeded", "");
				//_logOffAfterGameFlag = SDL_TRUE;
			}
			if (GetBingoState() == BIS_WAIT_LOGOFF) {	// if waiting to send logoff, go ahead
				SetBingoState(BIS_SEND_LOGOFF, -1);
			} else if (balance == 0) {
				_logOffAfterGameFlag = SDL_TRUE;
			}
#endif
#if defined(LOADTEST) || !defined(PRODUCTION)
			if (_CurrentPlayerAccount != balance) {
				fprintf(_debugPort, "\n!!!!!!!!!!!!*************** BALANCE MISMATCH\n");
			}
#endif
		}
		_saveMetersRequired = SDL_TRUE;
        }
        else if ((strcmp(egmclass->Command,"gameActivityNAck")==0) || 
		(strcmp(egmclass->Command,"activitynack")==0))
        {
		DATA_PAIRS datapairs[]={
                    {"balance",""},
                    {"status",""},
		    {"vnetts",""},
        	};
		int count=3;
		
		//fprintf(_debugPort, "b4 extractDataPairs\n");
                extractDataPairsDelim(egmclass->Data,datapairs,count,':');
		//sscanf(datapairs[1].data, "%lld",&gameid);
		//sscanf(datapairs[0].data, "%lld",&balance);
#ifdef PULLTAB
			if (IsWaiting4GameActivityAck() == SDL_TRUE) {
				char tmpbuf[20];

				++_GlobalMeters.P_OOSCount;
				++_GlobalMeters.G_OOSCount;
				ReadLog("CashlessLog", (char *)&cashlessLog, sizeof(cashlessLog), _GlobalMeters.CashlessLogPtr%CASHLESSHISTCOUNT);
				strcpy(cashlessLog.VNDateTime, datapairs[2].data);		// timestamp from VNet
				//if (cashlessLog.handpay == 0) {
				if (cashlessLog.handpay < cashlessLog.amount2Server) {
					unsigned long long diff = cashlessLog.amount2Server - cashlessLog.handpay;
					cashlessLog.handpay = cashlessLog.amount2Server;
					cashlessLog.endBalance -= diff;
					IncrLongLongMeter(&_GlobalMeters.P_OOSHandPay, diff, 4);
					IncrLongLongMeter(&_GlobalMeters.G_OOSHandPay, diff, 4);
					_GlobalMeters.OOS_handpay_adjust = diff;
				}
				//if (cashlessLog.handpay) {
				//	cashlessLog.amount2Server -= cashlessLog.handpay;	// transfer amount
				//}
				cashlessLog.transactionSeq = ++_GlobalMeters.CashlessLogPtr;
				cashlessLog.crc = CRC((unsigned char *)&cashlessLog, sizeof(cashlessLog)-2, 0);
				CashlessLogWrite();
				//if (cashlessLog.handpay) 
				{
					sprintf(tmpbuf, "OOS $%lld.%02d", cashlessLog.handpay/100, (long)(cashlessLog.handpay % 100));
					FlashEventWithTimeStamp(3, tmpbuf, cashlessLog.VNDateTime, EV_HANDPAY);
				}

				//if (cashlessLog.handpay) 
				{
					strcpy(handpayLog.localDateTime,getTimeStamp());
					strcpy(handpayLog.VNDateTime, cashlessLog.VNDateTime);
					strcpy(handpayLog.passport, cashlessLog.passport);
					handpayLog.handpay = cashlessLog.handpay;
					strcpy(handpayLog.type, tmpbuf);
					handpayLog.transactionSeq = ++_GlobalMeters.handpaySeq;
					handpayLog.crc = CRC((unsigned char *)&handpayLog, sizeof(handpayLog)-2, 0);
					HandpayLogWrite();
				} 
			}

#endif
		ClearWaiting4GameActivityAck();		// clear waiting for gameActivity ack flag
#ifdef BINGO
		if ((strcmp(datapairs[1].data, "Logged Off") == 0) || 
			(strcmp(datapairs[1].data, "Wrong Passport") == 0)) {
			SendBingoLogin();
			NeedTestLogin = 2;
			LastTestLoginTime = SDL_GetTicks();
			SetOutOfService();
			_GlobalMeters.serverLockType = 1;
		}
#endif
		_saveMetersRequired = SDL_TRUE;
        }
	else if (strcmp(egmclass->Command, "eventlogack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"eventnum",""},
			{"status",""},
		};

		int count = 2;
		unsigned long long eventNum = 0;

		extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		sscanf(datapairs[0].data, "%lld", &eventNum);
		eventNum -= (_GlobalConfig.assetID * 10000000000ull);
		ClearLastEvent(eventNum);
		ResendEvent();		// send next event, if any
	} else  if (strcmp(egmclass->Command, "eventlognack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"eventnum",""},
			{"status",""},
		};

		int count = 2;
		unsigned long long eventNum = 0;

		extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		sscanf(datapairs[0].data, "%lld", &eventNum);
		eventNum -= (_GlobalConfig.assetID * 10000000000ull);
		ClearLastEvent(eventNum);
		ResendEvent();		// send next event, if any
	}
#ifdef USE_MAG_CARD
        else if (strcmp(egmclass->Command,"purchaseack")==0) 
        {
		if (IsWaiting4PurchaseAck() == SDL_TRUE) {
			extern int _saveCashlessLog;
			DATA_PAIRS datapairs[]={
                    	{"passport",""},
                    	{"vnetts",""},
        		};
			int count=2;

			SendBingoLogin();	// this is to update the balance
                	extractDataPairs(egmclass->Data,datapairs,count);
			ReadLog("MoneyLog", (char *)&notesAcceptedLog, sizeof(notesAcceptedLog), (_GlobalMeters.dbaTransSeq - 1)%MONEYHISTCOUNT);
			strcpy(cashlessLog.localDateTime,getTimeStamp());
			strcpy(cashlessLog.VNDateTime, datapairs[1].data);		// timestamp from VNet
			cashlessLog.amount2Server = notesAcceptedLog.denomId;		// transfer amount
			cashlessLog.amount2Game = 0;
			cashlessLog.handpay = 0;
			cashlessLog.startBalance = notesAcceptedLog.startBalance;
			cashlessLog.endBalance = notesAcceptedLog.endBalance;
			strcpy(cashlessLog.type, "Bill In");
			cashlessLog.transactionSeq = ++_GlobalMeters.CashlessLogPtr;
			strcpy(cashlessLog.passport, notesAcceptedLog.passport);
			cashlessLog.crc = CRC((unsigned char *)&cashlessLog, sizeof(cashlessLog)-2, 0);

			
			//_saveCashlessLog = 1;
			CashlessLogWrite();
			ClearWaiting4PurchaseAck();		// clear waiting for cashinfo ack flag
			LastPurchaseTime = 0;
		}
	} 
        else if (strcmp(egmclass->Command,"purchasenack")==0) 
        {
		//bonusInfo.waiting4GAack &= ~4;		// clear waiting for cashinfo ack flag
		//LastPurchaseTime = 0;
		// set out of service, when cleared, clear waiting4GAack bit 2
		DATA_PAIRS datapairs[]={
                    {"balance",""},
                    {"status",""},
        	};
		int count=2;
		
		//fprintf(_debugPort, "b4 extractDataPairs\n");
                extractDataPairsDelim(egmclass->Data,datapairs,count,':');
		//sscanf(datapairs[1].data, "%lld",&gameid);
		//sscanf(datapairs[0].data, "%lld",&balance);
		ClearWaiting4PurchaseAck();		// clear waiting for purchase ack flag
		//if ((strcmp(datapairs[1].data, "Logged Off") == 0) || 
		//	(strcmp(datapairs[1].data, "Wrong Passport") == 0)) 
		{
			SendBingoLogin();
			NeedTestLogin = 2;
			LastTestLoginTime = SDL_GetTicks();
			SetOutOfService();
			_GlobalMeters.serverLockType = 4;
		}
		_saveMetersRequired = SDL_TRUE;
	} 
#else
        else if (strcmp(egmclass->Command,"cashinfoack")==0) 
        {
		ClearWaiting4PurchaseAck();		// clear waiting for cashinfo ack flag
		LastCashInfoTime = 0;
		if (HaveCashInfo2Send() == SDL_TRUE) {
			SendCashInfo1(&_GlobalMeters.cinfo);
		}
	}
#endif
        else
                processBadClass(sockfd,destAddr,egmclass);
}

#ifdef BINGO
void processBingoClass(int sockfd,struct sockaddr *destAddr,EGM_CLASS *egmclass)
{
  BINGO_STATE bState = GetBingoState();
#ifdef BINGO
  //fprintf(_debugPort, "\nprocessBingoClass, Command=%s, strlen(%s\n)=%d\n",egmclass->Command, egmclass->Data,strlen(egmclass->Data));
  //fprintf(_debugPort, "Bingo State = %d\n",(int)bState);
#endif
  if(strcmp(egmclass->Command,"card")==0)
  {
    if (bState != BIS_WAIT_CARD)  {
	    // ignore if we didn't ask for a card, or we already got it and this is a duplicate
	    return;
    }
    DATA_PAIRS datapairs[]={
      {"cardnum", ""},
      {"square",""},
    };
    int count=2;
    //extern long cardNumArray[];
    //printf("cabinet : card received\n");
    
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
#ifdef FAKING_PIZZA_JP
    strcpy(datapairs[1].data, "15,9,3,5,2,29,18,23,24,30,38,37,0,43,45,46,55,54,52,50,67,71,62,70,69");
#endif
#ifdef FORCING_BONUS5
    strcpy(datapairs[1].data, "15,9,3,5,2,29,18,23,24,30,38,37,0,43,45,46,55,54,52,50,67,71,62,70,69");
#endif
    sscanf(datapairs[0].data, "%lld", &_BCInfo.cardnum);
#ifdef notdef
    fprintf(_debugPort,"bingo card %lld:%s\n", _BCInfo.cardnum, datapairs[1].data);
#endif
    parseNextChar(datapairs[1].data, _BCInfo.cardNumArray, 25, ',');
    //sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","");
    SetBingoState(BIS_INACTIVE, -1);
#ifdef FAKECARDBASED
    SendBingoLogin();
#endif
  }
#if defined(FAKECARDBASED)
  else if (strcmp(egmclass->Command,"loginack")==0)
  {
    return;
  }
  else if (strcmp(egmclass->Command,"loginnack")==0)
  {
    return;
  }
  else if (strcmp(egmclass->Command,"logoffack")==0)
  {
    return;
  }  
  else if (strcmp(egmclass->Command,"logoffnack")==0)
  {
    return;
  }  
#endif
#ifdef VICTORYLAND
  else if (strcmp(egmclass->Command,"loginack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"balance",""},
      {"status",""},		// status = ok, wrongpin, wrongdevice, pinexpired
      {"vnetts",""},
#ifdef TABLET
      {"deviceleft",""},	// checkout timer, remaining minutes
#endif
    };
    unsigned long long bal;
#ifdef TABLET
    int count=5;
    int minLeft;
#else
    int count = 4;
    int minLeft = 9999;
#endif

    if (NeedTestLogin == 2) {
	LastTestLoginTime = 0;
	NeedTestLogin = 0;
	SendKeepAlive(destAddr);
#ifdef notdef1
	fprintf(_debugPort,"ka4 sent\n");
#endif
	return;
    }
    if (NeedTestLogin == 1) {		// jackpot lockup or out of service, 1st time after commsOnLine
	NeedTestLogin = 0;
	LastTestLoginTime = 0;
	SendKeepAlive(destAddr);
#ifdef notdef1
	fprintf(_debugPort,"ka5 sent\n");
#endif
	return;
    }
    if (bState != BIS_WAIT_LOGIN)  {
	    // ignore if we didn't send a login command, or we already got it and this is a duplicate
	    //ClearLogin();
#ifdef CASHPLAY
	if ((GetBingoState() == BIS_SEND_CARD) && ((_BCInfo.printPinReceipt & 1) == 1)) {
    		extractDataPairsDelim(egmclass->Data,datapairs,count,':');
		sscanf(datapairs[1].data, "%lld", &bal);
    		if (strcmp(datapairs[0].data, _BCInfo.newpin) == 0) {
			char buf[32];
			sprintf(buf, "Logged In. $%lld.%02d", bal/100, (unsigned long)(bal%100));
			SetLastLoginStatus(buf, datapairs[3].data);
		}
	}
#endif
	    return;
    }
    //fprintf(_debugPort, "_LoginGotPassport=%d,_LoginGotPin=%d\n", _LoginGotPassport, _LoginGotPin);
    if (_LoginGotPassport == 1) {	// passport is ok
	// we didn't send a pin
	_LoginGotPassport = 2;
    	SetBingoState(BIS_INACTIVE, -1);
	SetLastActivityTime();
    	SetLastLoginStatus("", "");
	return;
    }
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    if (strcmp(datapairs[0].data, _BCInfo.passport) != 0) {		// loginack for a different passport
	SendForceBingoLogoff(datapairs[0].data);			//  release passport
	return;
    }
    sscanf(datapairs[1].data, "%lld", &bal);
#ifdef DO_TITO
    if (bal != 0) {
	extern unsigned long incomingTransAmt;

	strcpy(passportLog.VNDateTime, datapairs[3].data);
	strcpy(passportLog.assetDateTime, getTimeStamp());
	passportLog.type = 0;		// login
	passportLog.startBalance = bal;
	strcpy(passportLog.passport, datapairs[0].data);
	passportLog.transactionSeq = ++_GlobalMeters.PassportLogPtr;
	passportLog.crc = CRC((unsigned char *)&passportLog, sizeof(passportLog)-2, 0);
	//fprintf(_debugPort, "passportLog crc=%d\n", passportLog.crc);
	PassportLogWrite();
	
	bonusInfo.instate70 = 0x71;
	incomingTransAmt = bal;
	_BCInfo.lastLoginTime = SDL_GetTicks();
	SetLastActivityTime();
	SetBingoState(BIS_SEND_CARD, -1);		// actually use this to goto denom selection screen
	_GlobalMeters.gameLoginFailed = 0;
	
	return;
    }
#endif
#ifdef FAKE0BALANCE_1
    bal = 0;
#endif
#ifdef TABLET
    sscanf(datapairs[4].data, "%d", &minLeft);	// get remaining minutes for device checkout
    if (_BCInfo.checkoutTime == 0) _GlobalMeters.checkOutTimer = 0;
#endif
    IncrLongLongMeter(&_CurrentPlayerAccount, bal, 4);
    IncrLongLongMeter(&_GlobalMeters.PlayerAccount, bal, 4);
    _saveMetersRequired = SDL_TRUE;
    DingUp(bal,0);
    StopDingUp();
    SoundPlayDingEnd();
#ifndef VICTORYLAND
    SetAllButtonState(MSBTN_ON);
#endif
    if ((strcmp(datapairs[2].data, "ok") != 0) && (strcmp(datapairs[2].data, "OK") != 0))
    	SetLastLoginStatus(datapairs[2].data, "");
    else {
	char buf[32];

#ifdef CASHPLAY
	if (bal == 0) {
		sprintf(buf, "Logging In with $%d.%02d", _BCInfo.cash4newpin/100, _BCInfo.cash4newpin%100);
	} else
#endif
	sprintf(buf, "Logged In. $%lld.%02d", bal/100, (unsigned long)(bal%100));
	SetLastLoginStatus(buf, datapairs[3].data);
	SetAllButtonState(MSBTN_ON);
#if defined(PULLTAB) || defined(CASHPLAY)
	strcpy(passportLog.VNDateTime, datapairs[3].data);
	strcpy(passportLog.assetDateTime, getTimeStamp());
	passportLog.type = 0;		// login
	passportLog.startBalance = bal;
	strcpy(passportLog.passport, datapairs[0].data);
	passportLog.transactionSeq = ++_GlobalMeters.PassportLogPtr;
	passportLog.crc = CRC((unsigned char *)&passportLog, sizeof(passportLog)-2, 0);
	//fprintf(_debugPort, "passportLog crc=%d\n", passportLog.crc);
	PassportLogWrite();
#endif
    }
    if (strcmp(datapairs[2].data, "wrongdevice") == 0) {
    	SetBingoState(BIS_INACTIVE, -1);
	ClearLogin();
	IncrLogInFailed();
#ifdef TABLETONLY
	_GlobalMeters.checkOutTimer = minLeft*MIN2TICKS + SDL_GetTicks();
#endif
    }
#ifdef TABLETONLY
    else if (minLeft < 0) 
    {				// timer already expired
	//fprintf(_debugPort, "minLeft=%d\n",minLeft);
	_GlobalMeters.checkOutTimer = SDL_GetTicks() - 10;
    	SetBingoState(BIS_INACTIVE, -1);
	ClearLogin();
    } 
#endif
#ifdef CASHPLAY
    else if ((strcmp(datapairs[0].data, _BCInfo.newpin) != 0) && (bal == 0)) {	
#else
    else if (bal == 0) {
#endif
	if ((strcmp(datapairs[2].data, "ok") == 0) || (strcmp(datapairs[2].data, "OK") == 0)) {
		SetLastLoginStatus("Account balance is zero", datapairs[3].data);
		SetBingoState(BIS_WAIT_LOGOFF, 0);
	} else { 
    	SetBingoState(BIS_INACTIVE, -1);
	ClearLogin();
	IncrLogInFailed();
#ifdef TABLETONLY
	_GlobalMeters.checkOutTimer = minLeft*MIN2TICKS + SDL_GetTicks();
#endif
	}
    } else {
	_BCInfo.lastLoginTime = SDL_GetTicks();
	SetLastActivityTime();
#ifdef PULLTAB
 #ifdef LOADTEST
    	SetBingoState(BIS_INACTIVE, -1);
 #else
	//if (_numDenomLevels == 1) {
    	//	SetBingoState(BIS_INACTIVE, -1);
	//} else {
    		SetBingoState(BIS_SEND_CARD, -1);		// actually use this to goto denom selection screen
	//}
 #endif
#else
 #ifndef TEST_NO_BINGOCARD
    	SetBingoState(BIS_SEND_CARD, -1);
 #else
    	SetBingoState(BIS_INACTIVE, -1);
 #endif
#endif
	_GlobalMeters.gameLoginFailed = 0;
#ifdef TABLETONLY
	_GlobalMeters.checkOutTimer = minLeft*MIN2TICKS + SDL_GetTicks();
#endif
#ifdef CASHPLAY
    	if ((strcmp(datapairs[0].data, _BCInfo.newpin) == 0) && (_BCInfo.cash4newpin > 0)) {	// we are logging in because cash was inserted.
		//strcpy(_BCInfo.newpin, "");
		SendCashInfoBillIn(_BCInfo.cash4newpin);
		DingUp(_BCInfo.cash4newpin, 0);
		_BCInfo.cash4newpin = 0;
		SetAllButtonState(MSBTN_ON);
	} else
#endif
#ifdef VICTORYLAND
	if (CreditExceeded() == SDL_TRUE) {
    		SetLastLoginStatus("Maximum Credit Exceeded", datapairs[3].data);
		_logOffAfterGameFlag = SDL_TRUE;
	}
#endif

    	_DollarsOrCredits = _ExtendedConfig.DollarsOrCredits;
    }
    _saveMetersRequired = SDL_TRUE;
  }
#endif
#ifdef VICTORYLAND	// card based games only
  else if (strcmp(egmclass->Command,"logoffack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"balance",""},
      {"vnetts", ""},
    };
    int count=3;
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    //_BCInfo.passport[0] = '\0';
    if (strcmp(datapairs[0].data, _BCInfo.passport) == 0) {
	_totalCashIn = 0;
    	ClearLogin();
#if defined(PULLTAB) || defined(CASHPLAY)
	strcpy(passportLog.VNDateTime, datapairs[2].data);
	strcpy(passportLog.assetDateTime, getTimeStamp());
	passportLog.type = 1;		// logoff
	passportLog.startBalance = 0;
	passportLog.endBalance = _GlobalMeters.PlayerAccount - _GlobalMeters.OOS_handpay_adjust;
	strcpy(passportLog.passport, datapairs[0].data);
	passportLog.transactionSeq = ++_GlobalMeters.PassportLogPtr;
	passportLog.crc = CRC((unsigned char *)&passportLog, sizeof(passportLog)-2, 0);
	fprintf(_debugPort, "passportLog crc=%d\n", passportLog.crc);
	PassportLogWrite();
	_GlobalMeters.OOS_handpay_adjust = 0;
#endif
    	_CurrentPlayerAccount = 0;
    	_PlayerAccount = 0;
    	_GlobalMeters.PlayerAccount = 0;
    	_saveMetersRequired = 1;
//#ifdef TABLET
	if (bState == BIS_SEND_LOGOFF || bState == BIS_WAIT_LOGOFF || bState == BIS_LOGOFF_DELAY) {
		SetBingoState(BIS_INACTIVE, -1);
		_BingoDisconnectState = BDIS_OK;
    		ButtonSetState(MSBTN_PRINT,MSBTN_ON);		// this is to allow us to enter config
#ifndef LOADTEST
	    	ButtonSetState(MSBTN_HLP_PAY_TBL,MSBTN_ON);		// this is to allow us to see help pages
#endif
    	} else if (bState == BIS_WAIT_DEAL) {
	    if (_BingoDisconnectState == BDIS_OK)
	    	_BingoDisconnectState = BDIS_DISCONNECT;			// force a cancel and logoff
    	} else if (_BingoDisconnectState != BDIS_OK) {
	    _BingoDisconnectState = BDIS_CANCELDEAL_ACKED;
    	} else {
    		ButtonSetState(MSBTN_PRINT,MSBTN_ON);		// this is to allow us to enter config
#ifndef LOADTEST
	    	ButtonSetState(MSBTN_HLP_PAY_TBL,MSBTN_ON);		// this is to allow us to see help pages
#endif
    	}
#ifndef DO_TITO
	SetLastLoginStatus("Logged Off", datapairs[2].data);
#endif
#ifdef CASHPLAY
	if (strlen(_BCInfo.newpin) == 0) {
		  SendBingoGetPin();
	}
#endif
#ifdef LOADTEST
	if (doAutoPlay == 0 && _autoPlay == SDL_FALSE && _logOffAfterGameFlag == SDL_TRUE) {
	  exit(0);
	}
#endif
    }
//#endif
    _saveMetersRequired = SDL_TRUE;
  }
#endif
  else if (strcmp(egmclass->Command,"loginnack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"balance",""},
      {"status",""},		// status = ok, wrongpin, wrongdevice, pinexpired
      {"vnetts", ""},
    };
    int count=4;
    unsigned long long bal;
#ifndef PRODUCTION
    static int debugCnt = 5;
#endif
    
    if (NeedTestLogin == 2) {
	LastTestLoginTime = 0;
	NeedTestLogin = 0;
	return;
    }
    if ((NeedTestLogin == 1) || (DeviceState() == 4) || (DeviceState() == 8)) {		// jackpot lockup or out of service, 1st time after commsOnLine
    	extractDataPairsDelim(egmclass->Data,datapairs,count,':');
	// we are no longer logged in or locked
	int len = strlen("is Locked");
	int len1 = strlen(datapairs[2].data);

	if (strcmp(&datapairs[2].data[len1-len], "is Locked") == 0) {
		fprintf(_debugPort, "still locked\n");
	} else {
		if (OutOfService() == SDL_TRUE) {
			ClearWaiting4GameActivityAck();		// don't send gameActivity, will be nacked
		}
		SetGotUnlock();
	}
	NeedTestLogin = 0;
	LastTestLoginTime = SDL_GetTicks();
	SendKeepAlive(destAddr);
#ifdef notdef1
	fprintf(_debugPort,"ka6 sent\n");
#endif
	return;
    }
    if (bState != BIS_WAIT_LOGIN)  {
	    // ignore if we didn't send a login command, or we already got it and this is a duplicate
	    //ClearLogin();
	    return;
    }
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
#ifdef VICTORYLAND
    if (strcmp(datapairs[0].data, _BCInfo.passport) != 0) {		// loginack for a different passport
	return;								// ignore
    }
#ifdef notdef
    if ((debugCnt > 0) && (_LoginGotPassport == 1) && (strcmp(datapairs[2].data, "Wrong Pin")) == 0) {
	switch (debugCnt--) {
	case 5:
		strcpy(datapairs[2].data, "Card Inactive");
		break;
	case 4:
		strcpy(datapairs[2].data, "Card in use");
		break;
	case 3:
		strcpy(datapairs[2].data, "Card is Locked");
		break;
	case 2:
		strcpy(datapairs[2].data, "Invalid Card");
		break;
	case 1:
		strcpy(datapairs[2].data, "Current Card (000002222) is Locked");
		break;
	}
    }
#endif
    if ((_LoginGotPassport == 1) && (strcmp(datapairs[2].data, "Wrong Pin")==0)) {	// passport is ok
	_LoginGotPassport = 2;
    	SetBingoState(BIS_INACTIVE, -1);
	SetLastActivityTime();
	SetLastStatus2Show("");
    }
    else
#endif
    {
    	SetLastLoginStatus(datapairs[2].data, datapairs[3].data);
    	SetBingoState(BIS_INACTIVE, -1);
    	ClearLogin();
    	IncrLogInFailed();
#ifdef DO_TITO
	rejectTic = 1;
#endif
    }
    _saveMetersRequired = SDL_TRUE;
  }
  else if (strcmp(egmclass->Command,"logoffnack")==0)
  {
#ifdef USE_MAG_CARD
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"balance",""},
      {"status",""},		// status = ok, wrongpin, wrongdevice, pinexpired
      {"vnetts", ""},
    };
    int count=4;
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    //_BCInfo.passport[0] = '\0';
    if (strcmp(datapairs[2].data, "Handpay Locked") == 0) {
	SetBingoState(BIS_LOGOFF_DELAY, -1);
    } else {
    	if (strcmp(datapairs[0].data, _BCInfo.passport) == 0) {
		_GlobalMeters.OOS_handpay_adjust = 0;
    		ClearLogin();
    		_CurrentPlayerAccount = 0;
    		_PlayerAccount = 0;
    		_GlobalMeters.PlayerAccount = 0;
    		_saveMetersRequired = 1;
//#ifdef TABLET
    		if (bState == BIS_WAIT_DEAL) {
			if (_BingoDisconnectState == BDIS_OK)
	    			_BingoDisconnectState = BDIS_DISCONNECT;			// force a cancel and logoff
    		} else if (_BingoDisconnectState != BDIS_OK) {
			_BingoDisconnectState = BDIS_CANCELDEAL_ACKED;
    		} else {
    			ButtonSetState(MSBTN_PRINT,MSBTN_ON);		// this is to allow us to enter config
#ifndef LOADTEST
    			ButtonSetState(MSBTN_HLP_PAY_TBL,MSBTN_ON);		// this is to allow us to see help pages
#endif
    		}
		SetBingoState(BIS_INACTIVE, -1);
	}
    }
    _saveMetersRequired = SDL_TRUE;
#endif
//#endif
  }
  else if (strcmp(egmclass->Command,"start1ack=0")==0)
  {
    if (bState == BIS_WAIT_START1)
      SetBingoState(BIS_GOT_START1NACK, -1);
  }
  else if (strcmp(egmclass->Command,"start1ack=1")==0)
  {
#ifndef BINGOTEST
	if (bState == BIS_CANCELLED)
		fprintf(_debugPort, "start1ack=1, bState=BIS_CANCELLED\n");
	else
		fprintf(_debugPort, "start1ack=1, bState=%d\n", bState);
#endif
    if (bState == BIS_WAIT_START1)
      SetBingoState(BIS_GOT_START1ACK, -1);
  }
  else if (strcmp(egmclass->Command,"start2ack=0")==0)
  {
    if (bState == BIS_WAIT_START2)
      SetBingoState(BIS_GOT_START2NACK, -1);
  }
  else if (strcmp(egmclass->Command,"start2ack=1")==0)
  {
    if (bState == BIS_WAIT_START2)
      SetBingoState(BIS_GOT_START2ACK, -1);
  }
  else if ((strcmp(egmclass->Command,"dealack")==0) || (strcmp(egmclass->Command,"dispenseack")==0))
  {
    DATA_PAIRS datapairs[] = {
      {"gameid",""},
      {"progwin", ""},
    };
    int count=2;
    unsigned long long progAmt = 0;
    unsigned long long gameid;

#ifdef FAKE_DEALNACK
      SetBingoState(BIS_CANCELLED, 0);
      _logOffAfterGameFlag = SDL_TRUE;
      SetLastStatus2Show("Wrong Passport");
      fprintf(_debugPort, "BIS_CANCELLED 6\n");
      return;
#endif
    if ((bState == BIS_WAIT_DEAL) || (_gameState == GS_RUNREELS)) {
      extractDataPairsDelim(egmclass->Data,datapairs,count,':');
      sscanf(datapairs[0].data, "%lld",&gameid);
      if (bState == BIS_WAIT_DEAL) {
      	SetBingoState(BIS_GOT_DEALACK, -1);
	if (_JackPotType == JP_BONUS) {
		if (strlen(datapairs[1].data) > 0)
			sscanf(datapairs[1].data, "%lld", &progAmt);
		if (progAmt > 0) {
        		_GlobalMeters._ProgressiveWin = progAmt;
        		_GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
			fprintf(_debugPort, "dealack: progAmt=%lld\n", progAmt);
		} else {
#ifdef FAKING_MYSTERYJP
			if (GetCurrentMJBetLevel() != -1) {
			  _GlobalMeters._ProgressiveWin = GetCurrentJackpotAmount();
			  _GlobalMeters._ProgressiveWinReceived = SDL_TRUE;
			  fprintf(_debugPort, "FAKING_MYSTERYJP: %lld\n", _GlobalMeters._ProgressiveWin);
			}
#endif
		}
	}
#ifdef FORCE_CNET_DISCONNECT_1
	if (++keepAliveCnt > 5) {
		_BrokenPipe = SDL_TRUE;
		keepAliveCnt = 0;
	}
#endif
      } else {
#ifndef PRODUCTION
	fprintf(_debugPort, "last gameid=%d, gameid=%d\n",_BCInfo.gameid, gameid);
#endif
      }
      _BCInfo.gameid = gameid;
      _saveMetersRequired = SDL_TRUE;
    }
  }
  else if ((strcmp(egmclass->Command,"dealnack")==0) || (strcmp(egmclass->Command,"dispensenack")==0))
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"cardnum",""},
      {"balance",""},
      {"status",""},
    };
    int count=4;
    unsigned long long bal;
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    sscanf(datapairs[2].data, "%lld",&bal);
    fprintf(_debugPort, "dealnack, status=%s\n", datapairs[3].data);
    if ((strcmp(datapairs[3].data, "Logged Off") == 0) 
	|| (strcmp(datapairs[3].data, "Wrong Passport") == 0)
	|| (strcmp(datapairs[3].data, "Invalid Passport") == 0)
	|| (strcmp(datapairs[3].data, "Wrong ServerID") == 0)
	|| (strcmp(datapairs[3].data, "Ticket Error") == 0) ){
      SetBingoState(BIS_CANCELLED, bal);
#ifndef BINGOSAS
      _logOffAfterGameFlag = SDL_TRUE;
#endif
      fprintf(_debugPort, "BIS_CANCELLED 5\n");
      SetLastStatus2Show(datapairs[3].data);
    } else if ((strcmp(datapairs[3].data, "Insufficent Funds") == 0) || ((strcmp(datapairs[3].data, "Insufficient Funds") == 0))){
      SetBingoState(BIS_CANCELLED, bal);
      SetLastStatus2Show("Insufficient Funds");
#ifndef BINGOSAS
      _logOffAfterGameFlag = SDL_TRUE;
#endif
      fprintf(_debugPort, "BIS_CANCELLED 4\n");
    } else
    if (bState == BIS_WAIT_BALLCALL) {
      SetBingoState(BIS_CANCELLED, bal);
      SetLastStatus2Show(datapairs[3].data);
      fprintf(_debugPort, "BIS_CANCELLED 3\n");
    }
    _saveMetersRequired = SDL_TRUE;
  }
  else if (strcmp(egmclass->Command,"cancelled")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"cardnum",""},
      {"balance",""},
    };
    int count=3;
    unsigned long long bal;
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    sscanf(datapairs[2].data, "%lld",&bal);
    if (bState == BIS_WAIT_BALLCALL) {
      fprintf(_debugPort, "BIS_CANCELLED 2\n");
      SetBingoState(BIS_CANCELLED, bal);
    }
    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","cancelled");
  }
  else if(strcmp(egmclass->Command,"ballcall")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},	//0
      {"cardnum",""},	//1
      {"count",""},	//2
      {"balls",""},	//3
      {"gamenum",""},	//4
      {"GEP_WIN",""}	//5
    };
    int count=6;
    int curGepWin;
    long ballsDrawnFirst;
    //extern long ballArray[];
    
    if (_BCInfo.gameid == 0) return;		// game cancelled

    if ((bState != BIS_WAIT_BALLCALL) && (bState != BIS_GOT_DEALACK))  {
	    // ignore if we already got it and this is a duplicate
	    if ((bState == BIS_GOT_RESULT) || (bState == BIS_BALLANIM))
    	    	sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","ballcall");
	    return;
    }
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
#ifndef PICKAPRICE
#ifndef PRODUCTION
#ifdef FAKING_PIZZA_JP
   strcpy(datapairs[5].data, "3250");
   fprintf(_debugPort, "GEP_WIN=%s\n",datapairs[5].data);
    //strcpy(datapairs[3].data, "15,69,2,67,24,55,62,48,68,21,16,75,35,5,14,52,58,3,29,23,44,37,70,27,26,28,56,45");
    strcpy(datapairs[3].data, "30,43,54,71,24,55,62,48,68,21,16,75,35,5,14,52,58,3,29,23,44,37,70,27,26,28,56,45");
   fprintf(_debugPort, "balls=%s\n",datapairs[3].data);
#endif
#endif
#endif
#ifdef FORCING_BONUS5
 #ifdef PIZZA_OR_HARVEST
    strcpy(datapairs[3].data, "45,52,62,1,2,3,4,5,6,7,8,10,11,12,71,54,43,30,13,14,16,17,19,20,21,22,25,26");
 #else
    strcpy(datapairs[3].data, "45,52,72,62,30,43,73,54,71,15,4,5,1,16,17,19,20,21,29,9,22,23,25,26,27,28,30,31");
 #endif
#endif
    sscanf(datapairs[2].data, "%d", &ballsDrawnFirst);
    sscanf(datapairs[5].data, "%d", &curGepWin);
    SetCurrentBingoPrize(curGepWin);
    parseNextChar(datapairs[3].data, _BCInfo.ballArray, ballsDrawnFirst, ',');
//#ifndef FPP
    if (_BCInfo._bingoFPP != 1) 
    {		// First Pattern Paid
	    // we wait till win_amts to set number of balls drawn.
	    SetBallsDrawnGEP(ballsDrawnFirst);
	    ballsDrawnFirst = BALLS_DRAWN;
	    SetBallsDrawnFirst(ballsDrawnFirst);
    }
//#endif
    sscanf(datapairs[4].data, "%lld", &_BCInfo.gamenumber);
#ifdef notdef
    fprintf(_debugPort, "ballcall %s\n",egmclass->Data);
#endif
    if (_BCInfo.gamenumber == 0) {		// not a valid game, no new balls drawn
	    SetBingoDisconnectState(BDIS_DISCONNECT);
    } else {
	    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","ballcall");
    }
    _saveMetersRequired = SDL_TRUE;
  }
#ifdef PULLTAB
  else if(strcmp(egmclass->Command,"ticket")==0)
  {
    DATA_PAIRS datapairs[]={
      {"gameid",""},		//0
      {"formname",""},		//1
      {"dealname",""},		//2
      {"ticknum",""},		//3
      {"price",""},		//4
      {"winamount",""},		//5 total interim prizes
      {"winflag",""},		//6
      {"ticdata",""},		//7
      {"passport",""},		//8
      {"balance",""},		//9
    };
    int count=10;
    int gameid;
    char formname[10];
    char dealname[30];
    unsigned long long ticknum;
    //unsigned long long price;
    int totalWin = 0;
    char winflag[10];
    char ticdata[256];
    char passport[20];
    unsigned long long endBalance;
    extern void SetPullTabPrize(int prize, char *wintype);
    extern void SetPullTabTickData(unsigned char *dealname, unsigned long long ticknum, char *ticdata);

    
    if (_BCInfo.gameid == 0) return;		// game cancelled
    //printf("cabinet : ballcall received\n");
    //if (bState != BIS_WAIT_WINAMT) {
    if ((bState != BIS_GOT_RESULT) && (bState != BIS_WAIT_BALLCALL) && (bState != BIS_GOT_DEALACK)) {
#ifndef PRODUCTION
	    if (_BCInfo.gotWinAmounts == 0) {
			fprintf(_debugPort, "pulltab:ticket, bState=%d\n",bState);
	    }
#endif
	    return;
    }
#ifdef notdef
    fprintf(_debugPort, "ticket:%s\n",egmclass->Data);
#endif
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    sscanf(datapairs[0].data,"%d",&gameid);
    strcpy(formname, datapairs[1].data);
    strcpy(dealname, datapairs[2].data);
    sscanf(datapairs[3].data,"%lld",&ticknum);
    //sscanf(datapairs[4].data,"%lld",&price);
    sscanf(datapairs[5].data,"%d",&totalWin);
    strcpy(winflag, datapairs[6].data);
    strcpy(ticdata, datapairs[7].data);
    strcpy(passport, datapairs[8].data);
    sscanf(datapairs[9].data,"%lld",&endBalance);	// ending balance
//#ifdef LOADTEST1
//    totalWin = 1800;
//    strcpy(winflag, "B5");
//#endif
#ifdef FAKING_LOSER
    totalWin = 0;
    strcpy(winflag, "");
#endif
#ifdef FAKING_F5
    if (totalWin == 0) {
	static int index=0;
	switch (index++) {
	case 0:
		strcpy(winflag, "F3");
		break;
	case 1:
		strcpy(winflag, "F4");
		break;
	case 2:
		strcpy(winflag, "F5");
		break;
	}
	if (index > 2) index = 0;
    }
#endif
    if (endBalance == _GlobalMeters._startMoney) {
	// when connecting to VNet, bet amount is deducted at activity time. Try to work  with both.
	SetBingoStartingBalance(endBalance);
        //endBalance -= _numberOfLinesBet * _creditsPerLine * _Denominations[_currentDenomination];
        endBalance -= GetTotalBet();
    }
    //SetBingoEndingBalance(endBalance+(totalWin*_Denominations[_currentDenomination]));
    SetBingoEndingBalance(endBalance+(totalWin*GetDenomX()));
    SetPullTabPrize(totalWin, winflag);		// interim prize only
    SetPullTabTickData(dealname, ticknum, ticdata);
    //sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","win_amts");
 #ifdef PULLTAB
    if (_BCInfo.WIN_TYPE == WINTYPE_JP) {
	_GlobalMeters._ProgressiveWin = (CNjackpotValues[_currentDenomination+1][_currentBetLevel] / 100);
	//SendProgHitInfo(_GlobalMeters._ProgressiveWin);
    } else {
    	//SendBingoClaim();		// do it in GS_CLAIM
    }
 #endif
    _BCInfo.gotWinAmounts = SDL_TRUE;
    _BCInfo.gotOkToPlay = SDL_FALSE;
    _saveMetersRequired = SDL_TRUE;
  }
#endif
  else if(strcmp(egmclass->Command,"win_amts")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},		//0
      {"cardnum",""},		//1
      {"gamenum",""},		//2
      {"wincount",""},		//3
      {"prizes",""},		//4
      {"totalwin",""},		//5 total interim prizes
      {"balance",""},		//6
      {"bingoprize",""},	//7
      {"numbingowinners",""},	//8
      {"bingowinnerid",""},	//9
      {"ballcount",""},		//10 balls drawn for interim prize
      {"gepballcount", ""},	//11 balls drawn for gep
    };
    int count=12;
    int totalWin;
    int bingoWin;
    long patPrizes[(8+1)*3];
    int winCount;
    int wt;
    char *prizePtr;
    unsigned long long endBalance;
    extern void SetBingoPrize(int prize);
    extern void SetBingoInterimPrize(int prize);
    
    int gepballcount = 0;
    int iballcount = 0;
    
    if (_BCInfo.gameid == 0) return;		// game cancelled
    //printf("cabinet : ballcall received\n");
    //if (bState != BIS_WAIT_WINAMT) {
    if ((bState != BIS_GOT_RESULT) && (bState != BIS_WAIT_BALLCALL) && (bState != BIS_GOT_DEALACK)) {
#ifndef PRODUCTION
	    if (_BCInfo.gotWinAmounts == 0) {
			fprintf(_debugPort, "bingo:win_amts, bState=%d\n",bState);
	    }
#endif
	    if ((bState == BIS_WIN) || (bState == BIS_WAITCLAIM) || (bState == BIS_CLAIM)) {
    		sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","win_amts");
	    }
	    return;
    }
#ifdef notdef
    fprintf(_debugPort, "win_amts:%s\n",egmclass->Data);
#endif
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
#ifndef PICKAPRICE
#ifndef PRODUCTION
#ifdef FAKING_PIZZA_JP
    strcpy(datapairs[7].data, "32");		//bingoprize
    strcpy(datapairs[5].data, "3500");		//totalwin
    strcpy(datapairs[3].data, "3");		//number of winners
    strcpy(datapairs[6].data, "22730");		// ending balance
    strcpy(datapairs[4].data, "3,6,2340,5,28,10,7,4,1150");	//prizes
#ifdef notdef
    strcpy(datapairs[5].data, "10440");		//totalwin
    strcpy(datapairs[3].data, "2");		//number of winners
    strcpy(datapairs[6].data, "22730");		// ending balance
    strcpy(datapairs[4].data, "5,28,10,6,4,10430");	//prizes
#endif
    fprintf(_debugPort, "wincount=%s\n",datapairs[3].data);
    fprintf(_debugPort, "prizes=%s\n",datapairs[4].data);
    fprintf(_debugPort, "totalwin=%s\n",datapairs[5].data);
    fprintf(_debugPort, "balance=%s\n",datapairs[6].data);
    fprintf(_debugPort, "bingoprize=%s\n",datapairs[7].data);
#endif
#endif
#endif
#ifdef FORCING_BONUS5
 #ifdef PICKAPRIZE
    strcpy(datapairs[7].data, "0");		//bingoprize
    {
    //strcpy(datapairs[5].data, "3500");		//totalwin
	char tmpbuf[256];
	sprintf(tmpbuf, "%d", 3000*_creditsPerLine);
	strcpy(datapairs[5].data, tmpbuf);		// totalwin
    }
    strcpy(datapairs[3].data, "3");		//number of winners
    //strcpy(datapairs[6].data, "22730");		// ending balance
    strcpy(datapairs[4].data, "0,20,20,5,4,2340,6,9,640");	//prizes
  #else
    {
    //strcpy(datapairs[5].data, "3500");		//totalwin
	char tmpbuf[256];
	sprintf(tmpbuf, "%d", 750*_creditsPerLine);
	strcpy(datapairs[5].data, tmpbuf);		// totalwin
    }
    strcpy(datapairs[3].data, "2");		//number of winners
    //strcpy(datapairs[6].data, "22730");		// ending balance
    strcpy(datapairs[4].data, "5,4,700,6,18,50");	//prizes
  #endif
#endif
    sscanf(datapairs[7].data,"%d",&bingoWin);		//bingoprize
#ifdef FORCEGEP
    bingoWin = 4;
#endif
    SetBingoPrize(bingoWin);
    sscanf(datapairs[5].data,"%d",&totalWin);		//totalwin
    sscanf(datapairs[3].data,"%d", &winCount);
#ifndef PRODUCTION // faking it
    //if (_GlobalMeters._ProgressiveWin > 0) 
    //  totalWin = 801;
#endif
    sscanf(datapairs[6].data,"%lld",&endBalance);	// ending balance
#ifndef PRODUCTION
 #ifdef FORCING_BONUS5
    endBalance = _GlobalMeters._startMoney;
 #endif
#endif
    if (endBalance == _GlobalMeters._startMoney) {
	// when connecting to VNet, bet amount is deducted at activity time. Try to work  with both.
	SetBingoStartingBalance(endBalance);
        endBalance -= GetTotalBet();
    }
    SetBingoWinCount(winCount);
//#ifdef ATRIB
//    SetBingoEndingBalance(endBalance+(totalWin*GetDenomX()*_GlobalConfig.price)+bingoWin);
//#else
    SetBingoEndingBalance(endBalance+(totalWin*GetDenomX())+bingoWin);
//#endif
    prizePtr = datapairs[4].data;
    parseNext(prizePtr, patPrizes, winCount*3, ',');
#ifdef notdef

    {
	    
	    for (wt=0; wt<count; wt++)
		    fprintf(_debugPort, "%s:%s\n", datapairs[wt].key, datapairs[wt].data);
	    fprintf(_debugPort, "prizes=%s\n",datapairs[4].data);
	    for (wt=0; wt<winCount; wt++) {
		    fprintf(_debugPort, "[%d]%d,%d,%d\n",wt+1,patPrizes[wt*3+0],patPrizes[wt*3+1],patPrizes[wt*3+2]);
	    }
    }
#endif
#ifdef bingo_debug
 #ifndef PRODUCTION
  #ifndef PULLTAB
//    if ((_ExtendedConfig.inDemoMode != 0) && (winCount == 1) && (patPrizes[0+2]>0)) {		// single pattern winner
    if (_ExtendedConfig.inDemoMode != 0) {		// demo mode
	    extern void SetNextDemoGame(long *patPrizes, int *winCount, int *totalWin);
	    
	    SetNextDemoGame(patPrizes, &winCount, &totalWin);
    }
  #endif
 #endif
#endif
    
    if (_BCInfo._bingoFPP == 1) {		// First Pattern Paid
	// we didn't do it at ballcall, do it now.
	sscanf(datapairs[11].data,"%d", &gepballcount);
	SetBallsDrawnGEP(gepballcount);
	//sscanf(datapairs[10].data,"%d", &iballcount);
	//SetBallsDrawnFirst(iballcount);
    }
    SetInterimPrizeInfo((int *)patPrizes, winCount);
    
    SetBingoInterimPrize(totalWin);		// interim prize only
#ifdef notdef
    fprintf(_debugPort, "win_amts %s:%s\n",datapairs[3].key, datapairs[3].data);
#endif
    //sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack","win_amts");
    if ((_JackPotType == JP_BONUS) && (_GlobalMeters._ProgressiveWin > 0)) {
	SendProgHitInfo(_GlobalMeters._ProgressiveWin);
    } else
    if (IsBingoJackpot()) {
	_GlobalMeters._ProgressiveWin = (CNjackpotValues[_currentDenomination+1][_currentBetLevel] / 100);
	SendProgHitInfo(_GlobalMeters._ProgressiveWin);
    } else {
    	//SendBingoClaim();		// do it in GS_CLAIM
    }
#ifdef FORCE_CNET_DISCONNECT_1
	if (++keepAliveCnt > 5 && totalWin > 0) {
		_BrokenPipe = SDL_TRUE;
		keepAliveCnt = 0;
	}
#endif
    _BCInfo.gotWinAmounts = SDL_TRUE;
    _BCInfo.gotOkToPlay = SDL_FALSE;
    _saveMetersRequired = SDL_TRUE;
  }
#ifdef notdef
  else if(strcmp(egmclass->Command,"patterns")==0)
  {
    DATA_PAIRS datapairs[]={
      {"setid",""},
      {"pattern",""},
      {"name",""},
      {"level",""},
    };
	#define	DP_SET_ID	0
	#define DP_PATTERN	1
	#define	DP_NAME		2
	#define DP_PAYLEVEL	3
    
    DATA_PAIRS patternData[] = {
      {"name",""},		// pattern
      {"winamount",""},		// winamount
      {"squares",""},		// squares
    };
    int i,j,k;
    int level;
    unsigned long winAmt[BALLS_DRAWN_MAX];
    unsigned long squares[25];
    int patternNum,subNum;
    unsigned long bitmap;
    int id;
    char buf[64];
    //printf("cabinet : patterns received\n");
    
#define PD_NAME		0
#define	PD_WINAMOUNT	1
#define	PD_SQUARES	2
    
    
    // get number of patterns
#ifdef notdef
  fprintf(_debugPort, "processBingoClass, strlen(egmclass->Data)=%d\n",strlen(egmclass->Data));
#endif
    extractDataPairsDelim(egmclass->Data,datapairs,4,':');
    //sscanf(datapairs[DP_SET_ID].data,"%d",&setid);
    sscanf(datapairs[DP_PAYLEVEL].data,"%d",&level);
    if (level != (paylevel+1)) {
	    fprintf(_debugPort, "requesting setid %d, got %d\n", paylevel+1, level);
    }
#ifdef notdef1
    fprintf(_debugPort, "bingo Pattern, setid=%d, level=%d\n",setid,level);
#endif
    // get info of pattern
	    //sprintf(patternData[DP_PATTERN].key, "pattern%1d",i+1);
	    //sprintf(patternData[DP_WINAMOUNT].key, "winamount%1d",id);
	    //sprintf(patternData[DP_SQUARES].key, "squares%1d",id);
	    extractDataPairsDelim(egmclass->Data, patternData,3,':');
	    patternNum = -1;
	    for (j=0; j<totalBingoPatterns; j++) {
		    if (strcmp(patternData[PD_NAME].data,bingoPatterns[j].name[paylevel]) == 0) {
			    patternNum = j;
			    break;
		    } 
	    }
	    //if (patternNum == -1) {
	    //}
#ifdef notdef
	    for (j=0; j<3; j++) {
		    fprintf(_debugPort, "%s,%s\n",patternData[j].key,patternData[j].data);
	    }
	    fprintf(_debugPort, "patternNum=%d\n",patternNum);
#endif
	    //fprintf(_debugPort, "win amount=%s\n",patternData[PD_WINAMOUNT].data);
	    //sscanf(patternData[PD_WINAMOUNT].data, "%lld", &winAmt);
	    parseNext(patternData[PD_WINAMOUNT].data, winAmt, 28, ',');
	    //fprintf(_debugPort, "squares=%s\n",patternData[PD_SQUARES].data);
	    parseNext(patternData[PD_SQUARES].data, squares, 25, ',');
	    bitmap = 0;
	    for (j=0; j<25; j++) {
		if (squares[j] == 1) {
		    bitmap |= 1 << j;
		}
	    } 
#ifdef notdef1
	    fprintf(_debugPort, "winAmt=%lld,bitmap=%08x\n",winAmt, bitmap);
#endif
	    if (patternNum == -1) {
		needPatterns = 0;
		patternNum = totalBingoPatterns;
		//fprintf(_debugPort, "%s:patternNum=%d, paylevel=%d\n",patternData[PD_NAME].data, patternNum, paylevel);
		bingoPatterns[patternNum].count[paylevel] = 0;
	    	strcpy(bingoPatterns[patternNum].name[paylevel], patternData[PD_NAME].data);
	    	bingoPatterns[patternNum].winamount[paylevel][0] = 0;
		for (k=0; k<BALLS_DRAWN; k++) {
	    		bingoPatterns[patternNum].winamount[paylevel][k+1] = winAmt[k];
#ifdef notdef
			if (get1ScreenNumber(winAmt[k]) == -1) {
				fprintf(_debugPort, "pattern %d paylevel %d inx=%d win amount %d\n", patternNum, paylevel, k, winAmt[k]); 
			}
#endif
		}
	    	//parseNext(patternData[DP_SQUARES].data, squares, 25, ',');
	    	bingoPatterns[patternNum].squaresBitmap[paylevel][bingoPatterns[patternNum].count[paylevel]] = bitmap;
		bingoPatterns[patternNum].count[paylevel]++;
		subNum = 0;
	    } else {
	    	bingoPatterns[patternNum].winamount[paylevel][0] = 0;
		for (k=0; k<BALLS_DRAWN; k++) {
			if (winAmt[k] != bingoPatterns[patternNum].winamount[paylevel][k+1]) {
				//fprintf(_debugPort, "!!! %d: winAmt=%lld, winamount=%lld\n", k, winAmt[k], bingoPatterns[patternNum].winamount[paylevel][k+1]);
				bingoPatterns[patternNum].winamount[paylevel][k+1] = winAmt[k];
			}
		}
		subNum = -1;
		for (j=0; j<bingoPatterns[patternNum].count[paylevel]; j++) {
			if (bingoPatterns[patternNum].squaresBitmap[paylevel][j] == bitmap) {		// already in table?
				subNum = j;
				break;
			}
		}
		if (subNum == -1) {
			subNum = bingoPatterns[patternNum].count[paylevel]++;
			bingoPatterns[patternNum].squaresBitmap[paylevel][subNum] = bitmap;
		}
		
	    }
#ifdef notdef
	    fprintf(_debugPort, "pattern %s: \n   winamount=%lld,squares=%x\n", bingoPatterns[patternNum].name[paylevel], 
		    bingoPatterns[patternNum].winamount[paylevel], bingoPatterns[patternNum].squaresBitmap[paylevel][subNum]);
#endif
	    if (totalBingoPatterns < 8) {
		if (++paylevel == 5) {
			paylevel = 0;
			++totalBingoPatterns;
		}
	    } else if (totalBingoPatterns < 20) {
		++totalBingoPatterns;
	    } 
	    if (totalBingoPatterns >= 20) {
		bingoPatternsDone = SDL_TRUE;
		if (totalBingoPatterns == 20)
		PrizeListAdjust();
#ifdef BINGOSAS
		if (_BCInfo.cardnum == 0) {
			SetBingoState(BIS_SEND_CARD, -1);
		}
#endif
	    }
	    //fprintf(_debugPort, "totalBingoPatterns=%d,paylevel=%d\n",totalBingoPatterns, paylevel);
    sprintf(buf,"pattern=%s",datapairs[DP_PATTERN].data),
    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack",buf);
    //if (totalBingoPatterns < 20) {
    if (totalBingoPatterns < (_BCInfo.numiPatterns + _BCInfo.numgPatterns)) {					    
	sprintf(buf,"pattern=%d,alllevels=1", totalBingoPatterns+1);
	//fprintf(_debugPort, "%s\n",buf);
	sendClass(sockfd,destAddr,"bingo",_TheEgmID,"getpatterns",buf);
    } else {
	SendKeepAlive(destAddr);
#ifdef notdef1
	fprintf(_debugPort,"ka7 sent\n");
#endif
    }
  }
#endif
#ifdef nomore
  else if(strcmp(egmclass->Command,"patterns")==0)
  {
    DATA_PAIRS datapairs[]={
      {"setid",""},
    };
	#define	DP_SET_ID	0
	//#define DP_PATTERN	1
	//#define	DP_NAME		2
    
    DATA_PAIRS patternData1[] = {
      {"level1",""},		// level
      {"name1",""},
      {"winamount1",""},	// winamount
      {"squares1",""},		// squares
    };
    DATA_PAIRS patternData2[] = {
      {"level2",""},		// level
      {"name2",""},
      {"winamount2",""},	// winamount
      {"squares2",""},		// squares
    };
    DATA_PAIRS patternData3[] = {
      {"level3",""},		// level
      {"name3",""},
      {"winamount3",""},	// winamount
      {"squares3",""},		// squares
    };
    DATA_PAIRS patternData4[] = {
      {"level4",""},		// level
      {"name4",""},
      {"winamount4",""},	// winamount
      {"squares4",""},		// squares
    };
    DATA_PAIRS patternData5[] = {
      {"level5",""},		// level
      {"name5",""},
      {"winamount5",""},	// winamount
      {"squares5",""},		// squares
    };
    int i,j,k,l;
    int level;
    unsigned long winAmt[BALLS_DRAWN_MAX];
    unsigned long squares[25];
    int patternNum,subNum;
    unsigned long bitmap;
    int id;
    char buf[64];
    DATA_PAIRS *pd;
    //printf("cabinet : patterns received\n");
    
#define PD_LEVEL	0
#define	PD_NAME		1
#define	PD_WINAMOUNT	2
#define	PD_SQUARES	3
    
    
    // get number of patterns
#ifdef notdef
  fprintf(_debugPort, "processBingoClass, strlen(egmclass->Data)=%d\n",strlen(egmclass->Data));
#endif
    extractDataPairsDelim(egmclass->Data,datapairs,3,':');
    // get info of pattern
    patternNum = -1;
    pd = &patternData1[0];
    extractDataPairsDelim(egmclass->Data, pd,4,':');
    for (j=0; j<totalBingoPatterns; j++) {
      if (strcmp(pd[PD_NAME].data,bingoPatterns[j].name[0]) == 0) {
      patternNum = j;
      break;
      }
    }
#ifdef notdef
    fprintf(_debugPort, "patternNum=%d\n",patternNum);
#endif
    if (patternNum == -1) {
      needPatterns = 0;
      patternNum = totalBingoPatterns;
      //fprintf(_debugPort, "%s:patternNum=%d, paylevel=%d\n",patternData[PD_NAME].data, patternNum, paylevel);
      for (l=0; l<5; l++)
	bingoPatterns[patternNum].count[l] = 0;
    }
    for (l=0; l<5; l++) {
      switch (l) {
	case 0:
	  pd = &patternData1[0];
	  break;
	case 1:
	  pd = &patternData2[0];
	  break;
	case 2:
	  pd = &patternData3[0];
	  break;
	case 3:
	  pd = &patternData4[0];
	  break;
	case 4:
	  pd = &patternData5[0];
	  break;
      }
      extractDataPairsDelim(egmclass->Data, pd,4,':');
   //sscanf(datapairs[DP_SET_ID].data,"%d",&setid);
      if (strlen(pd[PD_LEVEL].data) == 0) {
	// no data for this level
	break;
      }
      sscanf(pd[PD_LEVEL].data,"%d",&level);
      if (level != (l+1)) {
	fprintf(_debugPort, "requesting setid %d, got %d\n", l+1, level);
      }
#ifdef notdef1
      fprintf(_debugPort, "bingo Pattern, setid=%d, level=%d\n",setid,level);
#endif
#ifdef notdef
      for (j=0; j<3; j++) {
	fprintf(_debugPort, "%s,%s\n",pd[j].key,pd[j].data);
      }
#endif
      strcpy(bingoPatterns[patternNum].name[level], pd[PD_NAME].data);
      parseNext(pd[PD_WINAMOUNT].data, winAmt, 28, ',');
      //fprintf(_debugPort, "squares=%s\n",pd[PD_SQUARES].data);
      parseNext(pd[PD_SQUARES].data, squares, 25, ',');
      bitmap = 0;
      for (j=0; j<25; j++) {
	if (squares[j] == 1) {
	  bitmap |= 1 << j;
	}
      } 
#ifdef notdef1
      fprintf(_debugPort, "winAmt=%lld,bitmap=%08x\n",winAmt, bitmap);
#endif
      bingoPatterns[patternNum].winamount[level][0] = 0;
      for (k=0; k<BALLS_DRAWN; k++) {
	if (winAmt[k] != bingoPatterns[patternNum].winamount[level][k+1]) {
	  //fprintf(_debugPort, "!!! %d: winAmt=%lld, winamount=%lld\n", k, winAmt[k], bingoPatterns[patternNum].winamount[level][k+1]);
	  bingoPatterns[patternNum].winamount[level][k+1] = winAmt[k];
	  }
	}
	subNum = -1;
	for (j=0; j<bingoPatterns[patternNum].count[level]; j++) {
	  if (bingoPatterns[patternNum].squaresBitmap[level][j] == bitmap) {		// already in table?
	    subNum = j;
	    break;
	  }
	}
	if (subNum == -1) {
	  subNum = bingoPatterns[patternNum].count[level]++;
	  bingoPatterns[patternNum].squaresBitmap[level][subNum] = bitmap;
	}
		
    }
    sprintf(buf,"pattern=%s",bingoPatterns[patternNum].name[0]),
    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack",buf);
    ++totalBingoPatterns;
    if (totalBingoPatterns >= (_BCInfo.numiPatterns + _BCInfo.numgPatterns)) {
	bingoPatternsDone = SDL_TRUE;
#ifdef BINGOSAS
	if (_BCInfo.cardnum == 0) {
	  SetBingoState(BIS_SEND_CARD, -1);
	}
#endif
	SendKeepAlive(destAddr);
#ifdef notdef1
	fprintf(_debugPort,"ka7 sent\n");
#endif
    } else {
	sprintf(buf,"pattern=%d,alllevels=1", totalBingoPatterns+1);
	//fprintf(_debugPort, "%s\n",buf);
	sendClass(sockfd,destAddr,"bingo",_TheEgmID,"getpatterns",buf);
    }
  }
#endif
  else if (strcmp(egmclass->Command,"canceldealack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"cardnum",""},
      {"balance",""},
    };
    int count=3;
    unsigned long long bal;
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    sscanf(datapairs[2].data, "%lld",&bal);
    if (bState == BIS_WAIT_BALLCALL || bState == BIS_GOT_RESULT) {
      fprintf(_debugPort, "canceldealack: bal=%lld, _CurrentPlayerAccount=%lld\n", bal, _CurrentPlayerAccount);
      SetBingoDisconnectState(BDIS_CANCELDEAL_ACKED);
      SetBingoState(BIS_CANCELLED, bal);
    }
  }
  else if (strcmp(egmclass->Command,"reconnectack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
      {"cardnum",""},
      {"balance",""},
    };
    int count=3;
    unsigned long long bal;
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    sscanf(datapairs[2].data, "%lld",&bal);
    if (_BingoDisconnectState == BDIS_RECONNECT_SEND) {
      SetBingoDisconnectState(BDIS_RECONNECT_ACKED);
    }
  }
  else if (strcmp(egmclass->Command,"historyack")==0)
  {
    DATA_PAIRS datapairs[]={
      {"gameid",""},
      {"inx",""},
    };
    int count=2;
    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    //sscanf(datapairs[0].data, "%lld",&gameid);
    //sscanf(datapairs[1].data, "%lld",&inx);
    LastHistoryTime = 0;
    ClearWaiting4HistoryAck();		// clear waiting for history ack flag
    //if (bonusInfo.waiting4GAack & 1) {		// activity waiting to go out.
	//SendKeepAlive(destAddr);
    //}
    _saveMetersRequired = SDL_TRUE;
  }
  else if (strcmp(egmclass->Command,"forcelogoff")==0)
  {
    DATA_PAIRS datapairs[]={
      {"passport",""},
    };
    int count=1;
    char flobuf[64];
    
    //printf("cabinet : ballcall received\n");
#ifdef LOADTEST
    {
	extern int doAutoPlay;
	doAutoPlay = 0;
	_autoPlay = SDL_FALSE;
	fprintf(_debugPort, "forcelogoff 1\n");
    }
#endif

    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    if (strcmp(_BCInfo.passport, datapairs[0].data) == 0) {
      _logOffAfterGameFlag = SDL_TRUE;
      if (GameLocked() == SDL_TRUE)
	strcpy(flobuf, "status=locked");
      else if ((_gameState == GS_RUNREELS) || (_gameState == GS_RUNREELS_DONE))
	strcpy(flobuf, "status=busy");
      else
	strcpy(flobuf, "status=ok");
    } else {
	strcpy(flobuf, "status=not logged in");
	SendForceBingoLogoff(datapairs[0].data);
    }
    sendClass(sockfd,destAddr,acctStr,_TheEgmID,"forcelogoffack",flobuf);
    _saveMetersRequired = SDL_TRUE;
  }
  else if (strcmp(egmclass->Command,"getnewpinack") == 0)
  {
#ifdef CASHPLAY
    DATA_PAIRS datapairs[]={
      {"newpin",""},
    };
    int count=1;
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    strcpy(_BCInfo.newpin, datapairs[0].data);
    fprintf(_debugPort, "getnewpinack: newpin=%s\n", _BCInfo.newpin);
    _BCInfo.checkSum = calcBingoInfoChecksum();
    WriteLog("BingoInfo", (char *)&_BCInfo, sizeof(BingoCardInfo), 0);
#endif
  }
  else if (strcmp(egmclass->Command,"getnewpinnack") == 0)
  {
#ifdef CASHPLAY
    DATA_PAIRS datapairs[]={
      {"status",""},
    };
    int count=1;
    char status[256];
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    strcpy(status, datapairs[0].data);
    fprintf(_debugPort, "getnewpinNack: status=%s\n", status);
#endif
  }
  else if (strcmp(egmclass->Command,"registerack") == 0)
  {
  }
  else if (strcmp(egmclass->Command,"registernack") == 0)
  {
  }
  else if (strcmp(egmclass->Command,"regclearassetack") == 0)
  {
  }
  else if (strcmp(egmclass->Command,"regclearassetnack") == 0)
  {
  }
 #ifdef SEPARATE_FREQ
  else if (strcmp(egmclass->Command,"setBingoPaytable")==0)
  {
    DATA_PAIRS datapairs[]={
      {"ProgGroup",""},		//0
      {"Paylevel1",""},		//1
      {"Paylevel2",""},
      {"Paylevel3",""},
      {"Paylevel4",""},
      {"Paylevel5",""},		//5
      {"numBalls",""},		//6
      {"Name",""},		//7
      {"frequency",""},		//8
      {"JPEntries",""},		//9
      {"numiBalls",""},		//10
      {"numgBalls",""},		//11
      {"numiPatterns",""},	//12
      {"numgPatterns",""},	//13
      {"allPatternsPay",""},	//14 1=all interim prizes paid, 0=highest paid
      {"paytName",""},		//15 paytable file name
      {"paytCheck",""},		//16 paytable file checksum
      {"patName",""},		//17 pattern file name
      {"patCheck",""},		//18 pattern file checksum
      {"patGEPName",""},	//19 GEP pattern file name (not used)
      {"patGEPCheck",""},	//20 GEP pattern file checksum (not used)
      {"fpp",""},		//21 First Interim Pattern paid
      
    };
#define	BPT_PROGGROUP	0
#define	BPT_PAYLEVEL	1
#define	BPT_NUMBALLS	6
#define	BPT_NAME	7
#define	BPT_FREQ	8
#define	BPT_JPENTRIES	9
#define	BPT_NUMIBALLS	10
#define	BPT_NUMGBALLS	11
#define	BPT_NUMIPATTERNS	12
#define	BPT_NUMGPATTERNS	13
#define BPT_ALLPATPAY	14
#define	BPT_PAY_TABLE_NAME	15
#define	BPT_PAY_TABLE_SUM	16
#define	BPT_PAT_NAME	17
#define	BPT_PAT_SUM	18
#define	BPT_PAT_GEP_NAME	19
#define	BPT_PAT_GEP_SUM	20
#define	BPT_FPP		21

    int count=22;
    unsigned long jpData[26];
    int i,j;
    int level;
    int frequency;
    char buf[512];
    int val;
    
    useSeparateFreq = SDL_TRUE;

    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    for (j=0; j<5; j++) {
	if (strlen(datapairs[j+BPT_PAYLEVEL].data) > 0) {
		level = j;
    		sscanf(datapairs[j+BPT_PAYLEVEL].data, "%d",&_BCPayInfo[level].bingoPayNum);
	}
    }
    parseNext(datapairs[BPT_JPENTRIES].data, jpData, 26, ',');
    j = jpData[0];
    _BCPayInfo[level].jpEntryCount = j;
    if (j > 0) {
    	for (i=0; i<j; i++) {
    		_BCPayInfo[level].jpData[i][0] = jpData[i*2+1];
    		_BCPayInfo[level].jpData[i][1] = jpData[i*2+2];
		fprintf(_debugPort, "pattern %d balls %d\n", jpData[i*2+1], jpData[i*2+2]);
    	}
    }
    if (strlen(datapairs[BPT_NUMBALLS].data) > 0) {
    	sscanf(datapairs[BPT_NUMBALLS].data, "%d",&_BCPayInfo[level].numBalls);
	_BCInfo.balls_drawn = _BCPayInfo[level].numBalls;
    } else {
    	sscanf(datapairs[BPT_NUMIBALLS].data, "%d",&_BCPayInfo[level].numiBalls);
    	sscanf(datapairs[BPT_NUMGBALLS].data, "%d",&_BCPayInfo[level].numgBalls);
#ifdef FAKE28GEP
	_BCPayInfo[level].numgBalls = 28;
#endif
    	sscanf(datapairs[BPT_NUMIPATTERNS].data, "%d",&_BCPayInfo[level].numiPatterns);
    	sscanf(datapairs[BPT_NUMGPATTERNS].data, "%d",&_BCPayInfo[level].numgPatterns);
	sscanf(datapairs[BPT_ALLPATPAY].data, "%d", &val);
	_BCPayInfo[level].allPatternsPay = (unsigned char)val;
    	sscanf(datapairs[BPT_FPP].data, "%d",&val);
    	_BCPayInfo[level].fpp = (unsigned char)val;
	if (level == 0) {
//#ifdef FPP
//		_BCInfo.numiBalls = 67;
//#else
		_BCInfo.numiBalls = _BCPayInfo[level].numiBalls;
//#endif
		//_BCInfo.numgBalls = _BCPayInfo[level].numgBalls;
		_BCInfo.numgPatterns = _BCPayInfo[level].numgPatterns;
		_BCInfo.balls_drawn = _BCInfo.numiBalls;
		BALLS_DRAWN = _BCInfo.balls_drawn;
		IBALLS_DRAWN = _BCInfo.numiBalls;
		//if (_BCPayInfo[level].allPatternsPay != _BCInfo.allPatternsPay) {
		//}
	}
//#ifdef FPP
//	_BCInfo.numiPatterns[level] = 9;
//#else
	_BCInfo.numiPatterns[level] = _BCPayInfo[level].numiPatterns;
//#endif
//#ifndef FPP
	strcpy(&_BCPayInfo[level].PayName[0], datapairs[BPT_PAY_TABLE_NAME].data);
	strcpy(&_BCPayInfo[level].PayCheck[0], datapairs[BPT_PAY_TABLE_SUM].data);
	strcpy(&_BCPayInfo[level].PatName[0], datapairs[BPT_PAT_NAME].data);
	strcpy(&_BCPayInfo[level].PatCheck[0], datapairs[BPT_PAT_SUM].data);
	strcpy(&_BCPayInfo[level].PatGEPName[0], datapairs[BPT_PAT_GEP_NAME].data);
	strcpy(&_BCPayInfo[level].PatGEPCheck[0], datapairs[BPT_PAT_GEP_SUM].data);
	if (PayLoaded[level] == 3) // got invalid response
		PayLoaded[level] = 0;
	if ((strcmp(&_BCPayInfo[level].PayName[0], _BCInfo.PayName[level]) != 0) || 
	  (strcmp(&_BCPayInfo[level].PayCheck[0], _BCInfo.PayCheck[level]) != 0)) {
	  strcpy(_BCInfo.PayCheck[level], &_BCPayInfo[level].PayCheck[0]);
	  strcpy(_BCInfo.PayName[level], &_BCPayInfo[level].PayName[0]);
	  PayLoaded[level] = 0;		// force reload
	}
	if (PatLoaded[level] == 3) // got invalid response
		PatLoaded[level] = 0;
	if ((strcmp(&_BCPayInfo[level].PatName[0], _BCInfo.PatName[level]) != 0) || 
	  (strcmp(&_BCPayInfo[level].PatCheck[0], _BCInfo.PatCheck[level]) != 0)) {
	  strcpy(_BCInfo.PatCheck[level], &_BCPayInfo[level].PatCheck[0]);
	  strcpy(_BCInfo.PatName[level], &_BCPayInfo[level].PatName[0]);
	  PatLoaded[level] = 0;		// force reload
	}
//#endif
    }
    if (strlen(datapairs[BPT_NAME].data) > 0) {
	strcpy(buf, datapairs[BPT_NAME].data);
	fprintf(_debugPort, "len=%d, Name=%s\n", strlen(datapairs[BPT_NAME].data), buf);
    	strcpy(_BCPayInfo[level].Name, datapairs[BPT_NAME].data);
    }
//#ifdef notyet	// this is not correct yet. Wait for phase2
    if (strlen(datapairs[BPT_FREQ].data) > 0) {
    	sscanf(datapairs[BPT_FREQ].data, "%d",&_BCPayInfo[level].frequency);
    }
//#endif
    fprintf(_debugPort, "Name=%s, Paylevel%d=%d, numBalls=%d, frequency=%d, jpEntryCount = %d\n",
	_BCPayInfo[level].Name, level+1, _BCPayInfo[level].bingoPayNum,
	_BCPayInfo[level].numBalls, _BCPayInfo[level].frequency,
	_BCPayInfo[level].jpEntryCount);

    sprintf(buf, "setBingoPaytable:Paylevel%d=%d", level+1, _BCPayInfo[level].bingoPayNum);
    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack",buf);

  }
 #endif
#ifdef PULLTAB
  else if (strcmp(egmclass->Command,"setPulltabForms")==0)
  {
    DATA_PAIRS datapairs[]={
      {"Paylevel1",""},		//0
      {"Paylevel2",""},
      {"Paylevel3",""},
      {"Paylevel4",""},
      {"Paylevel5",""},		//4
      {"Name",""},		//5
      {"dealSize",""},		//6
      {"topBonusPrize",""},	//7
      {"price",""},		//8
    };
#define	PT_PAYLEVEL	0
#define	PT_NAME		5
#define	PT_DEALSIZE	6
#define	PT_TOPBONUSPRIZE	7
#define PT_PRICE	8

    int count=9;
    int i,j;
    int level;
    char buf[512];
    int dealsize;
    
    //useSeparateFreq = SDL_TRUE;

    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    for (j=PT_PAYLEVEL; j<(PT_PAYLEVEL+5); j++) {
	if (strlen(datapairs[j+PT_PAYLEVEL].data) > 0) {
		level = j;
    		sscanf(datapairs[j+PT_PAYLEVEL].data, "%d",&_PTInfo[level].pulltabNum);
		//fprintf(_debugPort, "%s:%s\n", datapairs[j+PT_PAYLEVEL].key, datapairs[j+PT_PAYLEVEL].data);
	}
    }
    strcpy(_PTInfo[level].Name, datapairs[PT_NAME].data);
    sscanf(datapairs[PT_PRICE].data, "%d", &_PTInfo[level].price);
    sscanf(datapairs[PT_DEALSIZE].data, "%d", &_PTInfo[level].dealSize);
    sscanf(datapairs[PT_TOPBONUSPRIZE].data, "%d", &_PTInfo[level].topBonusPrize);
    dealsize = _PTInfo[level].dealSize;
    sprintf(buf, "setPulltabForms:Paylevel%d=%d", level+1, _PTInfo[level].pulltabNum);
    sendClass(sockfd,destAddr,"pulltab",_TheEgmID,"pulltaback",buf);
    if ((_PTInfo[level].topBonusPrize / _PTInfo[level].price) > TopBonusPrizeX) {
	TopBonusPrizeX = _PTInfo[level].topBonusPrize / _PTInfo[level].price;
    }
    if (level == 0) {
	SetLowestBet(_PTInfo[level].price * _Denominations[0]);
    }

  }
  else if (strcmp(egmclass->Command,"eventlogack")==0)
  {
    	DATA_PAIRS datapairs[]={
      		{"eventnum",""},		//0
      		{"status",""},
    	};

    	int count=2;
    	unsigned long long eventNum = 0;
    
	extractDataPairsDelim(egmclass->Data,datapairs,count,':');
	fprintf(_debugPort, "eventlogack(%s)\n", egmclass->Data);
	sscanf(datapairs[0].data, "%lld", &eventNum);
	eventNum -= (_GlobalConfig.assetID * 10000000000ull);
	ClearLastEvent(eventNum);
	ResendEvent(); 	// send next event, if any
  }
  else if (strcmp(egmclass->Command,"eventlognack")==0)
  {
    	DATA_PAIRS datapairs[]={
      		{"eventnum",""},		//0
      		{"status",""},
    	};

    	int count=2;
    	unsigned long long eventNum = 0;
    
	extractDataPairsDelim(egmclass->Data,datapairs,count,':');
	fprintf(_debugPort, "eventlognack(%s)\n", egmclass->Data); 
	sscanf(datapairs[0].data, "%lld", &eventNum);
	ClearLastEvent(eventNum);
	eventNum -= (_GlobalConfig.assetID * 10000000000ull);
	ResendEvent(); 			// send next event, if any
  }
 #endif
 #ifndef PULLTAB
  else if (strcmp(egmclass->Command,"setBingoBonusFreespins")==0)
  {
#if !defined(ATRIB) && !defined(ATRIB2)
    DATA_PAIRS datapairs[]={
      {"ProgGroup",""},		//0
      {"Paylevel1",""},		//1
      {"Paylevel2",""},
      {"Paylevel3",""},
      {"Paylevel4",""},
      {"Paylevel5",""},		//5
      {"B3",""},		//6
      {"B4",""},		//7
      {"B5",""},		//8
      {"F3",""},		//9
      {"F4",""},		//10
      {"F5",""},		//11
    };
#define	BBF_PROGGROUP	0
#define	BBF_PAYLEVEL	1
#define BBF_B3		6
#define BBF_B4		7
#define BBF_B5		8
#define BBF_F3		9
#define BBF_F4		10
#define BBF_F5		11

    int count=12;
    unsigned long b3[3];
    unsigned long b4[3];
    unsigned long b5[3];
    unsigned long f3[3];
    unsigned long f4[3];
    unsigned long f5[3];
    int i,j;
    int level;
    char buf[512];
    extern int bonus_fs_limits[5*6][3];

    //printf("cabinet : ballcall received\n");
    extractDataPairsDelim(egmclass->Data,datapairs,count,':');
    for (j=0; j<5; j++) {
	if (strlen(datapairs[j+BPT_PAYLEVEL].data) > 0) {
		level = j;
#ifndef MLSKIN
    		sscanf(datapairs[j+BPT_PAYLEVEL].data, "%d",&_BCPayInfo[level].bingoPayNum);
#endif
	}
    }
#ifndef MLSKIN
    parseNext(datapairs[BBF_B3].data, b3, 3, ',');
    parseNext(datapairs[BBF_B4].data, b4, 3, ',');
    parseNext(datapairs[BBF_B5].data, b5, 3, ',');
    parseNext(datapairs[BBF_F3].data, f3, 3, ',');
    parseNext(datapairs[BBF_F4].data, f4, 3, ',');
    parseNext(datapairs[BBF_F5].data, f5, 3, ',');

    for (j=0; j<3; j++) {
	bonus_fs_limits[level*6][j] = b3[j];
	bonus_fs_limits[level*6+1][j] = b4[j];
	bonus_fs_limits[level*6+2][j] = b5[j];
	bonus_fs_limits[level*6+3][j] = f3[j];
	bonus_fs_limits[level*6+4][j] = f4[j];
	bonus_fs_limits[level*6+5][j] = f5[j];
    }
#endif
    sprintf(buf, "setBingoBonusFreespins:Paylevel%d=%d", level+1, _BCPayInfo[level].bingoPayNum);
    sendClass(sockfd,destAddr,"bingo",_TheEgmID,"bingoack",buf);

#ifndef PRODUCTION
#ifdef notdef
    for (i=0; i<5; i++) {
	fprintf(_debugPort, "bet level %1d\n", i);
	fprintf(_debugPort, "B3 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6][0], bonus_fs_limits[level*6][1], bonus_fs_limits[level*6][2]);
 	fprintf(_debugPort, "B4 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6+1][0], bonus_fs_limits[level*6+1][1], bonus_fs_limits[level*6+1][2]);
	fprintf(_debugPort, "B5 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6+2][0], bonus_fs_limits[level*6+2][1], bonus_fs_limits[level*6+2][2]);
	fprintf(_debugPort, "F3 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6+3][0], bonus_fs_limits[level*6+3][1], bonus_fs_limits[level*6+3][2]);
	fprintf(_debugPort, "F4 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6+4][0], bonus_fs_limits[level*6+4][1], bonus_fs_limits[level*6+4][2]);
	fprintf(_debugPort, "F5 freq=%d, limits=%d,%d\n", bonus_fs_limits[level*6+5][0], bonus_fs_limits[level*6+5][1], bonus_fs_limits[level*6+5][2]);
   }
#endif
#endif
#endif 
  }
 #endif
	else if (strcmp(egmclass->Command, "eventlogack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"eventnum",""},
			{"status",""},
		};

		int count = 2;
		unsigned long long eventNum = 0;

		extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		sscanf(datapairs[0].data, "%lld", &eventNum);
		eventNum -= (_GlobalConfig.assetID * 10000000000ull);
		ClearLastEvent(eventNum);
		ResendEvent();		// send next event, if any
	} else  if (strcmp(egmclass->Command, "eventlognack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"eventnum",""},
			{"status",""},
		};

		int count = 2;
		unsigned long long eventNum = 0;

		extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		sscanf(datapairs[0].data, "%lld", &eventNum);
		eventNum -= (_GlobalConfig.assetID * 10000000000ull);
		ClearLastEvent(eventNum);
		ResendEvent();		// send next event, if any
	} else if (strcmp(egmclass->Command, "getfileack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"fn",""},
		};

		int count = 1;
		int lev;
		char buf[1024];
		char filenamebuf[1024];
		char *cptr;
		
		//extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		cptr = egmclass->Data;
		while (*cptr++ != '\\');
		parseNextStr(cptr, filenamebuf, 1, ':');
		cptr = filenamebuf + strlen(filenamebuf);
		while (*cptr != '\\') {
		  --cptr;
		}
		++cptr;
		
#ifndef THUMB 
		FILE *fd;
		
		sprintf(buf, "/nvpt/%s", cptr);
		if (fd = fopen(buf, "r")) {	// file exists
			fclose(fd);
			sprintf(buf, "sudo /bin/rm -f ./nvpt/%s\n", cptr);
			fprintf(_debugPort, buf);
			system(buf);
			//sprintf(buf, "sudo /bin/mv -f /nvpt/%s ./nvpt/\n", cptr);
			sprintf(buf, "sudo /bin/cp /nvpt/%s ./nvpt/\n", cptr);
			fprintf(_debugPort, buf);
			system(buf);
		}
#endif
		for (lev=0; lev<5; lev++) {
			if (strcmp(_BCInfo.PatName[lev], cptr) == 0) {
			    PatLoaded[lev] = 2;		// ftp transfer successful
			    break;
			} else if (strcmp(_BCInfo.PayName[lev], cptr) == 0) {
			    PayLoaded[lev] = 2;		// ftp transfer successful
			    break;
			}
		}
		
                _keepAliveSent = SDL_FALSE;                             // Tell the scheduler we received the keepaliveack
                _KeepAliveTick = keepAliveInterval - 2000;		//3000;
	} else if (strcmp(egmclass->Command, "getfilenack") == 0)
	{
		DATA_PAIRS datapairs[] = {
			{"fn",""},
		};

		int count = 1;
		int lev;
		extractDataPairsDelim(egmclass->Data, datapairs, count, ':');
		for (lev=0; lev<5; lev++) {
			if (strcmp(_BCInfo.PatName[lev], datapairs[0].data) == 0) {
			    PatLoaded[lev] = 3;		// ftp transfer unsuccessful
			    break;
			} else if (strcmp(_BCInfo.PayName[lev], datapairs[0].data) == 0) {
			    PayLoaded[lev] = 3;		// ftp transfer unsuccessful
			    break;
			}
		}
                _keepAliveSent = SDL_FALSE;                             // Tell the scheduler we received the keepaliveack
                _KeepAliveTick = keepAliveInterval - 2000;		//3000;
		
	}
  else
    processBadClass(sockfd,destAddr,egmclass);

}
#endif


//			setDeviceState	voucherStatusInfo
//			getVoucherStatus	voucherStatusInfo
//			setLockOut	voucherStatusInfo

//			setVoucherConfig	voucherConfig
//			getVoucherLogStatus	voucherLogStatus
//			getVoucherLog	voucherLogList



// char *enableMoneyIn;
//  char *enableMoneyOut;
//
//  //char buf[256];
//  char buf[SNPRINTF_LIMIT+1];
//
//  snprintf(buf,SNPRINTF_LIMIT,"%s:%s:%s:%s:%s:",Class,EgmID,getTimeStamp(),Command,Data);
//  
//  
//  if(_CabinetSetEnableGamePlay==SDL_TRUE)         //egmEnabled & enableGamePlay & egmState should always be the same
//    egmEnabled=_stringTrue;
//  else
//    egmEnabled=_stringFalse;



SDL_bool _VoucherHostEnabled=SDL_TRUE;
SDL_bool _VoucherEgmEnabled=SDL_TRUE;
SDL_bool _VoucherHostLocked=SDL_FALSE;
SDL_bool _VoucherEgmLocked=SDL_FALSE;
char _VoucherLockText[128]="";
long _VoucherLockTimeout=0;
char _VoucherDisableText[128]="";

//hostEnabled=true,egmEnabled=true,egmLocked=false:hostLocked=false
//
//"voucher:WGSC00001:20040316184627432:setLockOut:lockOut=true,lockText=Game is Temporarily Out of Service,lockTimeOut=3600000:<CR>"
void sendVoucherStatu(int sockfd,struct sockaddr *destAddr)
{
char *hostEnabled;
char *egmEnabled;
char *hostLocked;
char *egmLocked;
char buf[SNPRINTF_LIMIT+1];

  
 if(_VoucherHostEnabled==SDL_TRUE)  hostEnabled=_stringTrue; else  hostEnabled=_stringFalse;
 if(_VoucherEgmEnabled==SDL_TRUE)  egmEnabled=_stringTrue; else  egmEnabled=_stringFalse;
 if(_VoucherHostLocked==SDL_TRUE)  hostLocked=_stringTrue; else  hostLocked=_stringFalse;
 if(_VoucherEgmLocked==SDL_TRUE)  egmLocked=_stringTrue; else  egmLocked=_stringFalse; 

  snprintf(buf,SNPRINTF_LIMIT,"hostEnabled=%s,egmEnabled=%s,egmLocked=%s,hostLocked=%s",hostEnabled,egmEnabled,egmLocked,hostLocked);

  sendClass(sockfd,destAddr,"voucher",_TheEgmID,"voucherStatus",buf);

//sendClass(sockfd,destAddr,"voucher",_TheEgmID,"voucherStatus","hostEnabled=true,egmEnabled=true,egmLocked=false:hostLocked=false");

}

char *ComputeVoucherChecksum(VOUCHER_IDS *voucher);

VOUCHER_IDS *GetVoucherValidId(char *norm,char *hyphen)
{
  int i;
  int j;
  VOUCHER_IDS *thisVoucher=NULL;
  //int sentGet=0;
  //int retrycount=0;
  
#ifndef MEXICO		// MEXICO has no dba, no printer
#ifdef XYZZY_TO_DO
    while(thisVoucher==NULL && retrycount<5)
    {
#endif //#ifdef XYZZY_TO_DO      

    for(i=0;i<VAL_ID_ARRAY_LEN && thisVoucher==NULL;i++) //find the next valid ID
      {
      if(_GlobalConfig._VoucherIds[i].valid!=0)
        thisVoucher=&_GlobalConfig._VoucherIds[i];
      }

#ifdef XYZZY_TO_DO
    if(sentGet==0)
      {
      SendGetVoucherValidationIds(_Socket,(struct sockaddr *)&_DestAddr);
      sentGet=1;
      }
    SDL_Delay(1000);                            //1 second  
    retrycount++;
    }
#endif //#ifdef XYZZY_TO_DO
    
  if(thisVoucher!=NULL)
    {
      
    char *chksum=ComputeVoucherChecksum(thisVoucher);
    
    thisVoucher->valid=0;
    _saveConfigRequired = SDL_TRUE;
    strcpy(norm,thisVoucher->Vid);
    //strcat(norm,chksum);
    i=0;
    j=0;
    while(*(norm+i)!='\0')
      {
      if(j==2 || j==7 || j==12 || j==17)
        {
        *(hyphen+j)='-';
        j++;
        }
      *(hyphen+j)=*(norm+i);
      j++;
      i++;
      }
    *(hyphen+j)='\0';
    strcat(norm,chksum);
    strcat(hyphen,chksum);
    }
  else
    {
    strcpy(norm,"111111111111");
    strcpy(hyphen,"Bad-Voucher-Id");
    }
#endif
  return thisVoucher;
}

char *ComputeVoucherChecksum(VOUCHER_IDS *voucher)
{
        static char result[3];
        unsigned char buffer[32], temp, idx, *ptr;
        int i;

        idx = 0;
        // Move the first seed value into the buffer
        ptr = (unsigned char *)&voucher->seed0;        
        for (i=sizeof(voucher->seed0)-1; i >= 0; i--, idx++)
                buffer[idx] = ptr[i];
        // Move the second seed value into the buffer
        ptr = (unsigned char *)&voucher->seed1;
        for ( i=sizeof(voucher->seed1)-1; i >= 0; i--, idx++)
                buffer[idx] = ptr[i];
        // Move the Validation ID into the buffer
        for (i=0; i<16; i++, idx++)
                buffer[idx] = voucher->Vid[i];
        // Perform the byte-by-byte XOR over the buffer
        temp = buffer[0];
        for (i=1; i<sizeof(buffer); i++)
                temp = temp ^ buffer[i];
        // Modulus 100 to ensure only two digits
        temp %= 100;
        // Build the result buffer
        result[0] = temp / 10 + '0';
        result[1] = temp % 10 + '0';
        result[2] = '\0';
        return(result);
}

unsigned short CRC(char *s,int len, unsigned short crcval)
{
register unsigned c,q;
        for (; len; len--) {
                c = *s++;
                q = (crcval ^ c) & 017;
                crcval = (crcval >> 4) ^ (q * 010201);
                q = (crcval ^ (c >> 4)) & 017;
                crcval = (crcval >> 4) ^ (q * 010201);
        }
        return (crcval);
}

unsigned long cvtbcd4(char *x)
{
        unsigned char tmp[2];
        unsigned long hi, lo, total;

        tmp[0]=*x;
        tmp[1]='\0';
        sscanf(tmp,"%ld",&hi);
        tmp[0]=*(x+1);
        sscanf(tmp,"%ld",&lo);
        //printf("hi=%d lo=%d\n",hi,lo);
        total=(hi<<28)+(lo<<24);
        //printf("hi=%d lo=%d   hi=0x%02x\n",hi,lo,hi);
        // 2nd byte
        tmp[0]=*(x+2);
        tmp[1]='\0';
        sscanf(tmp,"%ld",&hi);
        tmp[0]=*(x+3);
        sscanf(tmp,"%ld",&lo);
        //printf("hi=%d lo=%d\n",hi,lo);
        total=total + (hi<<20)+(lo<<16);

        // 3rd byte
        tmp[0]=*(x+4);
        tmp[1]='\0';
        sscanf(tmp,"%ld",&hi);
        tmp[0]=*(x+5);
        sscanf(tmp,"%ld",&lo);
        //printf("hi=%d lo=%d\n",hi,lo);
        total=total + (hi<<12)+(lo<<8);

        // 4th byte
        tmp[0]=*(x+6);
        tmp[1]='\0';
        sscanf(tmp,"%ld",&hi);
        tmp[0]=*(x+7);
        sscanf(tmp,"%ld",&lo);
        //printf("hi=%d lo=%d\n",hi,lo);
        total=total + (hi<<4)+lo;
        return total;
}

#ifdef SASMODE
unsigned char *GenSEV()
{
        unsigned int sum=0;
        unsigned char tmpstr[2];
        static unsigned char finalstr[19];
        int i;
        unsigned short crc;
        unsigned long x9;
        unsigned char x9str[9];

        _GlobalMeters.sevSeq++;
        if (_GlobalMeters.sevSeq == 0)
                _GlobalMeters.sevSeq = 1;
        seva[0]=_GlobalMeters.sevSeq&0xff;
        seva[1]=(_GlobalMeters.sevSeq>>8)&0xff;
        seva[2]=(_GlobalMeters.sevSeq>>16)&0xff;
        // for (i=0; i<6; i++) fprintf(_debugPort,"seva[%d]=%x ",i,seva[i]); fprintf(_debugPort,"\n");
        // now fill array b
        sevb[5]=seva[5]^seva[1];
        sevb[4]=seva[4]^seva[0];
        sevb[3]=seva[3]^seva[1];
        sevb[2]=seva[2]^seva[0];
        sevb[1]=seva[1];
        sevb[0]=seva[0];
        // now fill array c using crc algorithm
        crc = CRC(&sevb[4],2,0);
        sevc[4] = crc & 0xff;             //CRC LSB
        sevc[5] = (crc >> 8) & 0xff;
        crc = CRC(&sevb[2],2,0);
        sevc[2] = crc & 0xff;             //CRC LSB
        sevc[3] = (crc >> 8) & 0xff;
        crc = CRC(&sevb[0],2,0);
        sevc[0] = crc & 0xff;             //CRC LSB
        sevc[1] = (crc >> 8) & 0xff;
        // now binary to bcd (c5, c4, c3)
        x9=0;
        x9=(sevc[5]<<16) | (sevc[4]<<8) | sevc[3];
        sprintf(x9str,"%08ld",x9); //where x9 is the meter in question
        x9=cvtbcd4(x9str);
        sprintf(x9str,"%08lx",x9);
        tmpstr[1]='\0';
        for (i=0; i<8; i++) {
                tmpstr[0]=x9str[i];
                sum = sum + atoi(tmpstr);
        }
        tmpstr[0]=x9str[0];
        sum = atoi(tmpstr) | ((sum%5)<<1);
        sprintf(tmpstr,"%d",sum); x9str[0]=tmpstr[0];
        strcpy(finalstr,x9str); // *************************************************************
        // now binary to bcd (c2, c1, c0)
        x9=0;
        x9=(sevc[2]<<16) | (sevc[1]<<8) | sevc[0];
        sprintf(x9str,"%08ld",x9); //where x9 is the meter in question
        x9=cvtbcd4(x9str);
        sprintf(x9str,"%08lx",x9);
        tmpstr[1]='\0';
        sum=0;
        for (i=0; i<8; i++) {
                tmpstr[0]=x9str[i];
                sum = sum + atoi(tmpstr);
        }
        tmpstr[0]=x9str[0];
        sum = atoi(tmpstr) | (sum%5)<<1;
        sprintf(tmpstr,"%d",sum);
        x9str[0]=tmpstr[0];
        strcat(finalstr,x9str);
        return finalstr;
}

// Secure Enhanced Validation (SEV)
VOUCHER_IDS *GenSASVoucherValidId(char *norm,char *hyphen)
{
  int i;
  int j;
  VOUCHER_IDS *thisVoucher=NULL;
  //unsigned char fullvid[19] = "65";
#ifndef MEXICO		// MEXICO has no dba, no printer
  unsigned char fullvid[19] = "00";

  thisVoucher=&_GlobalConfig._VoucherIds[0];

  if(thisVoucher!=NULL)
    {
	unsigned char *xy;
    //char *chksum=ComputeVoucherChecksum(thisVoucher);
	xy=GenSEV();
	strcpy(thisVoucher->Vid,xy);
#ifdef notdef
	fprintf(_debugPort, "thisVoucher->Vid=%s\n",thisVoucher->Vid);
#endif
	strcat(fullvid,thisVoucher->Vid);//starts with "65"+16 chars--This will change
    thisVoucher->valid=0;
//FlashMem_SaveConfig();
    //strcpy(norm,thisVoucher->Vid);
    strcpy(norm,fullvid);
    //strcat(norm,chksum);
    i=0;
    j=0;
    while(*(norm+i)!='\0')
      {
      if(j==2 || j==7 || j==12 || j==17)
        {
        *(hyphen+j)='-';
        j++;
        }
      *(hyphen+j)=*(norm+i);
      j++;
      i++;
      }
    *(hyphen+j)='\0';
    //strcat(norm,chksum);
    //strcat(hyphen,chksum);
    }
  else
    {
    strcpy(norm,"111111111111");
    strcpy(hyphen,"Bad-Voucher-Id");
    }
#endif
  return thisVoucher;
}

// System Validation
VOUCHER_IDS *GenSASSystemValidId(char *norm,char *hyphen)
{
        int i;
        int j;
        VOUCHER_IDS *thisVoucher=NULL;
        //unsigned char fullvid[19] = "65";
        //unsigned char fullvid[19] = "00";
        int count = 0;
	unsigned long time57;

#ifndef MEXICO		//Mexico has no printer, no dba
        thisVoucher=&_GlobalConfig._VoucherIds[0];

        if(thisVoucher!=NULL)
        {
                //unsigned char *xy;
                //xy=GenSEV();
	      if (IsChirping() || (IsSAS_QueueEmpty() == SDL_FALSE)) {	// SAS down or ValidationQ not empty
			instate57 = 99;
	      } else {
                AddOneBytePExcQ(0x57);  // System Validation Request
                putst57 = SDL_GetTicks() + 1600; // 800; for Konami
		//time57 = SDL_GetTicks() + 12000; //12 secs.
		time57 = SDL_GetTicks() + 50000; //12 secs.
                instate57 = 1;		// 1st state / waiting for Host to issue 0x57 poll/cmd
		SVVid[0]='\0';
                // wait for SAS host to set SVVid[];
                while ((instate57 != 3) && (instate57 != 99))
                {
                        SAS_Delay(10);
			//fprintf(_debugPort, "Hung at GenSASSystemValidId\n");
#ifdef notdef
                        if (++count == 1000000)
                                fprintf(_debugPort, "Hung at GenSASSystemValidId\n");
#endif
			if ((SDL_GetTicks() > time57) || (IsChirping() == SDL_TRUE)) { //weve waited long enuf so bail
#ifdef notdef
				fprintf(_debugPort, "GenSASSystemValidId 12 sec t/o\n");
#endif
				instate57=99;
				break;
			}
                }
	      }
                if ((instate57 == 99)) {	// Host Denied System Validation
                        instate57 = 0;
#ifdef notdef
                        fprintf(_debugPort,"Host Denied System Validation\n");
#endif
                        return NULL;                    // Signal Caller
                }
                strcpy(thisVoucher->Vid,SVVid);
#ifdef notdef
                fprintf(_debugPort,"thisVoucher->Vid=%s SVVid=%s\n",thisVoucher->Vid,SVVid);
#endif
                //strcat(fullvid,thisVoucher->Vid);//starts with "65"+16 chars--This will change
                thisVoucher->valid=0;
                strcpy(norm,SVVid);
                i=0;
                j=0;
                while(*(norm+i)!='\0')
                {
                        if(j==2 || j==7 || j==12 || j==17)
                        {
                                *(hyphen+j)='-';
                                j++;
                        }
                        *(hyphen+j)=*(norm+i);
                        j++;
                        i++;
                }
                *(hyphen+j)='\0';
        }
        else
        {
                strcpy(norm,"111111111111");
                strcpy(hyphen,"Bad-Voucher-Id");
        }
#endif
        return thisVoucher;
}

// System Validation
VOUCHER_IDS *GenSASSystemValidIdNoPrint(char *norm,char *hyphen)
{
        int i;
        int j;
        VOUCHER_IDS *thisVoucher;
        thisVoucher=&_GlobalConfig._VoucherIds[0];
	return thisVoucher;
}
#endif

void extractDataPairs(char *rawdata,DATA_PAIRS *dpairs,int count)
{
  int i;
  int j;
  for(i=0;i<count;i++)
    {
    char *str=dpairs[i].key;
    char *fnd=strstr(rawdata,str);
    char *fnd1;
    int len = strlen(str);
  
    while ((fnd != NULL) && (fnd[len] != '=')) {
      // only a partial match, try again. Must be a complete match.
      fnd1 = fnd;
      fnd = strstr(fnd1, str);
    }

    dpairs[i].data[0]='\0';
    if(fnd!=NULL)
      {
      while(*fnd!='\0' && *fnd!='=')
        fnd++;
      if(*fnd=='=')
        {
        fnd++;
        j=0;
        while(*fnd!='\0' && *fnd!=',' && *fnd!=':')
          {
          if(j<DPAIR_LEN)
            {
            dpairs[i].data[j]=*fnd;
            j++;
            }
          fnd++;
          }
        dpairs[i].data[j]='\0';
        }
      }

    }
}

void extractDataPairsDelim(char *rawdata,DATA_PAIRS *dpairs,int count,char delim)
{
  int i;
  int j;
  
  char buf[2049+1024];
  strcpy(buf, rawdata);
  char *cptr = buf;
  
  for(i=0;i<count;i++)
    {
    char *str=dpairs[i].key;
    char *fnd=strstr(cptr,str);

    dpairs[i].data[0]='\0';
    if(fnd!=NULL)
      {
      while(*fnd!='\0' && *fnd!='=')
        fnd++;
      if(*fnd=='=')
        {
        fnd++;
        j=0;
        while(*fnd!='\0' && *fnd!=delim && *fnd!= ':')
          {
          if(j<DPAIR_LEN)
            {
            dpairs[i].data[j]=*fnd;
            j++;
            }
          fnd++;
          }
        dpairs[i].data[j]='\0';
        }
      } else {		// not found
	dpairs[i].data[0]='\0';
      }

    }
}

// parse a string of numbers, size long,  delim separated
void parseNext(char *rawdata,long *value,int count, char delim)
{
  int i;
  int j;
  char datastr[1024];
  char srcdata[1024];
  char *fnd = srcdata;
  char c;
  long val;
  
  strcpy (srcdata, rawdata);
  for(i=0;i<count;i++)
  {
    char *str=datastr;
    
    if (strlen(fnd) == 0) {
	    *value++ = 0;
    } else {
      memset(&datastr[0], '\0', 1024);	// clear buffer
      c = *fnd++;
      while(c!='\0' && c!=delim) {
        *str++ = c;
	c = *fnd++;
      }
      *str++ = '\0';
      val = 0;
      if (strlen(datastr)>0) {
        sscanf(datastr, "%ld", &val);
      }
      *value++ = val;
    }
  }
}

// parse a string of numbers, size char,  delim separated
void parseNextChar(char *rawdata,char *value,int count, char delim)
{
  int i;
  int j;
  char datastr[1024];
  char srcdata[1024];
  char *fnd = srcdata;
  char c;
  long val;
  
  strcpy (srcdata, rawdata);
  for(i=0;i<count;i++)
  {
    char *str=datastr;
    
    if (strlen(fnd) == 0) {
	    *value++ = 0;
    } else {
      memset(&datastr[0], '\0', 1024);	// clear buffer
      c = *fnd++;
      while(c!='\0' && c!=delim) {
        *str++ = c;
	c = *fnd++;
      }
      *str++ = '\0';
      val = 0;
      if (strlen(datastr)>0) {
        sscanf(datastr, "%ld", &val);
      }
      *value++ = val;
    }
  }
}

// parse a string of chars, size char,  delim separated
void parseNextStr(char *rawdata,char *value,int count, char delim)
{
  int i;
  int j;
  char datastr[1024];
  char srcdata[1024];
  char *fnd = srcdata;
  char c;
  long val;
  
  strcpy (srcdata, rawdata);
  for(i=0;i<count;i++)
  {
    char *str=datastr;
    
    if (strlen(fnd) == 0) {
	    *value++ = 0;
    } else {
      memset(&datastr[0], '\0', 1024);	// clear buffer
      c = *fnd++;
      while(c!='\0' && c!=delim) {
        *str++ = c;
	c = *fnd++;
      }
      *str++ = '\0';
      //val = 0;
      if (strlen(datastr)>0) {
        //sscanf(datastr, "%ld", &val);
        strcpy(value, datastr);
      }
      //*value++ = val;
    }
  }
}

void sort ( long * data, int cnt)
{
	long buf[20];
	int i,j,k;
	long value;
	
	int ii = 0;
	for (i=0; i<cnt; i++) {
		buf[i] = 0;
		if (data[i] > 0) 
			++ii;
	}
	
	for (i=0; i<ii; i++) {
		value = data[i];
		if ((i==0) || (value > buf[i-1]))
			buf[i] = value;	// 1st entry or highest
		else if (value < buf[0]) {	// lowest
			for (j=i; j>0; j--) {
				buf[j] = buf[j-1];
			}
			buf[0] = value;
		} else {
			k = 0;
			for (j=1; (j<i) && (k==0); j++) { 	// look for position to insert
				if (value < buf[j])
					k = j;
			}
			for (j=i; j>k; j--)			// shift up from position
				buf[j] = buf[j-1];
			buf[k] = value;
		}
	}
	for (i=0; i<cnt; i++)
		data[i] = buf[k];
}

int GetDenomLevel(int denom)
{
	int i;
	
	//if (_ExtendedConfig.ProgControllerType == 2) {  // we can use _GlobalMeters.jackpotValues
		for (i=1; i<6; i++) {
			if (denom == _dToLevel[i]) {
				return i;
			}
		}
	//}
	return 0;
}

#ifndef SASMODE
int SASExecute()
{
}

void SAS_Delay(int count)
{
        int lastTime;

        if (count < 0)                                            // only allow positive counts
        {
                SASExecute();
                return;
        }
        lastTime = SDL_GetTicks();
        while ((SDL_GetTicks() - lastTime) < count)                                        
                SASExecute();                                // keep checking for SAS data until time expires
}

void AddGameEndExcQ()
{
#ifdef notdef
	if (_SentGameEndFlg == 1) {
		fprintf(_debugPort,"Skip GE\n");
		_SentGameEndFlg = 0;
		return;
	}
	//if (instate51) {
	if (_alarmState && (_SentGameEndFlg!=99)) {
		fprintf(_debugPort,"Skip GE2\n");
		return;
	}
#endif
        if (_ExtendedConfig.ProgControllerType == 2) {   // if CasinoNet Controlled Progressive then send it.
                //SendGameActivity(_LastWin,_ProgressiveWin);
		//SendGameActivity(_LastWin4GameActivity, _GlobalMeters._ProgressiveWin);
		SendGameActivity(_LastWin4GameActivity, _LastProgWin4GameActivity);
        }
	_LastWin4GameActivity = 0;
	_LastProgWin4GameActivity = 0;
	fprintf(_debugPort, "[6] _LastWin4GameActivity=%lld\n",_LastWin4GameActivity);
	_SentGameEndFlg = 1;
}
#endif

#ifdef BINGO
void ShowBingoPatterns(void)
{
	int i,j,k,l;
	unsigned long pattern;
	int level = GetCurrentBetLevel();
	
	for (i=0; i<20; i++) {
		fprintf(_debugPort, "\n%s: ",bingoPatterns[i].name[level]);
		for (j=0; j<bingoPatterns[i].count[level]; j++) {
			pattern = bingoPatterns[i].squaresBitmap[level][j];
			for (k=0; k<25; k++) {
				if ((k % 5) == 0)
					fprintf(_debugPort,"\n");
				if ((pattern & ( 1 << k)) == 0)
					fprintf(_debugPort,"0");
				else
					fprintf(_debugPort,"1");
			}
			
		}
	}
	
	for (l=0; l<4; l++) {
		fprintf(_debugPort, "\nLEVEL %d:\n", l+1);
		for (j=1; j<=BALLS_DRAWN; j++) {
			if (bingoPatterns[0].winamount[l][j] > 0) {
				fprintf(_debugPort, "[%02d] ",j);
				for (i=0; i<8; i++) {
					fprintf(_debugPort, "%04d:",bingoPatterns[i].winamount[l][j]);
				}
				//fprintf(_debugPort, "\n%d Balls Called: %d", j, bingoPatterns[i].winamount[l][j]);
				fprintf(_debugPort, "\n");
			}

		}
	}
}

#endif

#ifdef BINGO
SDL_bool IsBingoPatternsDone()
{
#ifdef nomore
 #ifdef PULLTAB
	return SDL_TRUE;
 #else
	return bingoPatternsDone;
 #endif
#endif
	return SDL_TRUE;
}
#endif

SDL_bool ServerReady()
{
	//if (_ExtendedConfig.networkEnabled == 0) return SDL_TRUE;
#ifdef BINGO
	SDL_bool currNetCommStat = (IsBingoPatternsDone() && _GEPamtReceived && _progressiveValueReceived);
#else
	SDL_bool currNetCommStat = _progressiveValueReceived;
#endif
	static SDL_bool lastNetCommStat = SDL_FALSE;

#ifdef BINGO
 #ifdef TABLET
	if ((IsWaiting4APIack() == SDL_TRUE) && SignalLevelTooLow() == SDL_TRUE)
		return SDL_FALSE;
 #endif
 #ifdef notdef
	if ((IsBingoPatternsDone() && _GEPamtReceived && _progressiveValueReceived) == SDL_FALSE) {
		fprintf(_debugPort, "IsBingoPatternDone=%d, _GEPamtReceived=%d, _progressiveValueReceived=%d\n",
			IsBingoPatternsDone(), _GEPamtReceived,_progressiveValueReceived);
	}
 #endif
#endif
#ifdef CLASS3_OR_BINGOSAS_OR_PULLTAB

	if (_ExtendedConfig.networkEnabled == 1) {
		if (lastNetCommStat != currNetCommStat) {
			lastNetCommStat = currNetCommStat;
			if (currNetCommStat == SDL_TRUE) 
                    		FlashEvent(4,"NET COMM UP", EV_CNET_UP);
			else {
                    		FlashEvent(4,"NET COMM DOWN", EV_CNET_DOWN);
#ifdef BINGO
				int lev;
				for (lev=0; lev<5; lev++) {
				    if (PatLoaded[lev] == 1) PatLoaded[lev] = 0;
				    if (PayLoaded[lev] == 1) PayLoaded[lev] = 0;
				}
#endif
			}
		}
	}
 #ifdef BINGO
	if (currNetCommStat == SDL_TRUE) {
		int lev;
		
		ReloadBingoFiles();
		for (lev=0; lev<5; lev++) {
			if (PatLoaded[lev] != 4) return SDL_FALSE;
			if (PayLoaded[lev] != 4) return SDL_FALSE;
		}
		return currNetCommStat;
	} else
 #endif
	return currNetCommStat;
#else
	return _progressiveValueReceived;
#endif
}

#ifdef TABLET
void ForceReconnect()
{
#ifndef PRODUCTION
	fprintf(_debugPort, "ForceReconnect %s %d\n",getTimeStamp(),GetSignalLevel());
#endif
	_keepAliveSent = SDL_FALSE;
	_BrokenPipe = SDL_TRUE;
	_progressiveValueReceived = SDL_FALSE;
	Network_Close();
	//system(sudostr1);
}

SDL_bool ServerConnectionBroken()
{
	if (_BrokenPipe == SDL_TRUE && _progressiveValueReceived == SDL_FALSE)
		return SDL_TRUE;
	return SDL_FALSE;
}
#endif

void ForceKeepAlive()
{
	forceKeepAlive = SDL_TRUE;
}

#ifdef LOG2FILE
 void SaveHistoryBuf()
 {
	WriteFile("gameHistTrans", lastGameHist, 1024, 0);
 }

 void SaveLastActivityBuf()
 {
	WriteFile("gameactivity", lastGAbuf, 1024, 0);
 }

 #ifdef CS030
void SaveLastTimeBuf()
{
	WriteFile("poweroff", lastTimeBuf, 32, 0);
	lastTimeTick = SDL_GetTicks();
}

void TimedSaveLastTimeBuf() {
	unsigned long ticks = SDL_GetTicks();
	if ((ticks - lastTimeTick) > (60000*1))
		SaveLastTimeBuf();
}
#endif

#ifdef USE_MAG_CARD
  void SavePurchaseBuf()
  {
	WriteFile("purchaseinfo", lastPurchasebuf, 1024, 0);
  }
 #else
  void SaveCashInfoBuf()
  {
	WriteFile("cashinfo", lastCIbuf, 1024, 0);
  }
 #endif

 void ReloadLastHistoryBuf()
 {
	ReadFile("gameHistTrans", lastGameHist, 1024, 0);
 }

 #ifdef USE_MAG_CARD
 void ReloadPurchaseBuf()
 {
	ReadFile("purchaseinfo", lastPurchasebuf, 1024, 0);
 }
 #else
 void ReloadCashInfoBuf()
 {
	ReadFile("cashinfo", lastCIbuf, 1024, 0);
 }
 #endif

 void ReloadLastActivityBuf()
 {
	if (IsWaiting4PurchaseAck() == SDL_TRUE)
  #ifdef USE_MAG_CARD
		ReloadPurchaseBuf();
  #else
		ReloadCashInfoBuf();
  #endif
	if (IsWaiting4HistoryAck() == SDL_TRUE)
		ReloadLastHistoryBuf();
	if (IsWaiting4GameActivityAck() == SDL_TRUE)
		ReadFile("gameactivity", lastGAbuf, 1024, 0);
#ifdef PULLTAB
	ReloadLastTicBuf();
#endif
 }

#ifdef CS030
void UpdateLastTime()
{
#ifdef notdef
        struct timeb tb;
        struct tm *t;

        ftime(&tb);

        //t=gmtime(&tb.time);
        t=localtime(&tb.time);
	//yyyyMMddhhmmssnnn
	sprintf(lastTimeBuf,"%d/%d/%d  %02d:%02d:%02d", t->tm_mon+1, t->tm_mday, t->tm_year+1900, t->tm_hour, t->tm_min, t->tm_sec);
#endif
	strcpy(lastTimeBuf, getTimeStamp());
}

void LoadLastPowerOffTime()
{
	UpdateLastTime();
	strcpy(lastPowerOffTime, "");
	ReadFile("poweroff", lastPowerOffTime, 32, 0);
	if (strlen(lastPowerOffTime) == 0)
		strcpy(lastPowerOffTime, lastTimeBuf);
	else {
		FlashEventWithTimeStamp(4, "NET COMM DOWN", lastPowerOffTime, EV_CNET_DOWN);
		FlashEventWithTimeStamp(4, "POWER OFF", lastPowerOffTime, EV_PWR_OFF);
	}
	FlashEventWithTimeStamp(4, "POWER ON", lastTimeBuf, EV_PWR_ON);
//	SaveLastTimeBuf();
}
#endif


 void SaveLastProgHitBuf()
 {
	WriteFile("proghit", lastProgHitbuf, 1024, 0);
 }

 void ReloadLastProgHitBuf()
 {
	ReadFile("proghit", lastProgHitbuf, 1024, 0);
	ReadFile("proghit", lastProgCelebBuf, 1024, 0);
 }


#endif

SDL_bool LastGameActivityAcked()
{
	if (bonusInfo.waiting4GAack == 0) {
		return SDL_TRUE;		// last game activity acked
	}
	return SDL_FALSE;
}

SDL_bool LastProgHitAcked()
{
	if (bonusInfo.waiting4ProgHitAck == 0) {	// last progressive hit acked
		return SDL_TRUE;
	}
	return SDL_FALSE;
}

SDL_bool IsWaiting4APIack()
{
	// return true if waiting on:
	//  bit 0 progressive:gameActivity ack
	//  bit 1 bingo:history ack
	//  bit 2 progressive:purchase ack
	if (bonusInfo.waiting4GAack) return SDL_TRUE;
	else return SDL_FALSE;
}

SDL_bool IsWaiting4GameActivityAck()
{
	if (bonusInfo.waiting4GAack & 1) return SDL_TRUE;
	return SDL_FALSE;
}

void SetWaiting4GameActivityAck()
{
	bonusInfo.waiting4GAack |= 1;
}

void ClearWaiting4GameActivityAck()
{
	bonusInfo.waiting4GAack &= ~1;
}


SDL_bool IsWaiting4HistoryAck()
{
	if (bonusInfo.waiting4GAack & 2) return SDL_TRUE;
	return SDL_FALSE;
}

void SetWaiting4HistoryAck()
{
	bonusInfo.waiting4GAack |= 2;
}

void ClearWaiting4HistoryAck()
{
	bonusInfo.waiting4GAack &= ~2;
}


SDL_bool IsWaiting4PurchaseAck()
{
	if (bonusInfo.waiting4GAack & 4) return SDL_TRUE;
	return SDL_FALSE;
}

void SetWaiting4PurchaseAck()
{
	bonusInfo.waiting4GAack |= 4;
}

void ClearWaiting4PurchaseAck()
{
	bonusInfo.waiting4GAack &= ~4;
}

void SetWaiting4ProgHitAck()
{
	bonusInfo.waiting4ProgHitAck = 1;
}

void ClearWaiting4ProgHitAck()
{
	bonusInfo.waiting4ProgHitAck = 0;
}



// returns waiting for api ack flags
int GetWaitAPIflags()
{
	return bonusInfo.waiting4GAack & 0x0f;
}

void GetServerIP(char *server)
{
	sprintf(server,"%d.%d.%d.%d",_GlobalConfig.ServerIPAddress[0],_GlobalConfig.ServerIPAddress[1], _GlobalConfig.ServerIPAddress[2],_GlobalConfig.ServerIPAddress[3]);
}

int GetServerPort(void)
{
#ifdef MAMBOSKIN
	return _GlobalConfig.ServerPort-1;  //Base 0 to 1 Change   ie. egm setup as 1 but we send a 0 to CasinoNet
#else
	return _GlobalConfig.ServerPort-1;  //Base 0 to 1 Change   ie. egm setup as 1 but we send a 0 to CasinoNet
#endif
}

// betlevel is base 0
int GetPayTableLevel(int betlevel)
{
#ifdef BINGO
	//fprintf(_debugPort, "GetPayPercent(%d), %d\n", GetMaxPayLevel(), _GlobalConfig.payPercent[GetMaxPayLevel()-1]);
	return (_GlobalConfig.payPercent[GetMaxPayLevel()-1]);
#else
	return (_GlobalConfig.payPercent[_maxBetLevel-1]*100);
#endif

}

// get denom multiplier
int GetDenomX()
{
	return _Denominations[_currentDenomination];
}

#ifdef BINGO
void RequestPatFile(int level) {
	extern char *GetMathBase();
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];
	
	if (_ExtendedConfig.commEnabled == 0) return;
	if (ipaddr[strlen(ipaddr)-1] == ' ')
		ipaddr[strlen(ipaddr)-1] = 0;
	sprintf(buf, "fn=%s:ipaddr=%s:", _BCInfo.PatName[level], ipaddr);
	sendClass(_Socket, dest_addr, "bingo", _TheEgmID, "getfile", buf);
	PatLoaded[level] = 1;		// request sent
}

void RequestPayFile(int level) {
	extern char *GetMathBase();
        struct sockaddr *dest_addr=(struct sockaddr *)&_DestAddr;
        char buf[SNPRINTF_LIMIT+1];

	if (_ExtendedConfig.commEnabled == 0) return;
	if (ipaddr[strlen(ipaddr)-1] == ' ')
		ipaddr[strlen(ipaddr)-1] = 0;
	sprintf(buf, "fn=%s:ipaddr=%s:", _BCInfo.PayName[level], ipaddr);
	sendClass(_Socket, dest_addr, "bingo", _TheEgmID, "getfile", buf);
	PayLoaded[level] = 1;		// request sent
}
#endif

